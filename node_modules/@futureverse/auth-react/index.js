import { jsx as A } from "react/jsx-runtime";
import { createContext as O, useState as P, useEffect as m, useMemo as l, useCallback as u, useContext as x } from "react";
import { useQuery as v } from "@tanstack/react-query";
import { useDisconnect as S, WagmiProvider as U, useAccount as W, useConnect as q, useConfig as I, useWalletClient as L } from "wagmi";
import { connectAndSignIn as b } from "@futureverse/wagmi-connectors";
import { clientToSigner as E } from "@futureverse/signer";
const F = O(null), z = ({
  authClient: n,
  children: t,
  signer: o
}) => {
  const [r, c] = P(n.userSession), { disconnect: i } = S(), { isFetching: a } = v({
    queryKey: ["verifyAndLoadUser"],
    queryFn: async () => await n.verifyAndLoadUser(),
    refetchOnWindowFocus: "always"
  });
  m(() => {
    r == null && i();
  }, [i, r]), m(() => {
    const e = (s) => {
      c(s);
    };
    return n.addUserStateListener(e), () => n.removeUserStateListener(e);
  }, [n]);
  const f = l(() => {
    if (r != null)
      return n.getSessionAuthType();
  }, [n, r]), d = u(
    async (e) => await n.signInPass({
      signer: o,
      ...e
    }),
    [n, o]
  ), g = u(
    async (e = { flow: "redirect" }) => {
      await n.signOut({
        flow: e == null ? void 0 : e.flow,
        onBeforeRedirect: e == null ? void 0 : e.beforeSignOut
      }), i();
    },
    [n, i]
  ), w = u(
    async (e = { flow: "redirect" }) => {
      await n.signOutPass(e), i();
    },
    [n, i]
  );
  return /* @__PURE__ */ A(
    F.Provider,
    {
      value: {
        signIn: d,
        signOut: g,
        signOutPass: w,
        authClient: n,
        userSession: r,
        authMethod: f,
        isFetchingSession: a
      },
      children: t
    }
  );
}, B = ({
  initialState: n,
  getWagmiConfig: t,
  reconnectOnMount: o,
  children: r
}) => {
  const { data: c } = v({
    queryKey: ["wagmiConfig"],
    queryFn: async () => await t(),
    structuralSharing: !1,
    refetchOnWindowFocus: !1,
    refetchOnMount: !1
  });
  return c ? /* @__PURE__ */ A(
    U,
    {
      config: c,
      initialState: n,
      reconnectOnMount: o,
      children: r
    }
  ) : null;
};
function M() {
  const n = x(F);
  if (n === null)
    throw new Error("useAuth must be used inside FutureverseAuthProvider");
  return n;
}
const N = () => {
  const { isConnected: n, connector: t, isConnecting: o } = W(), { connectAsync: r, connectors: c } = q(), { disconnectAsync: i } = S(), a = I(), { authClient: f } = M(), d = u(
    // This curious type is a string type with autocomplete for known values
    async (e) => {
      const s = c.find((h) => h.id === e);
      if (!s)
        throw new Error(`Failed to find connector ${e}`);
      return s !== t && await (t == null ? void 0 : t.disconnect()), await s.isAuthorized() || await r({ connector: s }), await s.getAccounts();
    },
    [r, t, c]
  ), g = u(
    async (e) => {
      const s = c.find((y) => y.id === e) ?? t;
      s || console.warn("No active connector to disconnect from"), await i({ connector: s });
    },
    [c, i, t]
  ), w = u(
    async (e, s) => b(e, f, a, s),
    [f, a]
  );
  return {
    connect: d,
    connectAndSignIn: w,
    disconnect: g,
    isConnected: n,
    connector: t,
    isConnecting: o,
    connectors: c
  };
};
function Q({
  chainId: n,
  connector: t
} = {}) {
  const { data: o } = L({ chainId: n, connector: t });
  return l(() => o ? E(o) : void 0, [o]);
}
export {
  z as FutureverseAuthProvider,
  B as FutureverseWagmiProvider,
  F as futureverseAuthContext,
  M as useAuth,
  N as useConnector,
  Q as useFutureverseSigner
};
