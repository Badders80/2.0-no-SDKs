import "@therootnetwork/api-types";
import { blake2AsHex as P } from "@polkadot/util-crypto";
import { hexToString as S, formatBalance as A, hexToU8a as C, BN as v } from "@polkadot/util";
import { XamanSigner as F } from "@futureverse/signer";
import { encodeFunctionData as I, decodeFunctionResult as q, isAddress as d } from "viem";
class D {
  constructor(t, e) {
    this.api = t, this.walletAddress = e;
  }
  /**
   * Gets the FuturePass for the wallet address
   *
   * @param walletAddress - the wallet address to get the FuturePass for
   * @returns the FuturePass for the wallet address
   * @throws an error if the API is not connected or if the wallet address is not provided
   */
  async getFuturePass(t) {
    if (!this.api)
      throw new Error("API is not connected");
    if (!t || t === "")
      throw new Error("Address is required");
    const e = (await this.api.query.futurepass.holders(t)).unwrapOr(null);
    if (!e)
      throw new Error(
        "No FuturePass Found, please connect with your primary ETH address"
      );
    return e.toString();
  }
  /**
   * Gets the balance of an asset
   * Wallet address is optional, if not provided, the wallet address of the instance will be used
   *
   * @param walletAddress - (optional) the wallet address to get the balance for
   * @param assetId - the asset ID to get the balance for
   * @returns the balance of the asset
   *
   */
  async checkBalance({
    walletAddress: t,
    assetId: e
  }) {
    if (!this.api)
      throw new Error("API is not connected");
    if (!e)
      throw new Error("Asset ID is required");
    const r = await this.api.query.assets.metadata(e), i = await this.api.rpc.assetsExt.freeBalance(
      e,
      t ?? this.walletAddress
    );
    return {
      assetId: e,
      walletAddress: t ?? this.walletAddress,
      balance: i.toString(),
      decimals: parseInt(r.decimals.toString())
    };
  }
  /**
   * Checks the balances of multiple assets for given wallet addresses
   * Wallet address is optional, if not provided, the wallet address of the instance will be used
   *
   * @param walletAddressAssetIds - the [walletAddresses, assetId] pair to check balances for
   * @returns the balances of the assets
   * @throws an error if the API is not connected or if the wallet address and asset IDs are not provided
   */
  async checkBalances(t) {
    if (!this.api)
      throw new Error("API is not connected");
    if (!t)
      throw new Error("Address and Asset IDs are required");
    const e = async ({
      walletAddress: o
    }) => {
      const h = await this.api.rpc.assetsExt.freeBalance(
        1,
        o ?? this.walletAddress
      );
      return {
        assetId: 1,
        walletAddress: o ?? this.walletAddress,
        balance: h.toString(),
        decimals: 6
      };
    }, r = ({ walletAddress: o, assetId: h }, l) => {
      var u;
      const c = a[l].unwrapOr("0");
      return {
        assetId: h,
        walletAddress: o ?? this.walletAddress,
        // @ts-expect-error --  balance is a type that is not being recognized
        balance: ((u = c == null ? void 0 : c.balance) == null ? void 0 : u.toString()) ?? "0",
        decimals: parseInt(n[l].decimals.toString())
      };
    }, i = t.filter(
      ({ assetId: o }) => o === 1
    ), s = await Promise.all(
      i.map(e)
    ), n = await this.api.query.assets.metadata.multi(
      t.filter((o) => o.assetId !== 1).map(({ assetId: o }) => o)
    ), a = await this.api.query.assets.account.multi(
      t.filter((o) => o.assetId !== 1).map(({ walletAddress: o, assetId: h }) => [h, o ?? this.walletAddress])
    );
    return [
      ...s,
      ...t.filter((o) => o.assetId !== 1).map(r)
    ];
  }
  /**
   * Gets the amounts in for the given amount and asset ID
   * Slippage is optional, if not provided, a default of 5% will be used
   *
   * @param amount - the amount to get the amounts in for
   * @param assetId - the asset ID to get the amounts in for
   * @param slippage - (optional) the slippage to use for the amounts in
   * @returns the amounts in for the given amount and asset ID
   */
  async getAmountsIn(t, e, r = 5) {
    const {
      Ok: [i]
    } = await this.api.rpc.dex.getAmountsIn(t, [
      e,
      T
    ]);
    return BigInt(Math.round(Number(i * (1 + r / 100))));
  }
  /**
   * Reads a contract function and returns the decoded result
   *
   * @param contractAddress - the contract address to read from
   * @param abi - the ABI of the contract
   * @param functionName - the function name to read
   * @param args - the arguments to pass to the function
   * @returns the decoded result of the contract function
   */
  async readContract({
    contractAddress: t,
    abi: e,
    functionName: r,
    args: i
  }) {
    if (!this.api)
      throw new Error("API is not connected");
    if (!t)
      throw new Error("Contract Address is required");
    if (!e)
      throw new Error("ABI is required");
    if (!r)
      throw new Error("Function Name is required");
    const s = await I({
      abi: e,
      functionName: r,
      args: i
    }), n = await this.api.rpc.eth.call({
      to: t,
      data: s
    });
    return await q({
      abi: e,
      functionName: r,
      data: n.toHex()
    });
  }
}
const T = 2, G = 6, W = "XRP";
class f {
  constructor(t, e, r) {
    this._baseExtrinsic = null, this._extrinsicToSend = null, this._futurePassWrapped = !1, this._feeProxyWrapped = !1, this._xamanWrapped = !1, this._ethPayload = null, this._trnPayload = null, this._gasFee = "0", this._gasToken = 2, this._gasString = "", this._tokenDecimals = 0, this.api = t, this.signer = e, this.walletAddress = r, this._xamanWrapped = e instanceof F, this.queryBuilder = new D(t, r);
  }
  /**
   * Resets the RootTransactionBuilder Instance
   *
   * @returns the RootTransactionBuilder Instance
   */
  resetBase() {
    return this._baseExtrinsic = null, this._extrinsicToSend = null, this._futurePassWrapped = !1, this._feeProxyWrapped = !1, this._ethPayload = null, this._trnPayload = null, this._gasFee = "0", this._gasToken = 2, this._gasString = "", this._tokenDecimals = 0, this;
  }
  /**
   * Used internally by Root and Child Classes to check if the asset ID, collection ID or sale ID etc exists
   *
   * @returns a boolean
   */
  checks() {
    return this.exists();
  }
  /**
   * Sets the base extrinsic - used internally by Root and Child Classes
   *
   * @param extrinsic - the extrinsic to set as the base
   * @returns the RootTransactionBuilder Instance
   */
  setBaseExtrinsic(t) {
    return this.validateConnections(), this._baseExtrinsic = t, this._extrinsicToSend = t, this;
  }
  /**
   * Gets the base extrinsic - used internally by Root and Child Classes
   *
   * @returns the base extrinsic
   */
  getBaseExtrinsic() {
    return this._baseExtrinsic;
  }
  /**
   * Helper function to add a FuturePass Proxy to the extrinsic
   *
   * @param futurePass - the future pass to proxy the extrinsic through
   * @returns the RootTransactionBuilder Instance
   */
  async addFuturePass(t) {
    if (this.validateConnections(), !this._baseExtrinsic) throw new Error("Base Extrinsic is not set");
    if (this._futurePassWrapped) throw new Error("FuturePass already added");
    if (this._feeProxyWrapped)
      throw new Error(
        "Cannot add FuturePass to a FeeProxy wrapped extrinsic, please add FuturePass before FeeProxy"
      );
    const { futurePassExtrinsic: e, maxPayment: r } = await this.futurepassLogic(
      t,
      2,
      0
    );
    this.setGasFee(r.toString()), await this.setGasInfo(r.toString()), this._extrinsicToSend = e;
    const { ethPayload: i, trnPayload: s } = await this.generateExtrinsicPayloads(
      e.method
    );
    return this._ethPayload = i, this._trnPayload = s, this;
  }
  /**
   * Helper function to add a FeeProxy to the extrinsic
   *
   * @param assetId - the asset ID to pay the fee in (1 for ROOT, 2 for XRP etc)
   * @param slippage - the slippage to use for the fee - in percentage
   * @returns the RootTransactionBuilder Instance
   */
  async addFeeProxy({
    assetId: t,
    slippage: e
  }) {
    if (this.validateConnections(), !this._baseExtrinsic) throw new Error("Base Extrinsic is not set");
    if (this._feeProxyWrapped) throw new Error("FeeProxy already added");
    this._gasToken = t;
    const { maxPayment: r, feeProxyCall: i } = await this.feeProxyLogic(
      this._baseExtrinsic,
      this.walletAddress,
      t,
      e
    );
    this.setGasFee(BigInt(r).toString()), await this.setGasInfo(BigInt(r).toString()), this._feeProxyWrapped = !0, this._extrinsicToSend = i;
    const { ethPayload: s, trnPayload: n } = await this.generateExtrinsicPayloads(
      i.method
    );
    return this._ethPayload = s, this._trnPayload = n, this;
  }
  /**
   * Helper function to add a FuturePass & Fee Proxy to the extrinsic
   *
   * @param futurePass - the future pass to proxy the extrinsic through
   * @param assetId - the asset ID to pay the fee in (1 for ROOT, 2 for XRP etc)
   * @param slippage - the slippage to use for the fee - in percentage
   * @returns the RootTransactionBuilder Instance
   */
  async addFuturePassAndFeeProxy({
    futurePass: t,
    assetId: e,
    slippage: r
  }) {
    if (this.validateConnections(), !this._baseExtrinsic) throw new Error("Base Extrinsic is not set");
    this._gasToken = e;
    const { futurePassExtrinsic: i } = await this.futurepassLogic(
      t,
      e,
      r
    ), { maxPayment: s, feeProxyCall: n } = await this.feeProxyLogic(
      i,
      t,
      e,
      r
    );
    this.setGasFee(BigInt(s).toString()), await this.setGasInfo(BigInt(s).toString()), this._extrinsicToSend = n;
    const { ethPayload: a, trnPayload: o } = await this.generateExtrinsicPayloads(
      n.method
    );
    return this._ethPayload = a, this._trnPayload = o, this;
  }
  /**
   * Helper function to get the payloads for the extrinsic
   *
   * @returns the ExtrinsicPayload instance
   */
  async getPayloads() {
    var e;
    if (!await this.exists())
      throw new Error("Asset ID, Collection ID or Sale ID does not exist");
    if (this.validateConnections(), !this._ethPayload || !this._trnPayload) {
      const { ethPayload: r, trnPayload: i } = await this.generateExtrinsicPayloads(
        (e = this._extrinsicToSend) == null ? void 0 : e.method
      );
      this._ethPayload = r, this._trnPayload = i;
    }
    return { ethPayload: this._ethPayload, trnPayload: this._trnPayload };
  }
  /**
   * Gets the gas fees for the extrinsic
   *
   * @returns { gasString: string, gasFee: string, tokenDecimals: number }
   */
  async getGasFees() {
    if (this.validateConnections(), !this._extrinsicToSend) throw new Error("Extrinsic is not set");
    if (!this._futurePassWrapped && !this._feeProxyWrapped) {
      const t = await this._extrinsicToSend.paymentInfo(
        this.walletAddress
      ), e = BigInt(t.partialFee.toString());
      if (this._xamanWrapped) {
        const i = await this.getXamanCall(this._extrinsicToSend).paymentInfo(
          this.walletAddress
        ), s = BigInt(i.partialFee.toString()), n = BigInt(s);
        this.setGasFee(n.toString()), await this.setGasInfo(n.toString());
      } else
        this.setGasFee(e.toString()), await this.setGasInfo(e.toString());
    }
    return {
      gasString: this._gasString,
      gasFee: this._gasFee,
      tokenDecimals: this._tokenDecimals
    };
  }
  /**
   * Returns a signed extrinsic
   *
   * @returns the Signed Extrinsic
   */
  async sign() {
    if (this.validateConnections(), !this._extrinsicToSend) throw new Error("Extrinsic is not set");
    if ((!this._ethPayload || !this._trnPayload) && await this.getPayloads(), !await this.exists())
      throw new Error("Asset ID, Collection ID or Sale ID does not exist");
    return this.signer.signExtrinsicWithPayload(
      this.api,
      this._extrinsicToSend,
      {
        ethPayload: this._ethPayload,
        trnPayload: this._trnPayload
      },
      this.walletAddress
    );
  }
  /**
   * Signs and sends the extrinsic
   *
   * @param onSign - callback function to call when extrinsic is signed
   * @param onSend - callback function to call when extrinsic is sent
   * @returns the ExtrinsicResult instance
   */
  async signAndSend(t) {
    const e = await this.sign();
    t != null && t.onSign && t.onSign();
    const r = await this.sendExtrinsic({
      api: this.api,
      signedExtrinsic: e
    });
    return t != null && t.onSend && t.onSend(), r;
  }
  /**
   * Gets the extrinsic to send
   *
   * @returns the Extrinsic to send
   */
  getExtrinsicToSend() {
    return this._extrinsicToSend;
  }
  /**
   * Filters extrinsic events
   *
   * @param events - the events to filter
   * @param names - the names to filter by
   * @returns the filtered events
   */
  filterExtrinsicEvents({
    events: t,
    names: e
  }) {
    return t.filter(({ event: r }) => {
      const i = `${r.section[0].toUpperCase() + r.section.slice(1)}.${r.method}`;
      return e.includes(i);
    });
  }
  /**
   * Generates the extrinsic payloads - used internally by Root and Child Classes
   *
   * @param method - the method to generate the payloads for
   * @param options - the options to use
   * @returns the ExtrinsicPayload instance
   */
  async generateExtrinsicPayloads(t, e) {
    this.validateConnections();
    const { header: r, mortalLength: i, nonce: s } = await this.api.derive.tx.signingInfo(this.walletAddress), n = Object.assign(
      {
        address: this.walletAddress,
        blockHash: r == null ? void 0 : r.hash,
        blockNumber: r == null ? void 0 : r.number,
        era: this.api.registry.createTypeUnsafe("ExtrinsicEra", [
          {
            current: r == null ? void 0 : r.number,
            period: i
          }
        ]),
        genesisHash: this.api.genesisHash,
        method: t,
        nonce: s,
        runtimeVersion: this.api.runtimeVersion,
        signedExtensions: this.api.registry.signedExtensions,
        version: this.api.extrinsicVersion
      },
      e
    ), a = this.api.registry.createTypeUnsafe("SignerPayload", [
      n
    ]), { data: o } = a.toRaw(), h = o.length > 257 * 2 ? P(o) : o;
    return { ethPayload: P(h), trnPayload: a };
  }
  /**
   * Validates the that the API, Signer and Wallet Address are present - used internally by Root and Child Classes
   *
   * @returns void
   */
  validateConnections() {
    if (!this.api) throw new Error("API is missing");
    if (!this.signer) throw new Error("Signer is missing");
    if (!this.walletAddress) throw new Error("walletAddress is missing");
  }
  /**
   * Helper function to wrap the extrinsic in a FeeProxy - used internally by Root and Child Classes
   *
   * @param extrinsic - the extrinsic to wrap
   * @param assetId - the asset ID to pay the fee in (1 for ROOT, 2 for XRP etc)
   * @param slippage - the slippage to use for the fee - in percentage
   * @returns the FeeProxyExtrinsic and the maxPayment
   */
  async feeProxyLogic(t, e, r, i) {
    const s = this.api.tx.feeProxy.callWithFeePreferences(
      r,
      0,
      t
    ), n = await this.getPaymentInfo(
      s,
      e,
      r,
      i
    );
    return { feeProxyCall: this.api.tx.feeProxy.callWithFeePreferences(
      r,
      n == null ? void 0 : n.toString(),
      t
    ), maxPayment: n };
  }
  /**
   * Helper function to wrap the extrinsic in a FuturePass - used internally by Root and Child Classes
   *
   * @param futurePass - the future pass to proxy the extrinsic through
   * @param assetId - the asset ID to pay the fee in (1 for ROOT, 2 for XRP etc)
   * @param slippage - the slippage to use for the fee - in percentage
   * @returns the FuturePassExtrinsic and the maxPayment
   */
  async futurepassLogic(t, e, r) {
    const i = this.api.tx.futurepass.proxyExtrinsic(
      t,
      this._baseExtrinsic
    );
    this._futurePassWrapped = !0;
    const s = await this.getPaymentInfo(
      i,
      t,
      e,
      r
    );
    return { futurePassExtrinsic: i, maxPayment: s };
  }
  /**
   * Gets the payment info for the extrinsic - used internally by Root and Child Classes
   *
   * @param extrinsic - the extrinsic to get the payment info for
   * @param senderAddress - the sender address to get the payment info for
   * @param assetId - the asset ID to get the payment info for
   * @param slippage - the slippage to use for the payment info
   * @returns the payment info
   */
  async getPaymentInfo(t, e, r, i = 5) {
    const n = (this._xamanWrapped ? await this.getXamanCall(t).paymentInfo(e) : await t.paymentInfo(e)).partialFee.toString();
    return r === 2 ? BigInt(n) : await this.getAmountsIn(n, r, i);
  }
  /**
   * Sets the gas info
   *
   * @param gasString - the gas string to set
   * @param gasFee - the gas fee to set
   * @param tokenDecimals - the token decimals
   *
   */
  async setGasInfo(t) {
    const e = await this.api.query.assets.metadata(this._gasToken), r = this.getGas(
      this._gasFee.toString(),
      parseInt(e.decimals.toString()),
      S(e.symbol.toHex())
    );
    this._gasString = r, this._gasFee = t, this._tokenDecimals = parseInt(e.decimals.toString());
  }
  /**
   * Helper function to create a fake Xaman call when needing to estimate gas fees - used internally by Root and Child Classes when using Xaman Signer
   *
   * @param extrinsic
   * @returns
   */
  getXamanCall(t) {
    return this.api.tx.xrpl.transact(
      "0x5916969036626990000000000000000000F236FD752B5E4C84810AB3D41A3C25807321EDFB2A3A850B43E24D2700532EF1F9CCB2475DFF4F62B634B0C58845F23C26396581145116224CEF7355137BEBBA8E277A9BE18E0596E7F9EA7C0965787472696E7369637D8E383339353966376634323632373632663735393963326661343862343138623765313032663932633831666162396536656632326162333739616264623732663A333A31323639343937353A303A33623034653934373565373336353763616665393561653138656335363963336436383738353539643661633939333437316364623562646635396339636432E1F1",
      "0x3BC417D12C9595ABB4551CE518ACDD70AE3B9D9B55CF5110BD5009B4A098AE62CC8C66CD422A0DF67A2B08894C15E423CE6F1EFFCAC540964F84A57E31399102",
      t
    );
  }
  /**
   * Sets the Gas Fee
   *
   * @param gasFee - the gas fee to set
   */
  setGasFee(t) {
    this._gasFee = t;
  }
  /**
   * Unscale a value by the decimals - used internally by Root and Child Classes
   *
   * @param value - the value to unscale
   * @param decimals - the decimals to unscale by
   * @returns the unscaled value
   */
  unscaleBy(t, e) {
    return A(t, {
      decimals: e,
      forceUnit: "-",
      withSi: !1
    }).split(",");
  }
  /**
   * Gets the gas fee string - used internally by Root and Child Classes
   *
   * @param estimatedFee - the estimated fee to get the gas fee string for
   * @param tokenDecimals - the token decimals to use
   * @param gasToken - the gas token to use
   * @returns the gas fee string
   */
  getGas(t, e = G, r = W) {
    return `${this.unscaleBy(t ?? "0", e).toString()} ${r}`;
  }
  /**
   * Sends the extrinsic - used internally by Root and Child Classes to send the extrinsic
   *
   * @param api - the API to use
   * @param signedExtrinsic - the signed extrinsic to send
   * @returns the ExtrinsicResult instance
   */
  async sendExtrinsic({
    api: t,
    signedExtrinsic: e
  }) {
    return new Promise((r, i) => {
      (async () => {
        const n = await e.send((a) => {
          const { status: o, dispatchError: h, txHash: l, txIndex: c, blockNumber: u } = a;
          if (!o.isFinalized) return;
          if (h != null) {
            if (!h.isModule)
              return n(), i(
                new Error(
                  `Extrinsic failed, ${JSON.stringify(h.toJSON())}`
                )
              );
            const { section: m, name: y, docs: p } = h.registry.findMetaError(h.asModule);
            return n(), i(
              new Error(
                `Extrinsic sending failed, [${m}.${y}]: ${p.join(
                  ", "
                )}`
              )
            );
          }
          const E = this.filterExtrinsicEvents({
            events: a.events,
            names: ["Proxy.ProxyExecuted", "xrpl.XRPLExtrinsicExecuted"]
          });
          for (const m of E) {
            const [y] = m.event.data.toJSON(), p = y;
            if ("err" in p) {
              const { section: _, name: b, docs: B } = t.registry.findMetaError({
                index: new v(p.err.module.index),
                error: C(p.err.module.error)
              });
              return n(), i(
                `Extrinsic sending failed, [${_}.${b}]: ${B.join(
                  ", "
                )}`
              );
            }
          }
          if (u == null || c == null) return;
          n();
          const g = `${u.toString()}-${c.toString()}`;
          r({ result: a, extrinsicId: g, transactionHash: l.toString() });
        });
      })().catch(i);
    });
  }
  /**
   * Gets the balance of an asset
   * Wallet address is optional, if not provided, the wallet address of the instance will be used
   *
   * @param walletAddress - (optional) the wallet address to get the balance for
   * @param assetId - the asset ID to get the balance for
   * @returns the balance of the asset
   *
   */
  async checkBalance({
    walletAddress: t,
    assetId: e
  }) {
    return await this.queryBuilder.checkBalance({
      walletAddress: t,
      assetId: e
    });
  }
  /**
   * Checks the balances of multiple assets for given wallet addresses
   * Wallet address is optional, if not provided, the wallet address of the instance will be used
   *
   * @param walletAddressAssetIds - the [walletAddresses, assetId] pair to check balances for
   * @returns the balances of the assets
   * @throws an error if the API is not connected or if the wallet address and asset IDs are not provided
   */
  async checkBalances(t) {
    return await this.queryBuilder.checkBalances(t);
  }
  /**
   * Gets the FuturePass for the wallet address
   * Wallet address is optional, if not provided, the wallet address of the instance will be used
   *
   * @param walletAddress - (optional) the wallet address to get the FuturePass for
   * @returns the FuturePass for the wallet address
   * @throws an error if the API is not connected or if the wallet address is not provided
   */
  async getFuturePass(t) {
    const e = t ?? this.walletAddress;
    if (!e || !e.length || e === "")
      throw new Error("Address is required");
    return await this.queryBuilder.getFuturePass(e);
  }
  /**
   * Gets the amounts in for a given asset ID
   *
   * @param amount - the amount to get the amounts in for
   * @param assetId - the asset ID to get the amounts in for
   * @param slippage - the slippage to use for the amounts in
   * @returns the amounts in for the asset
   */
  async getAmountsIn(t, e, r = 5) {
    return await this.queryBuilder.getAmountsIn(t, e, r);
  }
}
class M extends f {
  constructor(t, e, r) {
    super(t, e, r), this.extrinsics = [];
  }
  /**
   * Use by child classes
   *
   * @returns always true
   */
  async exists() {
    return !0;
  }
  /**
   * Resets the BatchBuilder instance
   *
   * @returns the BatchBuilder instance
   */
  reset() {
    return super.resetBase(), this.extrinsics = [], this;
  }
  /**
   * Builds a batch with the provided extrinsics and sets the base extrinsic to the batch
   *
   * @param extrinsics - the extrinsics to include in the single transaction
   * @returns the BatchBuilder instance
   * @note This will batch all extrinsics into a single transaction, this is will finalise and succeed regardless of any extrinsic in the batch failing
   */
  batchWithExtrinsics(t) {
    if (!this.api)
      throw new Error("API is not connected");
    if (!t || t.length === 0)
      throw new Error("Extrinsics are required");
    this.checkBatchLimit(t.length, 0), this.setExtrinsics(t);
    const e = this.api.tx.utility.batch(t);
    return super.setBaseExtrinsic(e), this;
  }
  /**
   * Batch all extrinsics set into a single transaction and sets the base extrinsic to the batch
   *
   * @returns the BatchBuilder instance
   * @note This will batch all extrinsics into a single transaction, if any extrinsic fails, the entire transaction will fail
   */
  batch() {
    if (!this.api)
      throw new Error("API is not connected");
    if (!this.extrinsics || this.extrinsics.length === 0)
      throw new Error("Extrinsics are required");
    this.checkBatchLimit(0);
    const t = this.api.tx.utility.batch(this.extrinsics);
    return super.setBaseExtrinsic(t), this;
  }
  /**
   * Builds a batch with the provided extrinsics and sets the base extrinsic to the batchAll extrinsic
   *
   * @param extrinsics - the extrinsics to include in the single transaction
   * @returns the BatchBuilder instance
   * @note This will batch all extrinsics into a single transaction, if any extrinsic fails, the entire transaction will fail
   */
  batchAllWithExtrinsics(t) {
    if (!this.api)
      throw new Error("API is not connected");
    if (!t || t.length === 0)
      throw new Error("Extrinsics are required");
    this.checkBatchLimit(t.length, 0), this.setExtrinsics(t);
    const e = this.api.tx.utility.batchAll(t);
    return super.setBaseExtrinsic(e), this;
  }
  /**
   * Batch all extrinsics set into a single transaction and sets the base extrinsic to the batchAll extrinsic
   *
   * @returns the BatchBuilder instance
   * @note This will batch all extrinsics into a single transaction, if any extrinsic fails, the entire transaction will fail
   */
  batchAll() {
    if (!this.api)
      throw new Error("API is not connected");
    if (!this.extrinsics || this.extrinsics.length === 0)
      throw new Error("Extrinsics are required");
    this.checkBatchLimit(0);
    const t = this.api.tx.utility.batchAll(this.extrinsics);
    return super.setBaseExtrinsic(t), this;
  }
  /**
   * Adds an extrinsic to be used in a batch or batchAll call
   *
   * @param extrinsic - the extrinsic to add to the batch
   * @returns the BatchBuilder instance
   */
  addExtrinsic(t) {
    if (!this.api)
      throw new Error("API is not connected");
    if (!t)
      throw new Error("Extrinsic is required");
    return this.checkBatchLimit(1), this.extrinsics.push(t), this;
  }
  /**
   * Adds multiple extrinsics to be used in a batch or batchAll call
   *
   * @param extrinsics - the extrinsics to add to the batch
   * @returns the BatchBuilder instance
   */
  addExtrinsics(t) {
    if (!this.api)
      throw new Error("API is not connected");
    if (!t || t.length === 0)
      throw new Error("Extrinsic is required");
    return this.checkBatchLimit(t.length), this.extrinsics.push(...t), this;
  }
  /**
   * Checks if the batch limit has been reached - throws an error if the limit has been reached
   *
   * @param qtyToAdd - the number of extrinsics to add to the batch
   * @param batchOverride - the number of extrinsics to add to the batch, if different from the current batch size
   * @throws an error if the batch limit has been reached
   */
  checkBatchLimit(t, e = -1) {
    const r = this.api.consts.utility.batchedCallsLimit.toBigInt();
    if ((e !== -1 ? e : this.extrinsics.length) + t > r)
      throw new Error("Batch limit reached, cannot add more extrinsics");
  }
  /**
   * Sets the extrinsics for the batch
   *
   * @param extrinsics - the extrinsics to include in the single transaction
   */
  setExtrinsics(t) {
    this.extrinsics = t;
  }
  /**
   * Gets the extrinsics for the batch
   *
   * @returns the extrinsics for the batch
   */
  getExtrinsics() {
    return this.extrinsics;
  }
}
class k extends f {
  constructor(t, e, r) {
    super(t, e, r);
  }
  /**
   * Checks if a custom extrinsic exists
   * @returns true if the custom extrinsic exists, false otherwise
   * @note This always returns true
   */
  async exists() {
    return !0;
  }
  /**
   * Resets the CustomExtrinsicBuilder instance
   *
   * @returns the CustomExtrinsicBuilder instance
   */
  reset() {
    return super.resetBase(), this;
  }
  /**
   * @deprecated Use `fromExtrinsic` instead
   */
  extrinsic(t) {
    return this.fromExtrinsic(t);
  }
  /**
   * Sets the base extrinsic to the Custom Builder
   *
   * @param extrinsic - the extrinsic to include in the transaction
   * @returns the CustomExtrinsicBuilder instance
   */
  fromExtrinsic(t) {
    if (!this.api)
      throw new Error("API is not connected");
    if (!t)
      throw new Error("An extrinsic is required");
    return super.setBaseExtrinsic(t), this;
  }
}
class L extends f {
  constructor(t, e, r, i) {
    super(t, e, r), this._saleId = i;
  }
  /**
   * Checks if a sale exists
   *
   * @returns true if the sale exists, false otherwise
   */
  async exists() {
    return (await this.api.query.crowdsale.saleInfo(this._saleId)).isSome;
  }
  /**
   * Resets the CrowdsaleBuilder instance
   *
   * @param saleId - the sale ID to reset the instance with
   * @returns the CrowdsaleBuilder instance
   */
  reset(t) {
    return super.resetBase(), this._saleId = t, this;
  }
  /**
   * Checks if a crowdsale exists
   *
   * @param api - the API to use for queries
   * @param saleId - the sale ID to check for
   * @returns true if the crowdsale exists, false otherwise
   */
  static async crowdsaleExists(t, e) {
    return (await t.query.crowdsale.saleInfo(e)).isSome;
  }
  /**
   * Participates in the sale with the amount
   *
   * @param amount - the amount to participate with
   * @returns the CrowdsaleBuilder instance
   */
  participate(t) {
    if (!this.api)
      throw new Error("API is not connected");
    if (!this._saleId)
      throw new Error("Sale ID is required");
    if (!t)
      throw new Error("Amount is required");
    const e = this.api.tx.crowdsale.participate(this._saleId, t);
    return super.setBaseExtrinsic(e), this;
  }
  /**
   * Redeems the voucher for the sale with the quantity
   *
   * @param quantity - the quantity to redeem
   * @returns the CrowdsaleBuilder instance
   */
  redeem(t) {
    if (!this.api)
      throw new Error("API is not connected");
    if (!this._saleId)
      throw new Error("Sale ID is required");
    if (!t)
      throw new Error("Quantity is required");
    const e = this.api.tx.crowdsale.redeemVoucher(
      this._saleId,
      t
    );
    return super.setBaseExtrinsic(e), this;
  }
  /**
   * Claims the voucher for the sale
   *
   * @returns the CrowdsaleBuilder instance
   */
  claim() {
    if (!this.api)
      throw new Error("API is not connected");
    if (!this._saleId)
      throw new Error("Sale ID is required");
    const t = this.api.tx.crowdsale.claimVoucher(this._saleId);
    return super.setBaseExtrinsic(t), this;
  }
}
class R extends f {
  constructor(t, e, r, i) {
    super(t, e, r), this._assetId = i;
  }
  /**
   * Used by child classes to check if the asset ID exists
   *
   * @returns a boolean
   */
  async exists() {
    return this._assetId === 1 || this._assetId === 2 ? !0 : (await this.api.query.assets.asset(this._assetId)).isSome;
  }
  /**
   * Resets the AssetBuilder instance
   *
   * @param assetId - the asset ID to reset the instance with
   * @returns the AssetBuilder instance
   */
  reset(t) {
    return super.resetBase(), this._assetId = t, this;
  }
  /**
   * Checks if an asset exists
   *
   * @param api - the API to use for queries
   * @param assetId - the asset ID to check for
   * @returns true if the asset exists, false otherwise
   */
  static async assetExists(t, e) {
    return (await t.query.assets.asset(e)).isSome;
  }
  /**
   * Transfer an asset to a destination address
   *
   * @param destinationAddress - the destination address wallet address to transfer to
   * @param amount - the amount to transfer. Can be a number, bigint or string but must be a valid number including decimals. For example, if you are transferring `1.3` Tokens with a
   * precision of 6 decimals, you should pass in `1300000` as the amount.
   * @returns the AssetBuilder instance
   */
  transfer({
    destinationAddress: t,
    amount: e
  }) {
    if (!this.api)
      throw new Error("API is not connected");
    if (!this._assetId)
      throw new Error("Asset ID is required");
    if (!t)
      throw new Error("destinationAddress is required");
    if (!e)
      throw new Error("Amount is required");
    if (!t.startsWith("0x") || !d(t))
      throw new Error("destinationAddress is not a valid address");
    if (t === "0x0000000000000000000000000000000000000000")
      throw new Error("destinationAddress cannot be the zero address");
    const r = this.api.tx.assetsExt.transfer(
      this._assetId,
      t,
      e,
      !0
    );
    return super.setBaseExtrinsic(r), this;
  }
}
class U extends f {
  constructor(t, e, r, i) {
    super(t, e, r), i !== void 0 && (this._collectionId = i);
  }
  /**
   * Checks if an NFT Collection exists
   *
   * @param api - the API to use for queries
   * @param collectionId - the collection ID to check for
   * @returns  true if the collection exists, false otherwise
   */
  static async nftExists(t, e) {
    return (await t.query.nft.collectionInfo(e)).isSome;
  }
  /**
   * Checks if an NFT exists
   *
   * @returns true if the NFT exists, false otherwise
   */
  async exists() {
    if (!this.api)
      throw new Error("API is not connected");
    return this._collectionId ? (await this.api.query.nft.collectionInfo(
      this._collectionId
    )).isSome : !0;
  }
  /**
   * Resets the NftBuilder instance
   *
   * @param collectionId - optional - the collection ID to reset the instance with
   * @returns the NftBuilder instance
   */
  reset(t) {
    return super.resetBase(), t && (this._collectionId = t), this;
  }
  /**
   * Mints NFTs with the given quantity to the given wallet address
   *
   * @param quantity - the number of NFTs to mint
   * @param walletAddress - the wallet address to mint the NFTs to
   * @returns the NftBuilder instance
   */
  mint({
    quantity: t,
    walletAddress: e
  }) {
    if (!this.api)
      throw new Error("API is not connected");
    if (!this._collectionId)
      throw new Error("Collection ID is required");
    if (!e || e === "" || !d(e))
      throw new Error("WalletAddress is required or is not a valid address");
    if (e === "0x0000000000000000000000000000000000000000")
      throw new Error("walletAddress cannot be the zero address");
    if (typeof t != "number" || t < 1 || parseInt(t.toString()) < 1)
      throw new Error(
        "Quantity is required and must be a number greater than 0"
      );
    if (typeof t != "number" || t > 1e3 || parseInt(t.toString()) > 1e3)
      throw new Error(
        "Quantity is required and must be a number less than 1000"
      );
    const r = this.api.tx.nft.mint(
      this._collectionId,
      t,
      e
    );
    return super.setBaseExtrinsic(r), this;
  }
  /**
   * Transfers NFTs with the given serial numbers
   *
   * @param serialNumbers - the serial numbers of the NFTs to transfer
   * @param walletAddress - the walletAddress to transfer the NFTs to
   * @returns the NftBuilder instance
   */
  transfer({
    serialNumbers: t,
    walletAddress: e
  }) {
    if (!this.api)
      throw new Error("API is not connected");
    if (!e || e === "" || !d(e))
      throw new Error("WalletAddress is required or is not a valid address");
    if (e === "0x0000000000000000000000000000000000000000")
      throw new Error("walletAddress cannot be the zero address");
    if (!t || !Array.isArray(t) || t.length < 1)
      throw new Error(
        "Serial numbers are required and must be an array with at least one element"
      );
    if (!t.every((i) => typeof i == "number"))
      throw new Error(
        "All elements in the serial numbers array must be numbers"
      );
    if (!this._collectionId)
      throw new Error("Collection ID is required");
    const r = this.api.tx.nft.transfer(
      this._collectionId,
      t,
      e
    );
    return super.setBaseExtrinsic(r), this;
  }
  /**
   * Burns an NFT with the given serial number
   *
   * @param serialNumber - the serial number of the NFT to burn
   * @returns the NftBuilder instance
   */
  burn({ serialNumber: t }) {
    if (!this.api)
      throw new Error("API is not connected");
    if (typeof t != "number" || t < 0)
      throw new Error(
        "Serial number is required and must be a number greater than or equal to 0"
      );
    if (!this._collectionId)
      throw new Error("Collection ID is required");
    const e = this.api.tx.nft.burn([
      this._collectionId,
      t
    ]);
    return super.setBaseExtrinsic(e), this;
  }
  /**
   * Set the collection ID
   *
   * @param collectionId - the collection ID to set
   * @returns the NftBuilder instance
   */
  setCollectionId(t) {
    return this._collectionId = t, this;
  }
  /**
   * Create a new NFT Collection
   *
   * @param name - the name of the collection
   * @param initialIssuance - (optional) - the initial issuance of the collection
   * @param maxIssuance - the maximum issuance of the collection
   * @param tokenOwner - the owner of the tokens initially minted
   * @param metadataUri - the metadata URI of the collection
   * @param royalties - the royalties of the collection
   * @param crossChain - the cross chain compatibility of the collection
   * @returns the NftBuilder instance
   */
  createCollection({
    name: t,
    initialIssuance: e = null,
    maxIssuance: r = null,
    tokenOwner: i = null,
    metadataUri: s,
    royalties: n = null,
    crossChain: a = null
  }) {
    if (!this.api)
      throw new Error("API is not connected");
    if (!t)
      throw new Error("Collection Name is required");
    if (!s)
      throw new Error("Metadata URI is required");
    if (i && !d(i))
      throw new Error("tokenOwner is not a valid address");
    if (i === "0x0000000000000000000000000000000000000000")
      throw new Error("tokenOwner cannot be the zero address");
    if (e !== null && (parseInt(e.toString()) < 0 || parseInt(e.toString()) > 1e3))
      throw new Error(
        "Initial issuance must be a number greater than 0 and less than 1000"
      );
    if (r !== null && BigInt(r.toString()) <= 0)
      throw new Error("Max issuance must be a number greater than 0");
    if (n && !n.every(
      (c) => Array.isArray(c) && c.length === 2 && d(c[0].toString()) && c[0].toString() !== "" && c[0].toString() !== "0x0000000000000000000000000000000000000000" && c[0].toString().length === 42 && (typeof c[1] == "number" || typeof c[1] == "bigint")
    ))
      throw new Error("Royalties are not in the correct format");
    const o = n ? { entitlements: n } : null, h = { xrpl: a }, l = this.api.tx.nft.createCollection(
      t,
      e ?? 0,
      r ?? null,
      i === "" ? null : i ?? null,
      s,
      o ?? null,
      h ?? null
    );
    return super.setBaseExtrinsic(l), this;
  }
  /**
   * Update the metadata URI of the collection
   *
   * @param uri - the metadata URI to update to
   * @returns the NftBuilder instance
   */
  updateMetadataUri(t) {
    if (!this.api)
      throw new Error("API is not connected");
    if (!t)
      throw new Error("Metadata URI is required");
    if (!this._collectionId)
      throw new Error("Collection ID is required");
    const e = this.api.tx.nft.setBaseUri(
      this._collectionId,
      t
    );
    return super.setBaseExtrinsic(e), this;
  }
  /**
   * Update the royalties of the collection
   *
   * @param royalties - the royalties to update to
   * @returns the NftBuilder instance
   */
  updateRoyalties({
    royalties: t
  }) {
    if (!this.api)
      throw new Error("API is not connected");
    if (!this._collectionId)
      throw new Error("Collection ID is required");
    if (!t)
      throw new Error("Royalties are required");
    if (!Array.isArray(t))
      throw new Error("Royalties must be an array");
    if (!t.every(
      (r) => Array.isArray(r) && r.length === 2 && d(r[0].toString()) && r[0].toString() !== "" && r[0].toString() !== "0x0000000000000000000000000000000000000000" && r[0].toString().length === 42 && (typeof r[1] == "number" || typeof r[1] == "bigint")
    ))
      throw new Error("Royalties are not in the correct format");
    const e = this.api.tx.nft.setRoyaltiesSchedule(
      this._collectionId,
      { entitlements: t }
    );
    return super.setBaseExtrinsic(e), this;
  }
  /**
   * Update the max issuance of the collection
   *
   * @param maxIssuance - the max issuance to update to
   * @returns the NftBuilder instance
   */
  updateMaxIssuance(t) {
    if (!this.api)
      throw new Error("API is not connected");
    if (!this._collectionId)
      throw new Error("Collection ID is required");
    if (!t)
      throw new Error("Max Issuance is required");
    if (BigInt(t.toString()) <= 0)
      throw new Error("Max issuance must be a number greater than 0");
    const e = this.api.tx.nft.setMaxIssuance(
      this._collectionId,
      t
    );
    return super.setBaseExtrinsic(e), this;
  }
  /**
   * Transfer ownership of the collection
   *
   * @param newOwner - the new owner to update to
   * @returns the NftBuilder instance
   */
  transferCollection(t) {
    if (!this.api)
      throw new Error("API is not connected");
    if (!this._collectionId)
      throw new Error("Collection ID is required");
    if (!t || t === "" || !d(t))
      throw new Error("Token Owner is required or is not a valid address");
    if (t.length !== 42 || t === "0x0000000000000000000000000000000000000000")
      throw new Error("newOwner cannot be the zero address");
    const e = this.api.tx.nft.setOwner(
      this._collectionId,
      t
    );
    return super.setBaseExtrinsic(e), this;
  }
  /**
   * Update the mint fee of the collection
   *
   * @param assetId - the token to update the mint fee for
   * @param price - the price to update to - can be a number, bigint or string but must be a valid number including decimals.
   * For example, if you are setting the mint fee to `1.3` Tokens with a precision of 6 decimals, you should pass in `1300000` as the price.
   * @returns the NftBuilder instance
   */
  async setPrice({
    assetId: t,
    price: e
  } = {}) {
    if (!this.api)
      throw new Error("API is not connected");
    if (!this._collectionId)
      throw new Error("Collection ID is required");
    if ((t === void 0 || t === 0) && (e === void 0 || e === 0)) {
      if (t !== void 0 && t > 0 && (e === void 0 || Number(e) <= 0))
        throw new Error(
          "Price is required and must be greater than 0 when assetId is provided and greater than 0"
        );
      if (e !== void 0 && Number(e) > 0 && (t === void 0 || t <= 0))
        throw new Error(
          "AssetId is required and must be greater than 0 when price is provided and greater than 0"
        );
      if (e !== void 0 && e !== 0 && (typeof e != "number" && typeof e != "bigint" && typeof e != "string" || typeof e == "string" && parseInt(e) <= 0 || typeof e != "string" && e <= 0))
        throw new Error("Price must be a number greater than 0");
      if (t !== void 0 && t !== 0 && (typeof t != "number" && typeof t != "bigint" && typeof t != "string" || typeof t == "string" && parseInt(t) <= 0 || typeof t != "string" && t <= 0))
        throw new Error("AssetId must be a number greater than 0");
    }
    const r = this.api.tx.nft.setMintFee(
      this._collectionId,
      t && e ? [t, e] : null
    );
    return super.setBaseExtrinsic(r), this;
  }
  /**
   * Toggle public minting on or off
   *
   * @param publicMintEnabled - value to set public minting to
   * @returns the NftBuilder instance
   */
  togglePublicMint(t) {
    if (!this.api)
      throw new Error("API is not connected");
    if (!this._collectionId)
      throw new Error("Collection ID is required");
    const e = this.api.tx.nft.togglePublicMint(
      this._collectionId,
      t
    );
    return super.setBaseExtrinsic(e), this;
  }
}
class $ extends f {
  constructor(t, e, r) {
    super(t, e, r);
  }
  /**
   * Checks if a remark exists - always returns true
   *
   * @returns always true
   */
  async exists() {
    return !0;
  }
  /**
   * Resets the RemarkBuilder instance
   *
   * @returns the RemarkBuilder
   */
  reset() {
    return super.resetBase(), this;
  }
  /**
   * Sends a message in a remark extrinsic
   *
   * @param message - the message to include in the remark
   * @returns the RemarkBuilder instance
   */
  message(t) {
    if (!this.api)
      throw new Error("API is not connected");
    if (!t || t === "")
      throw new Error("A message is required");
    const e = this.api.tx.system.remark(t);
    return super.setBaseExtrinsic(e), this;
  }
}
class z extends f {
  constructor(t, e, r, i) {
    if (super(t, e, r), i !== void 0) {
      if (typeof i != "number" || i <= 0)
        throw new Error("Collection ID must be a positive number");
      this._collectionId = i;
    }
  }
  /**
   * Checks if an SFT exists
   *
   * @param api - the API to use for queries
   * @param collectionId - the collection ID to check for
   * @returns true if the SFT exists, false otherwise
   */
  static async sftExists(t, e) {
    return (await t.query.sft.sftCollectionInfo(e)).isSome;
  }
  /**
   * Checks if an SFT exists
   *
   * @returns true if the SFT exists, false otherwise
   */
  async exists() {
    return this._collectionId ? !!await this.api.query.sft.sftCollectionInfo(
      this._collectionId
    ) : !0;
  }
  /**
   * Resets the SftBuilder instance
   *
   * @param collectionId - optional - the collection ID to reset the instance with
   * @returns the SftBuilder instance
   */
  reset(t) {
    if (super.resetBase(), t) {
      if (typeof t != "number" || t <= 0)
        throw new Error("Collection ID must be a positive number");
      this._collectionId = t;
    }
    return this;
  }
  /**
   * Mints SFTs with the given serial numbers and quantities
   *
   * @param serialNumbers - the serial numbers of the SFTs to mint... Each element in the array should be an object with a tokenId and quantity property
   * @param walletAddress - the wallet address to mint the SFTs to
   * @returns the SftBuilder instance
   */
  mint({
    serialNumbers: t,
    walletAddress: e
  }) {
    if (!this.api)
      throw new Error("API is not connected");
    if (e === null || e === "" || e.length !== 42 || e === "0x0000000000000000000000000000000000000000")
      throw new Error(
        "walletAddress must be a valid address and not a zero address"
      );
    if (!e || !d(e))
      throw new Error("WalletAddress is required or is not a valid address");
    if (t.length < 1)
      throw new Error("Serial numbers are required");
    if (this._collectionId === void 0)
      throw new Error("Collection ID is required");
    if (!t.every(
      ({ tokenId: i, quantity: s }) => typeof i == "number" && (typeof s == "number" || typeof s == "bigint" || typeof s == "string")
    ))
      throw new Error(
        "All elements in the serial numbers array must be objects with a tokenId and quantity property"
      );
    const r = this.api.tx.sft.mint(
      this._collectionId,
      t.map(
        ({
          tokenId: i,
          quantity: s
        }) => [i, s]
      ),
      e
    );
    return super.setBaseExtrinsic(r), this;
  }
  /**
   * Transfers SFTs with the given serial numbers and quantities to the given wallet address
   *
   * @param serialNumbers - the serial numbers of the SFTs to transfer... Each element in the array should be an object with a tokenId and quantity property
   * @param walletAddress - the walletAddress to transfer the SFTs to
   * @returns the SftBuilder instance
   */
  transfer({
    serialNumbers: t,
    walletAddress: e
  }) {
    if (!this.api)
      throw new Error("API is not connected");
    if (!e || !d(e))
      throw new Error("WalletAddress is required or is not a valid address");
    if (!Array.isArray(t) || t.length < 1)
      throw new Error("Serial numbers are required");
    if (!t.every(
      ({ tokenId: i, quantity: s }) => typeof i == "number" && (typeof s == "number" || typeof s == "bigint" || typeof s == "string")
    ))
      throw new Error(
        "All elements in the serial numbers array must be objects with a tokenId and quantity property"
      );
    if (this._collectionId === void 0)
      throw new Error("Collection ID is required");
    const r = this.api.tx.sft.transfer(
      this._collectionId,
      t.map(
        ({
          tokenId: i,
          quantity: s
        }) => [i, s]
      ),
      e
    );
    return super.setBaseExtrinsic(r), this;
  }
  /**
   * Burns SFTs with the given serial numbers and quantities
   *
   * @param {ISerialNumbers} serialNumbers - the serial numbers of SFTs to burn
   * @returns the SftBuilder instance
   */
  burn({
    serialNumbers: t
  }) {
    if (!this.api)
      throw new Error("API is not connected");
    if (!Array.isArray(t) || t.length < 1)
      throw new Error("Serial numbers are required");
    if (this._collectionId === void 0)
      throw new Error("Collection ID is required");
    if (!t.every(
      ({ tokenId: r, quantity: i }) => typeof r == "number" && (typeof i == "number" || typeof i == "bigint" || typeof i == "string")
    ))
      throw new Error(
        "All elements in the serial numbers array must be objects with a tokenId and quantity property"
      );
    const e = this.api.tx.sft.burn(
      this._collectionId,
      t.map(
        ({
          tokenId: r,
          quantity: i
        }) => [r, i]
      )
    );
    return super.setBaseExtrinsic(e), this;
  }
  /**
   * Create a new SFT Collection
   *
   * @param collectionName - the name of the collection
   * @param collectionOwner - the owner of the collection
   * @param metadataUri - the metadata URI of the collection
   * @param royalties - the royalties of the collection
   * @returns the SftBuilder instance
   */
  createCollection({
    collectionName: t,
    collectionOwner: e = null,
    metadataUri: r,
    royalties: i = null
  }) {
    if (!this.api)
      throw new Error("API is not connected");
    if (!t)
      throw new Error("Collection collectionName is required");
    if (!r)
      throw new Error("Metadata URI is required");
    if (e === "" || e === "0x0000000000000000000000000000000000000000")
      throw new Error("collectionOwner cannot be the zero address");
    if (e && !d(e))
      throw new Error("Collection owner is not a valid address");
    if (i && !i.every(
      (a) => Array.isArray(a) && a.length === 2 && d(a[0].toString()) && a[0].toString() !== "" && a[0].toString() !== "0x0000000000000000000000000000000000000000" && a[0].toString().length === 42 && (typeof a[1] == "number" || typeof a[1] == "bigint")
    ))
      throw new Error("Royalties are not in the correct format");
    const s = i ? { entitlements: i } : null, n = this.api.tx.sft.createCollection(
      t,
      e === "" ? null : e,
      r,
      s ?? null
    );
    return super.setBaseExtrinsic(n), this;
  }
  /**
   * Create a new SFT Token for Collection
   *
   * @param collectionName - the name of the collection
   * @param initialIssuance - (optional) - the initial issuance of the collection
   * @param maxIssuance - the maximum issuance of the collection
   * @param tokenOwner - the owner of the tokens initially minted
   * @returns the SftBuilder instance
   */
  createToken({
    tokenName: t,
    initialIssuance: e = null,
    maxIssuance: r = null,
    tokenOwner: i = null
  }) {
    if (!this.api)
      throw new Error("API is not connected");
    if (!this._collectionId)
      throw new Error("Collection ID is required");
    if (!t)
      throw new Error("Collection tokenName is required");
    if (i && !d(i))
      throw new Error("Token owner is not a valid address");
    if (i === "" || i === "0x0000000000000000000000000000000000000000")
      throw new Error("tokenOwner cannot be the zero address");
    if (e !== null && (Number(e) < 0 || Number(e) > 1e3))
      throw new Error("Initial issuance must be between 0 and 1000");
    if (r !== null && BigInt(r.toString()) <= 0)
      throw new Error(
        "Max issuance must be a number greater than or equal to 0"
      );
    const s = this.api.tx.sft.createToken(
      this._collectionId,
      t,
      e ?? 0,
      r,
      i
    );
    return super.setBaseExtrinsic(s), this;
  }
  /**
   * Sets the price for minting SFTs in a collection
   *
   * @param tokenId - the token ID to set the price for
   * @param assetId - the asset ID to set the price for
   * @param price -  the price to update to - can be a number, bigint or string but must be a valid number including decimals.
   * For example, if you are setting the mint fee to `1.3` Tokens with a precision of 6 decimals, you should pass in `1300000` as the price.
   * @returns the SftBuilder instance
   */
  async setPrice({
    tokenId: t,
    assetId: e,
    price: r
  }) {
    if (!this.api)
      throw new Error("API is not connected");
    if (!this._collectionId)
      throw new Error("Collection ID is required");
    if (typeof t > "u" || t === null)
      throw new Error("Token ID is required");
    if (typeof t != "number" && typeof t != "bigint")
      throw new Error("Token ID must be a number or bigint");
    if ((e === void 0 || e === 0) && (r === void 0 || r === 0)) {
      if (e !== void 0 && e > 0 && (r === void 0 || Number(r) <= 0))
        throw new Error(
          "Price is required and must be greater than 0 when assetId is provided and greater than 0"
        );
      if (r !== void 0 && Number(r) > 0 && (e === void 0 || e <= 0))
        throw new Error(
          "AssetId is required and must be greater than 0 when price is provided and greater than 0"
        );
      if (r !== void 0 && r !== 0 && (typeof r != "number" && typeof r != "bigint" && typeof r != "string" || typeof r == "string" && parseInt(r) <= 0 || typeof r != "string" && r <= 0))
        throw new Error("Price must be a number greater than 0");
      if (e !== void 0 && e !== 0 && (typeof e != "number" && typeof e != "bigint" && typeof e != "string" || typeof e == "string" && parseInt(e) <= 0 || typeof e != "string" && e <= 0))
        throw new Error("AssetId must be a number greater than 0");
    }
    const i = this.api.tx.sft.setMintFee(
      [this._collectionId, t],
      e && r ? [e, r] : null
    );
    return super.setBaseExtrinsic(i), this;
  }
  /**
   * Toggle public minting on or off
   *
   * @param publicMintEnabled - value to set public minting to
   * @returns the SftBuilder instance
   */
  togglePublicMint(t, e) {
    if (!this.api)
      throw new Error("API is not connected");
    if (!this._collectionId)
      throw new Error("Collection ID is required");
    if (typeof t > "u" || t === null)
      throw new Error("Token ID is required");
    if (typeof t != "number" && typeof t != "bigint")
      throw new Error("Token ID must be a number or bigint");
    if (typeof e != "boolean")
      throw new Error("Public minting enabled must be a boolean");
    const r = this.api.tx.sft.togglePublicMint(
      [this._collectionId, t],
      e
    );
    return super.setBaseExtrinsic(r), this;
  }
}
class H extends f {
  constructor(t, e, r, i) {
    if (super(t, e, r), this._contractAddress = null, this._evmGasInfo = null, this._evmCall = null, this.futurePassEvmCall = null, this.isEvmFuturePass = !1, this.transactionData = null, this.addressToUse = null, this.gasLimit = BigInt(0), this.evmGasPrice = BigInt(0), this.nonce = null, i && !d(i))
      throw new Error("Invalid contract address");
    i && (this._contractAddress = i);
  }
  async exists() {
    return !0;
  }
  /**
   * Resets the EvmBuilder instance
   *
   * @param contractAddress - (optional) the contract address to reset the EvmBuilder with (if provided)
   * @returns the EvmBuilder instance
   */
  reset(t) {
    if (super.resetBase(), t && !d(t))
      throw new Error("Invalid contract address");
    return this._contractAddress = t || null, this._evmGasInfo = null, this._evmCall = null, this.futurePassEvmCall = null, this.isEvmFuturePass = !1, this.transactionData = null, this.addressToUse = null, this.gasLimit = BigInt(0), this.evmGasPrice = BigInt(0), this.nonce = null, this;
  }
  /**
   * Call to interact with the EVM with data already encoded.
   * Initially designed for internal use only as a way to override an evm call made through Wagmi with the Xaman Connector.
   *
   * @param to - the address sending the transaction to
   * @param data - the data to send with the transaction
   * @param value - the value to send with the transaction
   * @param maxPriorityFeePerGas - the max priority fee per gas to use
   * @param nonce - the nonce to use for the transaction
   * @param fromFuturePass - whether to use the FuturePass for the transaction
   * @returns the EvmBuilder instance
   */
  async evmOverride({
    to: t,
    data: e = "",
    value: r = BigInt(0),
    maxPriorityFeePerGas: i = null,
    nonce: s = null,
    fromFuturePass: n = !1
  }) {
    if (!this.api)
      throw new Error("API is not connected");
    return await this.prepareTransaction({
      to: t,
      data: e,
      value: r.toString(),
      maxPriorityFeePerGas: i ?? null,
      nonce: s,
      fromFuturePass: n
    }), this;
  }
  /**
   * Call to interact with a contract on the EVM
   * Function will encode the function data and prepare the transaction when the appropriate parameters are passed
   *
   * @param abi - the ABI of the contract to call
   * @param functionName - the name of the function to call
   * @param args - the arguments to pass to the function
   * @param fromFuturePass - whether to use the FuturePass for the transaction
   * @returns the EvmBuilder instance
   */
  async writeContract({
    to: t,
    abi: e,
    functionName: r,
    args: i = void 0,
    fromFuturePass: s = !1,
    value: n = "0",
    maxPriorityFeePerGas: a = null,
    nonce: o = null
  }) {
    if (!this.api)
      throw new Error("API is not connected");
    if (!e)
      throw new Error("ABI is required");
    if (!r)
      throw new Error("Function name is required");
    const l = JSON.parse(JSON.stringify(e)).find(
      (u) => u.name === r
    );
    if (!l)
      throw new Error("Function not found in ABI");
    if (i && l.inputs.length !== i.length)
      throw new Error("Arguments do not match function inputs");
    const c = I({
      abi: e,
      functionName: r,
      args: i
    });
    return await this.prepareTransaction({
      to: t,
      data: c,
      value: n,
      maxPriorityFeePerGas: a,
      nonce: o,
      fromFuturePass: s
    }), this;
  }
  async readContract({
    contractAddress: t,
    abi: e,
    functionName: r,
    args: i
  }) {
    return this.queryBuilder.readContract({
      contractAddress: t,
      abi: e,
      functionName: r,
      args: i
    });
  }
  /**
   * Used to prepare the transaction for sending to the EVM
   *
   * @param to - the address sending the transaction to
   * @param data - the data to send with the transaction
   * @param value - the value to send with the transaction
   * @param maxPriorityFeePerGas - the max priority fee per gas to use
   * @param nonce - the nonce to use for the transaction
   * @param fromFuturePass - whether to use the FuturePass for the transaction
   * @returns the address to use for the transaction
   */
  async prepareTransaction({
    to: t,
    data: e,
    value: r,
    maxPriorityFeePerGas: i = null,
    nonce: s = null,
    fromFuturePass: n
  }) {
    var o, h, l, c;
    if (!this.api)
      throw new Error("API is not connected");
    const a = n ? await this.getFuturePass(this.walletAddress) : this.walletAddress;
    this.addressToUse = a, t && (this._contractAddress = t);
    try {
      e && (this.transactionData = e), await this.getEvmGasInfo();
      const u = await this.getEthGasPrice();
      this.setGasFee(u.toString()), await this.setGasInfo(u.toString());
      const E = await this.api.rpc.eth.gasPrice(), x = (c = (l = (h = (o = this.api) == null ? void 0 : o.tx) == null ? void 0 : h.evm) == null ? void 0 : l.call) == null ? void 0 : c.call(
        l,
        a,
        this._contractAddress,
        e,
        r,
        this.gasLimit.toString(),
        E.toString(),
        i ?? null,
        s,
        []
      );
      this._evmCall = x, super.setBaseExtrinsic(x), n && await this.addFuturePass(a);
    } catch (u) {
      throw new Error(u.message);
    }
    return a;
  }
  /**
   * Gets the EVM gas Price for the transaction
   *
   * @param slippage - the slippage to use for the fee - in percentage
   * @returns the EVM gas Price for the transaction
   */
  async getEthGasPrice(t = 5) {
    const e = await this.api.rpc.eth.gasPrice(), r = BigInt(
      Number(this.gasLimit) * Number(e.toString()) * Number(1 + t / 100)
    ), i = r % BigInt(10 ** 12), s = r / BigInt(10 ** 12) + BigInt(i > 0 ? 1 : 0);
    return this.evmGasPrice = s, s;
  }
  /**
   * Gets the EVM gas info for the transaction
   *
   * @returns the EVM gas info for the transaction
   */
  async getEvmGasInfo() {
    var e, r, i;
    const t = await ((i = (r = (e = this.api) == null ? void 0 : e.rpc) == null ? void 0 : r.eth) == null ? void 0 : i.estimateGas({
      to: this._contractAddress,
      from: this.addressToUse,
      data: this.transactionData,
      nonce: this.nonce
    }));
    return this._evmGasInfo = t, this.gasLimit = BigInt(t.toString()), t;
  }
  /**
   * Helper function to wrap the extrinsic in a FuturePass
   *
   * @param futurePass - the future pass to proxy the extrinsic through
   * @param assetId - the asset ID to pay the fee in (1 for ROOT, 2 for XRP etc)
   * @param slippage - the slippage to use for the fee - in percentage
   * @returns the FuturePassExtrinsic and the maxPayment
   */
  async futurepassLogic(t, e, r) {
    const i = this.api.tx.futurepass.proxyExtrinsic(
      t,
      this._evmCall
    );
    this._futurePassWrapped = !0, this.isEvmFuturePass = !0, this._extrinsicToSend = i;
    const s = await this.getPaymentInfo(
      i,
      t,
      e,
      r
    );
    return { futurePassExtrinsic: i, maxPayment: s };
  }
  /**
   * Helper function to add a FuturePass Proxy to the extrinsic
   *
   * @param futurePass - the future pass to proxy the extrinsic through
   * @returns the TransactionBuilder instance
   */
  async addFuturePass(t) {
    if (!this.api) throw new Error("API is not connected");
    if (!this.signer) throw new Error("Signer is not connected");
    if (!this.walletAddress || !this.addressToUse)
      throw new Error("walletAddress is not connected");
    if (!this._evmCall) throw new Error("Base Extrinsic is not set");
    if (this._feeProxyWrapped)
      throw new Error(
        "Cannot add FuturePass to a FeeProxy wrapped extrinsic, please add FuturePass before FeeProxy"
      );
    if (this._futurePassWrapped) throw new Error("FuturePass already added");
    const { futurePassExtrinsic: e, maxPayment: r } = await this.futurepassLogic(
      t,
      2,
      0
    );
    await this.getEvmGasInfo();
    const i = await this.getEthGasPrice();
    this.setGasFee((i + r).toString()), await this.setGasInfo((i + r).toString()), this._extrinsicToSend = e, this.futurePassEvmCall = e;
    const { ethPayload: s, trnPayload: n } = await this.generateExtrinsicPayloads(
      e.method
    );
    return this._ethPayload = s, this._trnPayload = n, this;
  }
  /**
   * Helper function to add a FeeProxy to the extrinsic
   *
   * @param assetId - the asset ID to pay the fee in (1 for ROOT, 2 for XRP etc)
   * @param slippage - the slippage to use for the fee - in percentage
   * @returns the TransactionBuilder instance
   */
  async addFeeProxy({
    assetId: t,
    slippage: e
  }) {
    var u, E;
    if (!this.api) throw new Error("API is not connected");
    if (!this.signer) throw new Error("Signer is not connected");
    if (!this.walletAddress || !this.addressToUse)
      throw new Error("walletAddress is not connected");
    if (!this._evmCall) throw new Error("Base Extrinsic is not set");
    if (this._feeProxyWrapped) throw new Error("FeeProxy already added");
    const r = this.isEvmFuturePass ? this.futurePassEvmCall : this._evmCall;
    if (!r)
      throw new Error("Extrinsic not set");
    this._gasToken = t;
    let i = BigInt(0);
    if (this._xamanWrapped) {
      const g = await this.getXamanCall(r).paymentInfo(
        this.walletAddress
      );
      i = BigInt(g.partialFee.toString());
    }
    const n = await this.api.tx.feeProxy.callWithFeePreferences(
      t ?? 0,
      0,
      r
    ).paymentInfo(
      this.addressToUse
    ), a = BigInt(n.partialFee.toString()) + this.evmGasPrice + i, o = await this.getAmountsIn(
      a.toString(),
      t,
      e
    ), h = (E = (u = this.api.tx.feeProxy) == null ? void 0 : u.callWithFeePreferences) == null ? void 0 : E.call(
      u,
      t ?? 0,
      o == null ? void 0 : o.toString(),
      r
    );
    this.setGasFee(o.toString()), await this.setGasInfo(o.toString()), this._feeProxyWrapped = !0, this._extrinsicToSend = h;
    const { ethPayload: l, trnPayload: c } = await this.generateExtrinsicPayloads(
      h.method
    );
    return this._ethPayload = l, this._trnPayload = c, this;
  }
}
class j extends f {
  /**
   * Constructor for the TransactionBuilder
   *
   * @param api - the trnApi to use for interaction
   * @param signer - the signer to use for signing transactions
   * @param walletAddress - the wallet address to use for interaction - should be the EOA address for the signer, not the FuturePass address
   */
  constructor(t, e, r) {
    super(t, e, r);
  }
  /**
   * Returns true always
   *
   * @returns always true
   */
  async exists() {
    return !0;
  }
  /**
   * Creates an NftBuilder class instance - this provides methods to build transactions for NFT pallet
   *
   * @param api - the trnApi to use for interaction
   * @param signer - the signer to use for signing transactions
   * @param walletAddress - the wallet address to use for interaction - should be the EOA address for the signer, not the FuturePass address
   * @param collectionId - the Collection ID to target
   * @returns the TransactionBuilder instance
   **/
  static nft(t, e, r, i) {
    return new U(t, e, r, i);
  }
  /**
   * Creates an SftBuilder class instance - this provides methods to build transactions for SFT pallet
   *
   * @param api - the trnApi to use for interaction
   * @param signer - the signer to use for signing transactions
   * @param walletAddress - the wallet address to use for interaction - should be the EOA address for the signer, not the FuturePass address
   * @param collectionId - the Collection ID to target
   * @returns the SftBuilder instance
   **/
  static sft(t, e, r, i) {
    return new z(t, e, r, i);
  }
  /**
   * Creates an AssetBuilder class instance - this provides methods to build transactions for assets pallet
   *
   * @param api - the trnApi to use for interaction
   * @param signer - the signer to use for signing transactions
   * @param walletAddress - the wallet address to use for interaction - should be the EOA address for the signer, not the FuturePass address
   * @param assetId - the asset ID to use
   * @returns an AssetBuilder instance
   */
  static asset(t, e, r, i) {
    return new R(t, e, r, i);
  }
  /**
   * Creates a crowdsale builder class instance - this provides methods to build transactions for crowdsale pallet
   *
   * @param api - the trnApi to use for interaction
   * @param signer - the signer to use for signing transactions
   * @param walletAddress - the wallet address to use for interaction - should be the EOA address for the signer, not the FuturePass address
   * @param saleId - the Sale ID to target
   * @returns the CrowdsaleBuilder instance
   **/
  static crowdsale(t, e, r, i) {
    return new L(t, e, r, i);
  }
  /**
   * Creates a custom extrinsic builder instance - this provides methods to build transactions using extrinsics passed in by the user to make use of other methods of the library
   *
   * @param api - the trnApi to use for interaction
   * @param signer - the signer to use for signing transactions
   * @param walletAddress - the wallet address to use for interaction - should be the EOA address for the signer, not the FuturePass address
   * @returns the CustomExtrinsicBuilder instance
   **/
  static custom(t, e, r) {
    return new k(t, e, r);
  }
  /**
   * Creates a BatchBuilder class instance - this provides methods to build transactions for utility pallet batch extrinsics
   *
   * @param api - the trnApi to use for interaction
   * @param signer - the signer to use for signing transactions
   * @param walletAddress - the wallet address to use for interaction - should be the EOA address for the signer, not the FuturePass address
   * @returns a BatchBuilder instance
   */
  static batch(t, e, r) {
    return new M(t, e, r);
  }
  /**
   * Creates a remark builder class instance - this provides methods to build transactions for system pallet remark extrinsics
   *
   * @param api - the trnApi to use for interaction
   * @param signer - the signer to use for signing transactions
   * @param walletAddress - the wallet address to use for interaction - should be the EOA address for the signer, not the FuturePass address
   * @returns the RemarkBuilder instance
   **/
  static remark(t, e, r) {
    return new $(t, e, r);
  }
  /**
   * Creates an EVM builder class instance - this provides methods to build transactions for EVM pallet
   *
   * @param api - the trnApi to use for interaction
   * @param signer - the signer to use for signing transactions
   * @param walletAddress - the wallet address to use for interaction - should be the EOA address for the signer, not the FuturePass address
   * @param contractAddress - the contract address to use for interaction
   * @returns an EvmBuilder instance
   * @note the Evm Builder Class acts differently from the other builders in relation to the FuturePass and FeeProxy logic =>
   *       you need to to set the fromFuturePass flag to true when calling the writeContract method to use the FuturePass
   **/
  static evm(t, e, r, i) {
    return new H(t, e, r, i);
  }
}
export {
  R as AssetBuilder,
  M as BatchBuilder,
  L as CrowdsaleBuilder,
  k as CustomExtrinsicBuilder,
  H as EvmBuilder,
  U as NftBuilder,
  $ as RemarkBuilder,
  D as RootQueryBuilder,
  f as RootTransactionBuilder,
  z as SftBuilder,
  G as TOKEN_DECIMALS,
  W as TOKEN_NAME,
  j as TransactionBuilder,
  T as XRP_ASSET_ID
};
