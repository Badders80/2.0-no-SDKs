"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});require("@therootnetwork/api-types");const I=require("@polkadot/util-crypto"),g=require("@polkadot/util"),L=require("@futureverse/signer"),d=require("viem");class _{constructor(t,e){this.api=t,this.walletAddress=e}async getFuturePass(t){if(!this.api)throw new Error("API is not connected");if(!t||t==="")throw new Error("Address is required");const e=(await this.api.query.futurepass.holders(t)).unwrapOr(null);if(!e)throw new Error("No FuturePass Found, please connect with your primary ETH address");return e.toString()}async checkBalance({walletAddress:t,assetId:e}){if(!this.api)throw new Error("API is not connected");if(!e)throw new Error("Asset ID is required");const r=await this.api.query.assets.metadata(e),i=await this.api.rpc.assetsExt.freeBalance(e,t??this.walletAddress);return{assetId:e,walletAddress:t??this.walletAddress,balance:i.toString(),decimals:parseInt(r.decimals.toString())}}async checkBalances(t){if(!this.api)throw new Error("API is not connected");if(!t)throw new Error("Address and Asset IDs are required");const e=async({walletAddress:o})=>{const h=await this.api.rpc.assetsExt.freeBalance(1,o??this.walletAddress);return{assetId:1,walletAddress:o??this.walletAddress,balance:h.toString(),decimals:6}},r=({walletAddress:o,assetId:h},l)=>{var u;const c=a[l].unwrapOr("0");return{assetId:h,walletAddress:o??this.walletAddress,balance:((u=c==null?void 0:c.balance)==null?void 0:u.toString())??"0",decimals:parseInt(n[l].decimals.toString())}},i=t.filter(({assetId:o})=>o===1),s=await Promise.all(i.map(e)),n=await this.api.query.assets.metadata.multi(t.filter(o=>o.assetId!==1).map(({assetId:o})=>o)),a=await this.api.query.assets.account.multi(t.filter(o=>o.assetId!==1).map(({walletAddress:o,assetId:h})=>[h,o??this.walletAddress]));return[...s,...t.filter(o=>o.assetId!==1).map(r)]}async getAmountsIn(t,e,r=5){const{Ok:[i]}=await this.api.rpc.dex.getAmountsIn(t,[e,B]);return BigInt(Math.round(Number(i*(1+r/100))))}async readContract({contractAddress:t,abi:e,functionName:r,args:i}){if(!this.api)throw new Error("API is not connected");if(!t)throw new Error("Contract Address is required");if(!e)throw new Error("ABI is required");if(!r)throw new Error("Function Name is required");const s=await d.encodeFunctionData({abi:e,functionName:r,args:i}),n=await this.api.rpc.eth.call({to:t,data:s});return await d.decodeFunctionResult({abi:e,functionName:r,data:n.toHex()})}}const B=2,b=6,A="XRP";class f{constructor(t,e,r){this._baseExtrinsic=null,this._extrinsicToSend=null,this._futurePassWrapped=!1,this._feeProxyWrapped=!1,this._xamanWrapped=!1,this._ethPayload=null,this._trnPayload=null,this._gasFee="0",this._gasToken=2,this._gasString="",this._tokenDecimals=0,this.api=t,this.signer=e,this.walletAddress=r,this._xamanWrapped=e instanceof L.XamanSigner,this.queryBuilder=new _(t,r)}resetBase(){return this._baseExtrinsic=null,this._extrinsicToSend=null,this._futurePassWrapped=!1,this._feeProxyWrapped=!1,this._ethPayload=null,this._trnPayload=null,this._gasFee="0",this._gasToken=2,this._gasString="",this._tokenDecimals=0,this}checks(){return this.exists()}setBaseExtrinsic(t){return this.validateConnections(),this._baseExtrinsic=t,this._extrinsicToSend=t,this}getBaseExtrinsic(){return this._baseExtrinsic}async addFuturePass(t){if(this.validateConnections(),!this._baseExtrinsic)throw new Error("Base Extrinsic is not set");if(this._futurePassWrapped)throw new Error("FuturePass already added");if(this._feeProxyWrapped)throw new Error("Cannot add FuturePass to a FeeProxy wrapped extrinsic, please add FuturePass before FeeProxy");const{futurePassExtrinsic:e,maxPayment:r}=await this.futurepassLogic(t,2,0);this.setGasFee(r.toString()),await this.setGasInfo(r.toString()),this._extrinsicToSend=e;const{ethPayload:i,trnPayload:s}=await this.generateExtrinsicPayloads(e.method);return this._ethPayload=i,this._trnPayload=s,this}async addFeeProxy({assetId:t,slippage:e}){if(this.validateConnections(),!this._baseExtrinsic)throw new Error("Base Extrinsic is not set");if(this._feeProxyWrapped)throw new Error("FeeProxy already added");this._gasToken=t;const{maxPayment:r,feeProxyCall:i}=await this.feeProxyLogic(this._baseExtrinsic,this.walletAddress,t,e);this.setGasFee(BigInt(r).toString()),await this.setGasInfo(BigInt(r).toString()),this._feeProxyWrapped=!0,this._extrinsicToSend=i;const{ethPayload:s,trnPayload:n}=await this.generateExtrinsicPayloads(i.method);return this._ethPayload=s,this._trnPayload=n,this}async addFuturePassAndFeeProxy({futurePass:t,assetId:e,slippage:r}){if(this.validateConnections(),!this._baseExtrinsic)throw new Error("Base Extrinsic is not set");this._gasToken=e;const{futurePassExtrinsic:i}=await this.futurepassLogic(t,e,r),{maxPayment:s,feeProxyCall:n}=await this.feeProxyLogic(i,t,e,r);this.setGasFee(BigInt(s).toString()),await this.setGasInfo(BigInt(s).toString()),this._extrinsicToSend=n;const{ethPayload:a,trnPayload:o}=await this.generateExtrinsicPayloads(n.method);return this._ethPayload=a,this._trnPayload=o,this}async getPayloads(){var e;if(!await this.exists())throw new Error("Asset ID, Collection ID or Sale ID does not exist");if(this.validateConnections(),!this._ethPayload||!this._trnPayload){const{ethPayload:r,trnPayload:i}=await this.generateExtrinsicPayloads((e=this._extrinsicToSend)==null?void 0:e.method);this._ethPayload=r,this._trnPayload=i}return{ethPayload:this._ethPayload,trnPayload:this._trnPayload}}async getGasFees(){if(this.validateConnections(),!this._extrinsicToSend)throw new Error("Extrinsic is not set");if(!this._futurePassWrapped&&!this._feeProxyWrapped){const t=await this._extrinsicToSend.paymentInfo(this.walletAddress),e=BigInt(t.partialFee.toString());if(this._xamanWrapped){const i=await this.getXamanCall(this._extrinsicToSend).paymentInfo(this.walletAddress),s=BigInt(i.partialFee.toString()),n=BigInt(s);this.setGasFee(n.toString()),await this.setGasInfo(n.toString())}else this.setGasFee(e.toString()),await this.setGasInfo(e.toString())}return{gasString:this._gasString,gasFee:this._gasFee,tokenDecimals:this._tokenDecimals}}async sign(){if(this.validateConnections(),!this._extrinsicToSend)throw new Error("Extrinsic is not set");if((!this._ethPayload||!this._trnPayload)&&await this.getPayloads(),!await this.exists())throw new Error("Asset ID, Collection ID or Sale ID does not exist");return this.signer.signExtrinsicWithPayload(this.api,this._extrinsicToSend,{ethPayload:this._ethPayload,trnPayload:this._trnPayload},this.walletAddress)}async signAndSend(t){const e=await this.sign();t!=null&&t.onSign&&t.onSign();const r=await this.sendExtrinsic({api:this.api,signedExtrinsic:e});return t!=null&&t.onSend&&t.onSend(),r}getExtrinsicToSend(){return this._extrinsicToSend}filterExtrinsicEvents({events:t,names:e}){return t.filter(({event:r})=>{const i=`${r.section[0].toUpperCase()+r.section.slice(1)}.${r.method}`;return e.includes(i)})}async generateExtrinsicPayloads(t,e){this.validateConnections();const{header:r,mortalLength:i,nonce:s}=await this.api.derive.tx.signingInfo(this.walletAddress),n=Object.assign({address:this.walletAddress,blockHash:r==null?void 0:r.hash,blockNumber:r==null?void 0:r.number,era:this.api.registry.createTypeUnsafe("ExtrinsicEra",[{current:r==null?void 0:r.number,period:i}]),genesisHash:this.api.genesisHash,method:t,nonce:s,runtimeVersion:this.api.runtimeVersion,signedExtensions:this.api.registry.signedExtensions,version:this.api.extrinsicVersion},e),a=this.api.registry.createTypeUnsafe("SignerPayload",[n]),{data:o}=a.toRaw(),h=o.length>257*2?I.blake2AsHex(o):o;return{ethPayload:I.blake2AsHex(h),trnPayload:a}}validateConnections(){if(!this.api)throw new Error("API is missing");if(!this.signer)throw new Error("Signer is missing");if(!this.walletAddress)throw new Error("walletAddress is missing")}async feeProxyLogic(t,e,r,i){const s=this.api.tx.feeProxy.callWithFeePreferences(r,0,t),n=await this.getPaymentInfo(s,e,r,i);return{feeProxyCall:this.api.tx.feeProxy.callWithFeePreferences(r,n==null?void 0:n.toString(),t),maxPayment:n}}async futurepassLogic(t,e,r){const i=this.api.tx.futurepass.proxyExtrinsic(t,this._baseExtrinsic);this._futurePassWrapped=!0;const s=await this.getPaymentInfo(i,t,e,r);return{futurePassExtrinsic:i,maxPayment:s}}async getPaymentInfo(t,e,r,i=5){const n=(this._xamanWrapped?await this.getXamanCall(t).paymentInfo(e):await t.paymentInfo(e)).partialFee.toString();return r===2?BigInt(n):await this.getAmountsIn(n,r,i)}async setGasInfo(t){const e=await this.api.query.assets.metadata(this._gasToken),r=this.getGas(this._gasFee.toString(),parseInt(e.decimals.toString()),g.hexToString(e.symbol.toHex()));this._gasString=r,this._gasFee=t,this._tokenDecimals=parseInt(e.decimals.toString())}getXamanCall(t){return this.api.tx.xrpl.transact("0x5916969036626990000000000000000000F236FD752B5E4C84810AB3D41A3C25807321EDFB2A3A850B43E24D2700532EF1F9CCB2475DFF4F62B634B0C58845F23C26396581145116224CEF7355137BEBBA8E277A9BE18E0596E7F9EA7C0965787472696E7369637D8E383339353966376634323632373632663735393963326661343862343138623765313032663932633831666162396536656632326162333739616264623732663A333A31323639343937353A303A33623034653934373565373336353763616665393561653138656335363963336436383738353539643661633939333437316364623562646635396339636432E1F1","0x3BC417D12C9595ABB4551CE518ACDD70AE3B9D9B55CF5110BD5009B4A098AE62CC8C66CD422A0DF67A2B08894C15E423CE6F1EFFCAC540964F84A57E31399102",t)}setGasFee(t){this._gasFee=t}unscaleBy(t,e){return g.formatBalance(t,{decimals:e,forceUnit:"-",withSi:!1}).split(",")}getGas(t,e=b,r=A){return`${this.unscaleBy(t??"0",e).toString()} ${r}`}async sendExtrinsic({api:t,signedExtrinsic:e}){return new Promise((r,i)=>{(async()=>{const n=await e.send(a=>{const{status:o,dispatchError:h,txHash:l,txIndex:c,blockNumber:u}=a;if(!o.isFinalized)return;if(h!=null){if(!h.isModule)return n(),i(new Error(`Extrinsic failed, ${JSON.stringify(h.toJSON())}`));const{section:y,name:P,docs:p}=h.registry.findMetaError(h.asModule);return n(),i(new Error(`Extrinsic sending failed, [${y}.${P}]: ${p.join(", ")}`))}const E=this.filterExtrinsicEvents({events:a.events,names:["Proxy.ProxyExecuted","xrpl.XRPLExtrinsicExecuted"]});for(const y of E){const[P]=y.event.data.toJSON(),p=P;if("err"in p){const{section:M,name:k,docs:W}=t.registry.findMetaError({index:new g.BN(p.err.module.index),error:g.hexToU8a(p.err.module.error)});return n(),i(`Extrinsic sending failed, [${M}.${k}]: ${W.join(", ")}`)}}if(u==null||c==null)return;n();const m=`${u.toString()}-${c.toString()}`;r({result:a,extrinsicId:m,transactionHash:l.toString()})})})().catch(i)})}async checkBalance({walletAddress:t,assetId:e}){return await this.queryBuilder.checkBalance({walletAddress:t,assetId:e})}async checkBalances(t){return await this.queryBuilder.checkBalances(t)}async getFuturePass(t){const e=t??this.walletAddress;if(!e||!e.length||e==="")throw new Error("Address is required");return await this.queryBuilder.getFuturePass(e)}async getAmountsIn(t,e,r=5){return await this.queryBuilder.getAmountsIn(t,e,r)}}class S extends f{constructor(t,e,r){super(t,e,r),this.extrinsics=[]}async exists(){return!0}reset(){return super.resetBase(),this.extrinsics=[],this}batchWithExtrinsics(t){if(!this.api)throw new Error("API is not connected");if(!t||t.length===0)throw new Error("Extrinsics are required");this.checkBatchLimit(t.length,0),this.setExtrinsics(t);const e=this.api.tx.utility.batch(t);return super.setBaseExtrinsic(e),this}batch(){if(!this.api)throw new Error("API is not connected");if(!this.extrinsics||this.extrinsics.length===0)throw new Error("Extrinsics are required");this.checkBatchLimit(0);const t=this.api.tx.utility.batch(this.extrinsics);return super.setBaseExtrinsic(t),this}batchAllWithExtrinsics(t){if(!this.api)throw new Error("API is not connected");if(!t||t.length===0)throw new Error("Extrinsics are required");this.checkBatchLimit(t.length,0),this.setExtrinsics(t);const e=this.api.tx.utility.batchAll(t);return super.setBaseExtrinsic(e),this}batchAll(){if(!this.api)throw new Error("API is not connected");if(!this.extrinsics||this.extrinsics.length===0)throw new Error("Extrinsics are required");this.checkBatchLimit(0);const t=this.api.tx.utility.batchAll(this.extrinsics);return super.setBaseExtrinsic(t),this}addExtrinsic(t){if(!this.api)throw new Error("API is not connected");if(!t)throw new Error("Extrinsic is required");return this.checkBatchLimit(1),this.extrinsics.push(t),this}addExtrinsics(t){if(!this.api)throw new Error("API is not connected");if(!t||t.length===0)throw new Error("Extrinsic is required");return this.checkBatchLimit(t.length),this.extrinsics.push(...t),this}checkBatchLimit(t,e=-1){const r=this.api.consts.utility.batchedCallsLimit.toBigInt();if((e!==-1?e:this.extrinsics.length)+t>r)throw new Error("Batch limit reached, cannot add more extrinsics")}setExtrinsics(t){this.extrinsics=t}getExtrinsics(){return this.extrinsics}}class C extends f{constructor(t,e,r){super(t,e,r)}async exists(){return!0}reset(){return super.resetBase(),this}extrinsic(t){return this.fromExtrinsic(t)}fromExtrinsic(t){if(!this.api)throw new Error("API is not connected");if(!t)throw new Error("An extrinsic is required");return super.setBaseExtrinsic(t),this}}class v extends f{constructor(t,e,r,i){super(t,e,r),this._saleId=i}async exists(){return(await this.api.query.crowdsale.saleInfo(this._saleId)).isSome}reset(t){return super.resetBase(),this._saleId=t,this}static async crowdsaleExists(t,e){return(await t.query.crowdsale.saleInfo(e)).isSome}participate(t){if(!this.api)throw new Error("API is not connected");if(!this._saleId)throw new Error("Sale ID is required");if(!t)throw new Error("Amount is required");const e=this.api.tx.crowdsale.participate(this._saleId,t);return super.setBaseExtrinsic(e),this}redeem(t){if(!this.api)throw new Error("API is not connected");if(!this._saleId)throw new Error("Sale ID is required");if(!t)throw new Error("Quantity is required");const e=this.api.tx.crowdsale.redeemVoucher(this._saleId,t);return super.setBaseExtrinsic(e),this}claim(){if(!this.api)throw new Error("API is not connected");if(!this._saleId)throw new Error("Sale ID is required");const t=this.api.tx.crowdsale.claimVoucher(this._saleId);return super.setBaseExtrinsic(t),this}}class F extends f{constructor(t,e,r,i){super(t,e,r),this._assetId=i}async exists(){return this._assetId===1||this._assetId===2?!0:(await this.api.query.assets.asset(this._assetId)).isSome}reset(t){return super.resetBase(),this._assetId=t,this}static async assetExists(t,e){return(await t.query.assets.asset(e)).isSome}transfer({destinationAddress:t,amount:e}){if(!this.api)throw new Error("API is not connected");if(!this._assetId)throw new Error("Asset ID is required");if(!t)throw new Error("destinationAddress is required");if(!e)throw new Error("Amount is required");if(!t.startsWith("0x")||!d.isAddress(t))throw new Error("destinationAddress is not a valid address");if(t==="0x0000000000000000000000000000000000000000")throw new Error("destinationAddress cannot be the zero address");const r=this.api.tx.assetsExt.transfer(this._assetId,t,e,!0);return super.setBaseExtrinsic(r),this}}class q extends f{constructor(t,e,r,i){super(t,e,r),i!==void 0&&(this._collectionId=i)}static async nftExists(t,e){return(await t.query.nft.collectionInfo(e)).isSome}async exists(){if(!this.api)throw new Error("API is not connected");return this._collectionId?(await this.api.query.nft.collectionInfo(this._collectionId)).isSome:!0}reset(t){return super.resetBase(),t&&(this._collectionId=t),this}mint({quantity:t,walletAddress:e}){if(!this.api)throw new Error("API is not connected");if(!this._collectionId)throw new Error("Collection ID is required");if(!e||e===""||!d.isAddress(e))throw new Error("WalletAddress is required or is not a valid address");if(e==="0x0000000000000000000000000000000000000000")throw new Error("walletAddress cannot be the zero address");if(typeof t!="number"||t<1||parseInt(t.toString())<1)throw new Error("Quantity is required and must be a number greater than 0");if(typeof t!="number"||t>1e3||parseInt(t.toString())>1e3)throw new Error("Quantity is required and must be a number less than 1000");const r=this.api.tx.nft.mint(this._collectionId,t,e);return super.setBaseExtrinsic(r),this}transfer({serialNumbers:t,walletAddress:e}){if(!this.api)throw new Error("API is not connected");if(!e||e===""||!d.isAddress(e))throw new Error("WalletAddress is required or is not a valid address");if(e==="0x0000000000000000000000000000000000000000")throw new Error("walletAddress cannot be the zero address");if(!t||!Array.isArray(t)||t.length<1)throw new Error("Serial numbers are required and must be an array with at least one element");if(!t.every(i=>typeof i=="number"))throw new Error("All elements in the serial numbers array must be numbers");if(!this._collectionId)throw new Error("Collection ID is required");const r=this.api.tx.nft.transfer(this._collectionId,t,e);return super.setBaseExtrinsic(r),this}burn({serialNumber:t}){if(!this.api)throw new Error("API is not connected");if(typeof t!="number"||t<0)throw new Error("Serial number is required and must be a number greater than or equal to 0");if(!this._collectionId)throw new Error("Collection ID is required");const e=this.api.tx.nft.burn([this._collectionId,t]);return super.setBaseExtrinsic(e),this}setCollectionId(t){return this._collectionId=t,this}createCollection({name:t,initialIssuance:e=null,maxIssuance:r=null,tokenOwner:i=null,metadataUri:s,royalties:n=null,crossChain:a=null}){if(!this.api)throw new Error("API is not connected");if(!t)throw new Error("Collection Name is required");if(!s)throw new Error("Metadata URI is required");if(i&&!d.isAddress(i))throw new Error("tokenOwner is not a valid address");if(i==="0x0000000000000000000000000000000000000000")throw new Error("tokenOwner cannot be the zero address");if(e!==null&&(parseInt(e.toString())<0||parseInt(e.toString())>1e3))throw new Error("Initial issuance must be a number greater than 0 and less than 1000");if(r!==null&&BigInt(r.toString())<=0)throw new Error("Max issuance must be a number greater than 0");if(n&&!n.every(c=>Array.isArray(c)&&c.length===2&&d.isAddress(c[0].toString())&&c[0].toString()!==""&&c[0].toString()!=="0x0000000000000000000000000000000000000000"&&c[0].toString().length===42&&(typeof c[1]=="number"||typeof c[1]=="bigint")))throw new Error("Royalties are not in the correct format");const o=n?{entitlements:n}:null,h={xrpl:a},l=this.api.tx.nft.createCollection(t,e??0,r??null,i===""?null:i??null,s,o??null,h??null);return super.setBaseExtrinsic(l),this}updateMetadataUri(t){if(!this.api)throw new Error("API is not connected");if(!t)throw new Error("Metadata URI is required");if(!this._collectionId)throw new Error("Collection ID is required");const e=this.api.tx.nft.setBaseUri(this._collectionId,t);return super.setBaseExtrinsic(e),this}updateRoyalties({royalties:t}){if(!this.api)throw new Error("API is not connected");if(!this._collectionId)throw new Error("Collection ID is required");if(!t)throw new Error("Royalties are required");if(!Array.isArray(t))throw new Error("Royalties must be an array");if(!t.every(r=>Array.isArray(r)&&r.length===2&&d.isAddress(r[0].toString())&&r[0].toString()!==""&&r[0].toString()!=="0x0000000000000000000000000000000000000000"&&r[0].toString().length===42&&(typeof r[1]=="number"||typeof r[1]=="bigint")))throw new Error("Royalties are not in the correct format");const e=this.api.tx.nft.setRoyaltiesSchedule(this._collectionId,{entitlements:t});return super.setBaseExtrinsic(e),this}updateMaxIssuance(t){if(!this.api)throw new Error("API is not connected");if(!this._collectionId)throw new Error("Collection ID is required");if(!t)throw new Error("Max Issuance is required");if(BigInt(t.toString())<=0)throw new Error("Max issuance must be a number greater than 0");const e=this.api.tx.nft.setMaxIssuance(this._collectionId,t);return super.setBaseExtrinsic(e),this}transferCollection(t){if(!this.api)throw new Error("API is not connected");if(!this._collectionId)throw new Error("Collection ID is required");if(!t||t===""||!d.isAddress(t))throw new Error("Token Owner is required or is not a valid address");if(t.length!==42||t==="0x0000000000000000000000000000000000000000")throw new Error("newOwner cannot be the zero address");const e=this.api.tx.nft.setOwner(this._collectionId,t);return super.setBaseExtrinsic(e),this}async setPrice({assetId:t,price:e}={}){if(!this.api)throw new Error("API is not connected");if(!this._collectionId)throw new Error("Collection ID is required");if((t===void 0||t===0)&&(e===void 0||e===0)){if(t!==void 0&&t>0&&(e===void 0||Number(e)<=0))throw new Error("Price is required and must be greater than 0 when assetId is provided and greater than 0");if(e!==void 0&&Number(e)>0&&(t===void 0||t<=0))throw new Error("AssetId is required and must be greater than 0 when price is provided and greater than 0");if(e!==void 0&&e!==0&&(typeof e!="number"&&typeof e!="bigint"&&typeof e!="string"||typeof e=="string"&&parseInt(e)<=0||typeof e!="string"&&e<=0))throw new Error("Price must be a number greater than 0");if(t!==void 0&&t!==0&&(typeof t!="number"&&typeof t!="bigint"&&typeof t!="string"||typeof t=="string"&&parseInt(t)<=0||typeof t!="string"&&t<=0))throw new Error("AssetId must be a number greater than 0")}const r=this.api.tx.nft.setMintFee(this._collectionId,t&&e?[t,e]:null);return super.setBaseExtrinsic(r),this}togglePublicMint(t){if(!this.api)throw new Error("API is not connected");if(!this._collectionId)throw new Error("Collection ID is required");const e=this.api.tx.nft.togglePublicMint(this._collectionId,t);return super.setBaseExtrinsic(e),this}}class D extends f{constructor(t,e,r){super(t,e,r)}async exists(){return!0}reset(){return super.resetBase(),this}message(t){if(!this.api)throw new Error("API is not connected");if(!t||t==="")throw new Error("A message is required");const e=this.api.tx.system.remark(t);return super.setBaseExtrinsic(e),this}}class T extends f{constructor(t,e,r,i){if(super(t,e,r),i!==void 0){if(typeof i!="number"||i<=0)throw new Error("Collection ID must be a positive number");this._collectionId=i}}static async sftExists(t,e){return(await t.query.sft.sftCollectionInfo(e)).isSome}async exists(){return this._collectionId?!!await this.api.query.sft.sftCollectionInfo(this._collectionId):!0}reset(t){if(super.resetBase(),t){if(typeof t!="number"||t<=0)throw new Error("Collection ID must be a positive number");this._collectionId=t}return this}mint({serialNumbers:t,walletAddress:e}){if(!this.api)throw new Error("API is not connected");if(e===null||e===""||e.length!==42||e==="0x0000000000000000000000000000000000000000")throw new Error("walletAddress must be a valid address and not a zero address");if(!e||!d.isAddress(e))throw new Error("WalletAddress is required or is not a valid address");if(t.length<1)throw new Error("Serial numbers are required");if(this._collectionId===void 0)throw new Error("Collection ID is required");if(!t.every(({tokenId:i,quantity:s})=>typeof i=="number"&&(typeof s=="number"||typeof s=="bigint"||typeof s=="string")))throw new Error("All elements in the serial numbers array must be objects with a tokenId and quantity property");const r=this.api.tx.sft.mint(this._collectionId,t.map(({tokenId:i,quantity:s})=>[i,s]),e);return super.setBaseExtrinsic(r),this}transfer({serialNumbers:t,walletAddress:e}){if(!this.api)throw new Error("API is not connected");if(!e||!d.isAddress(e))throw new Error("WalletAddress is required or is not a valid address");if(!Array.isArray(t)||t.length<1)throw new Error("Serial numbers are required");if(!t.every(({tokenId:i,quantity:s})=>typeof i=="number"&&(typeof s=="number"||typeof s=="bigint"||typeof s=="string")))throw new Error("All elements in the serial numbers array must be objects with a tokenId and quantity property");if(this._collectionId===void 0)throw new Error("Collection ID is required");const r=this.api.tx.sft.transfer(this._collectionId,t.map(({tokenId:i,quantity:s})=>[i,s]),e);return super.setBaseExtrinsic(r),this}burn({serialNumbers:t}){if(!this.api)throw new Error("API is not connected");if(!Array.isArray(t)||t.length<1)throw new Error("Serial numbers are required");if(this._collectionId===void 0)throw new Error("Collection ID is required");if(!t.every(({tokenId:r,quantity:i})=>typeof r=="number"&&(typeof i=="number"||typeof i=="bigint"||typeof i=="string")))throw new Error("All elements in the serial numbers array must be objects with a tokenId and quantity property");const e=this.api.tx.sft.burn(this._collectionId,t.map(({tokenId:r,quantity:i})=>[r,i]));return super.setBaseExtrinsic(e),this}createCollection({collectionName:t,collectionOwner:e=null,metadataUri:r,royalties:i=null}){if(!this.api)throw new Error("API is not connected");if(!t)throw new Error("Collection collectionName is required");if(!r)throw new Error("Metadata URI is required");if(e===""||e==="0x0000000000000000000000000000000000000000")throw new Error("collectionOwner cannot be the zero address");if(e&&!d.isAddress(e))throw new Error("Collection owner is not a valid address");if(i&&!i.every(a=>Array.isArray(a)&&a.length===2&&d.isAddress(a[0].toString())&&a[0].toString()!==""&&a[0].toString()!=="0x0000000000000000000000000000000000000000"&&a[0].toString().length===42&&(typeof a[1]=="number"||typeof a[1]=="bigint")))throw new Error("Royalties are not in the correct format");const s=i?{entitlements:i}:null,n=this.api.tx.sft.createCollection(t,e===""?null:e,r,s??null);return super.setBaseExtrinsic(n),this}createToken({tokenName:t,initialIssuance:e=null,maxIssuance:r=null,tokenOwner:i=null}){if(!this.api)throw new Error("API is not connected");if(!this._collectionId)throw new Error("Collection ID is required");if(!t)throw new Error("Collection tokenName is required");if(i&&!d.isAddress(i))throw new Error("Token owner is not a valid address");if(i===""||i==="0x0000000000000000000000000000000000000000")throw new Error("tokenOwner cannot be the zero address");if(e!==null&&(Number(e)<0||Number(e)>1e3))throw new Error("Initial issuance must be between 0 and 1000");if(r!==null&&BigInt(r.toString())<=0)throw new Error("Max issuance must be a number greater than or equal to 0");const s=this.api.tx.sft.createToken(this._collectionId,t,e??0,r,i);return super.setBaseExtrinsic(s),this}async setPrice({tokenId:t,assetId:e,price:r}){if(!this.api)throw new Error("API is not connected");if(!this._collectionId)throw new Error("Collection ID is required");if(typeof t>"u"||t===null)throw new Error("Token ID is required");if(typeof t!="number"&&typeof t!="bigint")throw new Error("Token ID must be a number or bigint");if((e===void 0||e===0)&&(r===void 0||r===0)){if(e!==void 0&&e>0&&(r===void 0||Number(r)<=0))throw new Error("Price is required and must be greater than 0 when assetId is provided and greater than 0");if(r!==void 0&&Number(r)>0&&(e===void 0||e<=0))throw new Error("AssetId is required and must be greater than 0 when price is provided and greater than 0");if(r!==void 0&&r!==0&&(typeof r!="number"&&typeof r!="bigint"&&typeof r!="string"||typeof r=="string"&&parseInt(r)<=0||typeof r!="string"&&r<=0))throw new Error("Price must be a number greater than 0");if(e!==void 0&&e!==0&&(typeof e!="number"&&typeof e!="bigint"&&typeof e!="string"||typeof e=="string"&&parseInt(e)<=0||typeof e!="string"&&e<=0))throw new Error("AssetId must be a number greater than 0")}const i=this.api.tx.sft.setMintFee([this._collectionId,t],e&&r?[e,r]:null);return super.setBaseExtrinsic(i),this}togglePublicMint(t,e){if(!this.api)throw new Error("API is not connected");if(!this._collectionId)throw new Error("Collection ID is required");if(typeof t>"u"||t===null)throw new Error("Token ID is required");if(typeof t!="number"&&typeof t!="bigint")throw new Error("Token ID must be a number or bigint");if(typeof e!="boolean")throw new Error("Public minting enabled must be a boolean");const r=this.api.tx.sft.togglePublicMint([this._collectionId,t],e);return super.setBaseExtrinsic(r),this}}class G extends f{constructor(t,e,r,i){if(super(t,e,r),this._contractAddress=null,this._evmGasInfo=null,this._evmCall=null,this.futurePassEvmCall=null,this.isEvmFuturePass=!1,this.transactionData=null,this.addressToUse=null,this.gasLimit=BigInt(0),this.evmGasPrice=BigInt(0),this.nonce=null,i&&!d.isAddress(i))throw new Error("Invalid contract address");i&&(this._contractAddress=i)}async exists(){return!0}reset(t){if(super.resetBase(),t&&!d.isAddress(t))throw new Error("Invalid contract address");return this._contractAddress=t||null,this._evmGasInfo=null,this._evmCall=null,this.futurePassEvmCall=null,this.isEvmFuturePass=!1,this.transactionData=null,this.addressToUse=null,this.gasLimit=BigInt(0),this.evmGasPrice=BigInt(0),this.nonce=null,this}async evmOverride({to:t,data:e="",value:r=BigInt(0),maxPriorityFeePerGas:i=null,nonce:s=null,fromFuturePass:n=!1}){if(!this.api)throw new Error("API is not connected");return await this.prepareTransaction({to:t,data:e,value:r.toString(),maxPriorityFeePerGas:i??null,nonce:s,fromFuturePass:n}),this}async writeContract({to:t,abi:e,functionName:r,args:i=void 0,fromFuturePass:s=!1,value:n="0",maxPriorityFeePerGas:a=null,nonce:o=null}){if(!this.api)throw new Error("API is not connected");if(!e)throw new Error("ABI is required");if(!r)throw new Error("Function name is required");const l=JSON.parse(JSON.stringify(e)).find(u=>u.name===r);if(!l)throw new Error("Function not found in ABI");if(i&&l.inputs.length!==i.length)throw new Error("Arguments do not match function inputs");const c=d.encodeFunctionData({abi:e,functionName:r,args:i});return await this.prepareTransaction({to:t,data:c,value:n,maxPriorityFeePerGas:a,nonce:o,fromFuturePass:s}),this}async readContract({contractAddress:t,abi:e,functionName:r,args:i}){return this.queryBuilder.readContract({contractAddress:t,abi:e,functionName:r,args:i})}async prepareTransaction({to:t,data:e,value:r,maxPriorityFeePerGas:i=null,nonce:s=null,fromFuturePass:n}){var o,h,l,c;if(!this.api)throw new Error("API is not connected");const a=n?await this.getFuturePass(this.walletAddress):this.walletAddress;this.addressToUse=a,t&&(this._contractAddress=t);try{e&&(this.transactionData=e),await this.getEvmGasInfo();const u=await this.getEthGasPrice();this.setGasFee(u.toString()),await this.setGasInfo(u.toString());const E=await this.api.rpc.eth.gasPrice(),x=(c=(l=(h=(o=this.api)==null?void 0:o.tx)==null?void 0:h.evm)==null?void 0:l.call)==null?void 0:c.call(l,a,this._contractAddress,e,r,this.gasLimit.toString(),E.toString(),i??null,s,[]);this._evmCall=x,super.setBaseExtrinsic(x),n&&await this.addFuturePass(a)}catch(u){throw new Error(u.message)}return a}async getEthGasPrice(t=5){const e=await this.api.rpc.eth.gasPrice(),r=BigInt(Number(this.gasLimit)*Number(e.toString())*Number(1+t/100)),i=r%BigInt(10**12),s=r/BigInt(10**12)+BigInt(i>0?1:0);return this.evmGasPrice=s,s}async getEvmGasInfo(){var e,r,i;const t=await((i=(r=(e=this.api)==null?void 0:e.rpc)==null?void 0:r.eth)==null?void 0:i.estimateGas({to:this._contractAddress,from:this.addressToUse,data:this.transactionData,nonce:this.nonce}));return this._evmGasInfo=t,this.gasLimit=BigInt(t.toString()),t}async futurepassLogic(t,e,r){const i=this.api.tx.futurepass.proxyExtrinsic(t,this._evmCall);this._futurePassWrapped=!0,this.isEvmFuturePass=!0,this._extrinsicToSend=i;const s=await this.getPaymentInfo(i,t,e,r);return{futurePassExtrinsic:i,maxPayment:s}}async addFuturePass(t){if(!this.api)throw new Error("API is not connected");if(!this.signer)throw new Error("Signer is not connected");if(!this.walletAddress||!this.addressToUse)throw new Error("walletAddress is not connected");if(!this._evmCall)throw new Error("Base Extrinsic is not set");if(this._feeProxyWrapped)throw new Error("Cannot add FuturePass to a FeeProxy wrapped extrinsic, please add FuturePass before FeeProxy");if(this._futurePassWrapped)throw new Error("FuturePass already added");const{futurePassExtrinsic:e,maxPayment:r}=await this.futurepassLogic(t,2,0);await this.getEvmGasInfo();const i=await this.getEthGasPrice();this.setGasFee((i+r).toString()),await this.setGasInfo((i+r).toString()),this._extrinsicToSend=e,this.futurePassEvmCall=e;const{ethPayload:s,trnPayload:n}=await this.generateExtrinsicPayloads(e.method);return this._ethPayload=s,this._trnPayload=n,this}async addFeeProxy({assetId:t,slippage:e}){var u,E;if(!this.api)throw new Error("API is not connected");if(!this.signer)throw new Error("Signer is not connected");if(!this.walletAddress||!this.addressToUse)throw new Error("walletAddress is not connected");if(!this._evmCall)throw new Error("Base Extrinsic is not set");if(this._feeProxyWrapped)throw new Error("FeeProxy already added");const r=this.isEvmFuturePass?this.futurePassEvmCall:this._evmCall;if(!r)throw new Error("Extrinsic not set");this._gasToken=t;let i=BigInt(0);if(this._xamanWrapped){const m=await this.getXamanCall(r).paymentInfo(this.walletAddress);i=BigInt(m.partialFee.toString())}const n=await this.api.tx.feeProxy.callWithFeePreferences(t??0,0,r).paymentInfo(this.addressToUse),a=BigInt(n.partialFee.toString())+this.evmGasPrice+i,o=await this.getAmountsIn(a.toString(),t,e),h=(E=(u=this.api.tx.feeProxy)==null?void 0:u.callWithFeePreferences)==null?void 0:E.call(u,t??0,o==null?void 0:o.toString(),r);this.setGasFee(o.toString()),await this.setGasInfo(o.toString()),this._feeProxyWrapped=!0,this._extrinsicToSend=h;const{ethPayload:l,trnPayload:c}=await this.generateExtrinsicPayloads(h.method);return this._ethPayload=l,this._trnPayload=c,this}}class R extends f{constructor(t,e,r){super(t,e,r)}async exists(){return!0}static nft(t,e,r,i){return new q(t,e,r,i)}static sft(t,e,r,i){return new T(t,e,r,i)}static asset(t,e,r,i){return new F(t,e,r,i)}static crowdsale(t,e,r,i){return new v(t,e,r,i)}static custom(t,e,r){return new C(t,e,r)}static batch(t,e,r){return new S(t,e,r)}static remark(t,e,r){return new D(t,e,r)}static evm(t,e,r,i){return new G(t,e,r,i)}}exports.AssetBuilder=F;exports.BatchBuilder=S;exports.CrowdsaleBuilder=v;exports.CustomExtrinsicBuilder=C;exports.EvmBuilder=G;exports.NftBuilder=q;exports.RemarkBuilder=D;exports.RootQueryBuilder=_;exports.RootTransactionBuilder=f;exports.SftBuilder=T;exports.TOKEN_DECIMALS=b;exports.TOKEN_NAME=A;exports.TransactionBuilder=R;exports.XRP_ASSET_ID=B;
