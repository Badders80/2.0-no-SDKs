import { ApiPromise } from '@polkadot/api';
import { Abi } from 'viem';
export type IGetBalance = {
    assetId: number;
    walletAddress: string;
    balance: string;
    decimals: number;
};
export type IGetBalances = Array<IGetBalance>;
/**
 * The RootQueryBuilder class provides methods to query the Root Network
 *
 * @param api - the trnApi to use for interaction
 * @param walletAddress - the wallet address to use for queries - should be the EOA address for the signer, not the FuturePass address
 * @returns a RootQueryBuilder instance
 */
export declare class RootQueryBuilder {
    readonly api: ApiPromise;
    readonly walletAddress: string;
    constructor(api: ApiPromise, walletAddress: string);
    /**
     * Gets the FuturePass for the wallet address
     *
     * @param walletAddress - the wallet address to get the FuturePass for
     * @returns the FuturePass for the wallet address
     * @throws an error if the API is not connected or if the wallet address is not provided
     */
    getFuturePass(walletAddress: string): Promise<string>;
    /**
     * Gets the balance of an asset
     * Wallet address is optional, if not provided, the wallet address of the instance will be used
     *
     * @param walletAddress - (optional) the wallet address to get the balance for
     * @param assetId - the asset ID to get the balance for
     * @returns the balance of the asset
     *
     */
    checkBalance({ walletAddress, assetId, }: {
        walletAddress?: string;
        assetId: number;
    }): Promise<IGetBalance>;
    /**
     * Checks the balances of multiple assets for given wallet addresses
     * Wallet address is optional, if not provided, the wallet address of the instance will be used
     *
     * @param walletAddressAssetIds - the [walletAddresses, assetId] pair to check balances for
     * @returns the balances of the assets
     * @throws an error if the API is not connected or if the wallet address and asset IDs are not provided
     */
    checkBalances(walletAddressAssetIds: {
        walletAddress?: string;
        assetId: number;
    }[]): Promise<IGetBalances>;
    /**
     * Gets the amounts in for the given amount and asset ID
     * Slippage is optional, if not provided, a default of 5% will be used
     *
     * @param amount - the amount to get the amounts in for
     * @param assetId - the asset ID to get the amounts in for
     * @param slippage - (optional) the slippage to use for the amounts in
     * @returns the amounts in for the given amount and asset ID
     */
    getAmountsIn(amount: string, assetId: number, slippage?: number): Promise<bigint>;
    /**
     * Reads a contract function and returns the decoded result
     *
     * @param contractAddress - the contract address to read from
     * @param abi - the ABI of the contract
     * @param functionName - the function name to read
     * @param args - the arguments to pass to the function
     * @returns the decoded result of the contract function
     */
    readContract<T>({ contractAddress, abi, functionName, args, }: {
        contractAddress: string;
        abi: Abi;
        functionName: string;
        args?: never[] | undefined;
    }): Promise<T>;
}
