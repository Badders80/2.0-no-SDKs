import { ApiPromise } from '@polkadot/api';
import { Signer } from '@futureverse/signer';
import { RootTransactionBuilder } from './base';
import { SeedPrimitivesSignatureAccountId20 } from '@polkadot/types/lookup';
import { Permill } from '@polkadot/types/interfaces';
import { Vec } from '@polkadot/types';
import { ITuple } from '@polkadot/types/types';
/**
 * The NftBuilder class provides methods to build transactions for NFT pallet
 *
 * @param api - the trnApi to use for interaction
 * @param signer - the signer to use for signing transactions
 * @param walletAddressAddress - the wallet address to use for interaction - should be the EOA address for the signer, not the FuturePass address
 * @param collectionId - optional - the collection ID to use for interaction
 * @returns an NftBuilder instance
 */
export declare class NftBuilder extends RootTransactionBuilder {
    private _collectionId;
    constructor(api: ApiPromise, signer: Signer, walletAddress: string, collectionId?: number);
    /**
     * Checks if an NFT Collection exists
     *
     * @param api - the API to use for queries
     * @param collectionId - the collection ID to check for
     * @returns  true if the collection exists, false otherwise
     */
    static nftExists(api: ApiPromise, collectionId: number): Promise<boolean>;
    /**
     * Checks if an NFT exists
     *
     * @returns true if the NFT exists, false otherwise
     */
    protected exists(): Promise<boolean>;
    /**
     * Resets the NftBuilder instance
     *
     * @param collectionId - optional - the collection ID to reset the instance with
     * @returns the NftBuilder instance
     */
    reset(collectionId?: number): this;
    /**
     * Mints NFTs with the given quantity to the given wallet address
     *
     * @param quantity - the number of NFTs to mint
     * @param walletAddress - the wallet address to mint the NFTs to
     * @returns the NftBuilder instance
     */
    mint({ quantity, walletAddress, }: {
        quantity: number;
        walletAddress: string;
    }): NftBuilder;
    /**
     * Transfers NFTs with the given serial numbers
     *
     * @param serialNumbers - the serial numbers of the NFTs to transfer
     * @param walletAddress - the walletAddress to transfer the NFTs to
     * @returns the NftBuilder instance
     */
    transfer({ serialNumbers, walletAddress, }: {
        serialNumbers: number[];
        walletAddress: string;
    }): NftBuilder;
    /**
     * Burns an NFT with the given serial number
     *
     * @param serialNumber - the serial number of the NFT to burn
     * @returns the NftBuilder instance
     */
    burn({ serialNumber }: {
        serialNumber: number;
    }): NftBuilder;
    /**
     * Set the collection ID
     *
     * @param collectionId - the collection ID to set
     * @returns the NftBuilder instance
     */
    setCollectionId(collectionId: number): NftBuilder;
    /**
     * Create a new NFT Collection
     *
     * @param name - the name of the collection
     * @param initialIssuance - (optional) - the initial issuance of the collection
     * @param maxIssuance - the maximum issuance of the collection
     * @param tokenOwner - the owner of the tokens initially minted
     * @param metadataUri - the metadata URI of the collection
     * @param royalties - the royalties of the collection
     * @param crossChain - the cross chain compatibility of the collection
     * @returns the NftBuilder instance
     */
    createCollection({ name, initialIssuance, maxIssuance, tokenOwner, metadataUri, royalties, crossChain, }: {
        name: string;
        initialIssuance?: number | bigint | string | null;
        maxIssuance?: number | bigint | string | null;
        tokenOwner?: string | null;
        metadataUri: string;
        royalties?: null | Vec<ITuple<[SeedPrimitivesSignatureAccountId20, Permill]>> | Array<[SeedPrimitivesSignatureAccountId20, Permill | number]>;
        crossChain?: null | boolean;
    }): NftBuilder;
    /**
     * Update the metadata URI of the collection
     *
     * @param uri - the metadata URI to update to
     * @returns the NftBuilder instance
     */
    updateMetadataUri(uri: string): NftBuilder;
    /**
     * Update the royalties of the collection
     *
     * @param royalties - the royalties to update to
     * @returns the NftBuilder instance
     */
    updateRoyalties({ royalties, }: {
        royalties: Vec<ITuple<[SeedPrimitivesSignatureAccountId20, Permill]>>;
    }): NftBuilder;
    /**
     * Update the max issuance of the collection
     *
     * @param maxIssuance - the max issuance to update to
     * @returns the NftBuilder instance
     */
    updateMaxIssuance(maxIssuance: number | bigint | string): NftBuilder;
    /**
     * Transfer ownership of the collection
     *
     * @param newOwner - the new owner to update to
     * @returns the NftBuilder instance
     */
    transferCollection(newOwner: string): NftBuilder;
    /**
     * Update the mint fee of the collection
     *
     * @param assetId - the token to update the mint fee for
     * @param price - the price to update to - can be a number, bigint or string but must be a valid number including decimals.
     * For example, if you are setting the mint fee to `1.3` Tokens with a precision of 6 decimals, you should pass in `1300000` as the price.
     * @returns the NftBuilder instance
     */
    setPrice({ assetId, price, }?: {
        assetId?: number | bigint;
        price?: number | bigint | string;
    }): Promise<NftBuilder>;
    /**
     * Toggle public minting on or off
     *
     * @param publicMintEnabled - value to set public minting to
     * @returns the NftBuilder instance
     */
    togglePublicMint(publicMintEnabled: boolean): NftBuilder;
}
