{
  "version": 3,
  "sources": ["../../@walletconnect/ethereum-provider/node_modules/@noble/hashes/src/_u64.ts", "../../@walletconnect/ethereum-provider/node_modules/@noble/hashes/src/sha3.ts"],
  "sourcesContent": ["/**\r\n * Internal helpers for u64. BigUint64Array is too slow as per 2025, so we implement it using Uint32Array.\r\n * @todo re-check https://issues.chromium.org/issues/42212588\r\n * @module\r\n */\r\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\r\nconst _32n = /* @__PURE__ */ BigInt(32);\r\n\r\nfunction fromBig(\r\n  n: bigint,\r\n  le = false\r\n): {\r\n  h: number;\r\n  l: number;\r\n} {\r\n  if (le) return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\r\n  return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\r\n}\r\n\r\nfunction split(lst: bigint[], le = false): Uint32Array[] {\r\n  let Ah = new Uint32Array(lst.length);\r\n  let Al = new Uint32Array(lst.length);\r\n  for (let i = 0; i < lst.length; i++) {\r\n    const { h, l } = fromBig(lst[i], le);\r\n    [Ah[i], Al[i]] = [h, l];\r\n  }\r\n  return [Ah, Al];\r\n}\r\n\r\nconst toBig = (h: number, l: number): bigint => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\r\n// for Shift in [0, 32)\r\nconst shrSH = (h: number, _l: number, s: number): number => h >>> s;\r\nconst shrSL = (h: number, l: number, s: number): number => (h << (32 - s)) | (l >>> s);\r\n// Right rotate for Shift in [1, 32)\r\nconst rotrSH = (h: number, l: number, s: number): number => (h >>> s) | (l << (32 - s));\r\nconst rotrSL = (h: number, l: number, s: number): number => (h << (32 - s)) | (l >>> s);\r\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\r\nconst rotrBH = (h: number, l: number, s: number): number => (h << (64 - s)) | (l >>> (s - 32));\r\nconst rotrBL = (h: number, l: number, s: number): number => (h >>> (s - 32)) | (l << (64 - s));\r\n// Right rotate for shift===32 (just swaps l&h)\r\nconst rotr32H = (_h: number, l: number): number => l;\r\nconst rotr32L = (h: number, _l: number): number => h;\r\n// Left rotate for Shift in [1, 32)\r\nconst rotlSH = (h: number, l: number, s: number): number => (h << s) | (l >>> (32 - s));\r\nconst rotlSL = (h: number, l: number, s: number): number => (l << s) | (h >>> (32 - s));\r\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\r\nconst rotlBH = (h: number, l: number, s: number): number => (l << (s - 32)) | (h >>> (64 - s));\r\nconst rotlBL = (h: number, l: number, s: number): number => (h << (s - 32)) | (l >>> (64 - s));\r\n\r\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\r\n// simple take carry out of low bit sum by shift, we need to use division.\r\nfunction add(\r\n  Ah: number,\r\n  Al: number,\r\n  Bh: number,\r\n  Bl: number\r\n): {\r\n  h: number;\r\n  l: number;\r\n} {\r\n  const l = (Al >>> 0) + (Bl >>> 0);\r\n  return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\r\n}\r\n// Addition with more than 2 elements\r\nconst add3L = (Al: number, Bl: number, Cl: number): number => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\r\nconst add3H = (low: number, Ah: number, Bh: number, Ch: number): number =>\r\n  (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\r\nconst add4L = (Al: number, Bl: number, Cl: number, Dl: number): number =>\r\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\r\nconst add4H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number): number =>\r\n  (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\r\nconst add5L = (Al: number, Bl: number, Cl: number, Dl: number, El: number): number =>\r\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\r\nconst add5H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number, Eh: number): number =>\r\n  (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\r\n\r\n// prettier-ignore\r\nexport {\r\n  fromBig, split, toBig,\r\n  shrSH, shrSL,\r\n  rotrSH, rotrSL, rotrBH, rotrBL,\r\n  rotr32H, rotr32L,\r\n  rotlSH, rotlSL, rotlBH, rotlBL,\r\n  add, add3L, add3H, add4L, add4H, add5H, add5L,\r\n};\r\n// prettier-ignore\r\nconst u64: { fromBig: typeof fromBig; split: typeof split; toBig: (h: number, l: number) => bigint; shrSH: (h: number, _l: number, s: number) => number; shrSL: (h: number, l: number, s: number) => number; rotrSH: (h: number, l: number, s: number) => number; rotrSL: (h: number, l: number, s: number) => number; rotrBH: (h: number, l: number, s: number) => number; rotrBL: (h: number, l: number, s: number) => number; rotr32H: (_h: number, l: number) => number; rotr32L: (h: number, _l: number) => number; rotlSH: (h: number, l: number, s: number) => number; rotlSL: (h: number, l: number, s: number) => number; rotlBH: (h: number, l: number, s: number) => number; rotlBL: (h: number, l: number, s: number) => number; add: typeof add; add3L: (Al: number, Bl: number, Cl: number) => number; add3H: (low: number, Ah: number, Bh: number, Ch: number) => number; add4L: (Al: number, Bl: number, Cl: number, Dl: number) => number; add4H: (low: number, Ah: number, Bh: number, Ch: number, Dh: number) => number; add5H: (low: number, Ah: number, Bh: number, Ch: number, Dh: number, Eh: number) => number; add5L: (Al: number, Bl: number, Cl: number, Dl: number, El: number) => number; } = {\r\n  fromBig, split, toBig,\r\n  shrSH, shrSL,\r\n  rotrSH, rotrSL, rotrBH, rotrBL,\r\n  rotr32H, rotr32L,\r\n  rotlSH, rotlSL, rotlBH, rotlBL,\r\n  add, add3L, add3H, add4L, add4H, add5H, add5L,\r\n};\r\nexport default u64;\r\n", "/**\r\n * SHA3 (keccak) hash function, based on a new \"Sponge function\" design.\r\n * Different from older hashes, the internal state is bigger than output size.\r\n *\r\n * Check out [FIPS-202](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf),\r\n * [Website](https://keccak.team/keccak.html),\r\n * [the differences between SHA-3 and Keccak](https://crypto.stackexchange.com/questions/15727/what-are-the-key-differences-between-the-draft-sha-3-standard-and-the-keccak-sub).\r\n *\r\n * Check out `sha3-addons` module for cSHAKE, k12, and others.\r\n * @module\r\n */\r\nimport { abytes, aexists, anumber, aoutput } from './_assert.js';\r\nimport { rotlBH, rotlBL, rotlSH, rotlSL, split } from './_u64.js';\r\nimport {\r\n  byteSwap32,\r\n  Hash,\r\n  isLE,\r\n  toBytes,\r\n  u32,\r\n  wrapConstructor,\r\n  wrapXOFConstructorWithOpts,\r\n  type CHash,\r\n  type CHashXO,\r\n  type HashXOF,\r\n  type Input,\r\n} from './utils.js';\r\n\r\n// Various per round constants calculations\r\nconst SHA3_PI: number[] = [];\r\nconst SHA3_ROTL: number[] = [];\r\nconst _SHA3_IOTA: bigint[] = [];\r\nconst _0n = /* @__PURE__ */ BigInt(0);\r\nconst _1n = /* @__PURE__ */ BigInt(1);\r\nconst _2n = /* @__PURE__ */ BigInt(2);\r\nconst _7n = /* @__PURE__ */ BigInt(7);\r\nconst _256n = /* @__PURE__ */ BigInt(256);\r\nconst _0x71n = /* @__PURE__ */ BigInt(0x71);\r\nfor (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {\r\n  // Pi\r\n  [x, y] = [y, (2 * x + 3 * y) % 5];\r\n  SHA3_PI.push(2 * (5 * y + x));\r\n  // Rotational\r\n  SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);\r\n  // Iota\r\n  let t = _0n;\r\n  for (let j = 0; j < 7; j++) {\r\n    R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;\r\n    if (R & _2n) t ^= _1n << ((_1n << /* @__PURE__ */ BigInt(j)) - _1n);\r\n  }\r\n  _SHA3_IOTA.push(t);\r\n}\r\nconst [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ split(_SHA3_IOTA, true);\r\n\r\n// Left rotation (without 0, 32, 64)\r\nconst rotlH = (h: number, l: number, s: number) => (s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s));\r\nconst rotlL = (h: number, l: number, s: number) => (s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s));\r\n\r\n/** `keccakf1600` internal function, additionally allows to adjust round count. */\r\nexport function keccakP(s: Uint32Array, rounds: number = 24): void {\r\n  const B = new Uint32Array(5 * 2);\r\n  // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)\r\n  for (let round = 24 - rounds; round < 24; round++) {\r\n    // Theta θ\r\n    for (let x = 0; x < 10; x++) B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\r\n    for (let x = 0; x < 10; x += 2) {\r\n      const idx1 = (x + 8) % 10;\r\n      const idx0 = (x + 2) % 10;\r\n      const B0 = B[idx0];\r\n      const B1 = B[idx0 + 1];\r\n      const Th = rotlH(B0, B1, 1) ^ B[idx1];\r\n      const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\r\n      for (let y = 0; y < 50; y += 10) {\r\n        s[x + y] ^= Th;\r\n        s[x + y + 1] ^= Tl;\r\n      }\r\n    }\r\n    // Rho (ρ) and Pi (π)\r\n    let curH = s[2];\r\n    let curL = s[3];\r\n    for (let t = 0; t < 24; t++) {\r\n      const shift = SHA3_ROTL[t];\r\n      const Th = rotlH(curH, curL, shift);\r\n      const Tl = rotlL(curH, curL, shift);\r\n      const PI = SHA3_PI[t];\r\n      curH = s[PI];\r\n      curL = s[PI + 1];\r\n      s[PI] = Th;\r\n      s[PI + 1] = Tl;\r\n    }\r\n    // Chi (χ)\r\n    for (let y = 0; y < 50; y += 10) {\r\n      for (let x = 0; x < 10; x++) B[x] = s[y + x];\r\n      for (let x = 0; x < 10; x++) s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\r\n    }\r\n    // Iota (ι)\r\n    s[0] ^= SHA3_IOTA_H[round];\r\n    s[1] ^= SHA3_IOTA_L[round];\r\n  }\r\n  B.fill(0);\r\n}\r\n\r\n/** Keccak sponge function. */\r\nexport class Keccak extends Hash<Keccak> implements HashXOF<Keccak> {\r\n  protected state: Uint8Array;\r\n  protected pos = 0;\r\n  protected posOut = 0;\r\n  protected finished = false;\r\n  protected state32: Uint32Array;\r\n  protected destroyed = false;\r\n  // NOTE: we accept arguments in bytes instead of bits here.\r\n  constructor(\r\n    public blockLen: number,\r\n    public suffix: number,\r\n    public outputLen: number,\r\n    protected enableXOF = false,\r\n    protected rounds: number = 24\r\n  ) {\r\n    super();\r\n    // Can be passed from user as dkLen\r\n    anumber(outputLen);\r\n    // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes\r\n    // 0 < blockLen < 200\r\n    if (0 >= this.blockLen || this.blockLen >= 200)\r\n      throw new Error('Sha3 supports only keccak-f1600 function');\r\n    this.state = new Uint8Array(200);\r\n    this.state32 = u32(this.state);\r\n  }\r\n  protected keccak(): void {\r\n    if (!isLE) byteSwap32(this.state32);\r\n    keccakP(this.state32, this.rounds);\r\n    if (!isLE) byteSwap32(this.state32);\r\n    this.posOut = 0;\r\n    this.pos = 0;\r\n  }\r\n  update(data: Input): this {\r\n    aexists(this);\r\n    const { blockLen, state } = this;\r\n    data = toBytes(data);\r\n    const len = data.length;\r\n    for (let pos = 0; pos < len; ) {\r\n      const take = Math.min(blockLen - this.pos, len - pos);\r\n      for (let i = 0; i < take; i++) state[this.pos++] ^= data[pos++];\r\n      if (this.pos === blockLen) this.keccak();\r\n    }\r\n    return this;\r\n  }\r\n  protected finish(): void {\r\n    if (this.finished) return;\r\n    this.finished = true;\r\n    const { state, suffix, pos, blockLen } = this;\r\n    // Do the padding\r\n    state[pos] ^= suffix;\r\n    if ((suffix & 0x80) !== 0 && pos === blockLen - 1) this.keccak();\r\n    state[blockLen - 1] ^= 0x80;\r\n    this.keccak();\r\n  }\r\n  protected writeInto(out: Uint8Array): Uint8Array {\r\n    aexists(this, false);\r\n    abytes(out);\r\n    this.finish();\r\n    const bufferOut = this.state;\r\n    const { blockLen } = this;\r\n    for (let pos = 0, len = out.length; pos < len; ) {\r\n      if (this.posOut >= blockLen) this.keccak();\r\n      const take = Math.min(blockLen - this.posOut, len - pos);\r\n      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\r\n      this.posOut += take;\r\n      pos += take;\r\n    }\r\n    return out;\r\n  }\r\n  xofInto(out: Uint8Array): Uint8Array {\r\n    // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF\r\n    if (!this.enableXOF) throw new Error('XOF is not possible for this instance');\r\n    return this.writeInto(out);\r\n  }\r\n  xof(bytes: number): Uint8Array {\r\n    anumber(bytes);\r\n    return this.xofInto(new Uint8Array(bytes));\r\n  }\r\n  digestInto(out: Uint8Array): Uint8Array {\r\n    aoutput(out, this);\r\n    if (this.finished) throw new Error('digest() was already called');\r\n    this.writeInto(out);\r\n    this.destroy();\r\n    return out;\r\n  }\r\n  digest(): Uint8Array {\r\n    return this.digestInto(new Uint8Array(this.outputLen));\r\n  }\r\n  destroy(): void {\r\n    this.destroyed = true;\r\n    this.state.fill(0);\r\n  }\r\n  _cloneInto(to?: Keccak): Keccak {\r\n    const { blockLen, suffix, outputLen, rounds, enableXOF } = this;\r\n    to ||= new Keccak(blockLen, suffix, outputLen, enableXOF, rounds);\r\n    to.state32.set(this.state32);\r\n    to.pos = this.pos;\r\n    to.posOut = this.posOut;\r\n    to.finished = this.finished;\r\n    to.rounds = rounds;\r\n    // Suffix can change in cSHAKE\r\n    to.suffix = suffix;\r\n    to.outputLen = outputLen;\r\n    to.enableXOF = enableXOF;\r\n    to.destroyed = this.destroyed;\r\n    return to;\r\n  }\r\n}\r\n\r\nconst gen = (suffix: number, blockLen: number, outputLen: number) =>\r\n  wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));\r\n\r\n/** SHA3-224 hash function. */\r\nexport const sha3_224: CHash = /* @__PURE__ */ gen(0x06, 144, 224 / 8);\r\n/** SHA3-256 hash function. Different from keccak-256. */\r\nexport const sha3_256: CHash = /* @__PURE__ */ gen(0x06, 136, 256 / 8);\r\n/** SHA3-384 hash function. */\r\nexport const sha3_384: CHash = /* @__PURE__ */ gen(0x06, 104, 384 / 8);\r\n/** SHA3-512 hash function. */\r\nexport const sha3_512: CHash = /* @__PURE__ */ gen(0x06, 72, 512 / 8);\r\n\r\n/** keccak-224 hash function. */\r\nexport const keccak_224: CHash = /* @__PURE__ */ gen(0x01, 144, 224 / 8);\r\n/** keccak-256 hash function. Different from SHA3-256. */\r\nexport const keccak_256: CHash = /* @__PURE__ */ gen(0x01, 136, 256 / 8);\r\n/** keccak-384 hash function. */\r\nexport const keccak_384: CHash = /* @__PURE__ */ gen(0x01, 104, 384 / 8);\r\n/** keccak-512 hash function. */\r\nexport const keccak_512: CHash = /* @__PURE__ */ gen(0x01, 72, 512 / 8);\r\n\r\nexport type ShakeOpts = { dkLen?: number };\r\n\r\nconst genShake = (suffix: number, blockLen: number, outputLen: number) =>\r\n  wrapXOFConstructorWithOpts<HashXOF<Keccak>, ShakeOpts>(\r\n    (opts: ShakeOpts = {}) =>\r\n      new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true)\r\n  );\r\n\r\n/** SHAKE128 XOF with 128-bit security. */\r\nexport const shake128: CHashXO = /* @__PURE__ */ genShake(0x1f, 168, 128 / 8);\r\n/** SHAKE256 XOF with 256-bit security. */\r\nexport const shake256: CHashXO = /* @__PURE__ */ genShake(0x1f, 136, 256 / 8);\r\n"],
  "mappings": "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",
  "names": []
}
