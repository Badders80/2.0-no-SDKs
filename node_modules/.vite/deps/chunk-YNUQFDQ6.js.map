{
  "version": 3,
  "sources": ["../../viem/node_modules/@noble/hashes/src/hmac.ts", "../../viem/node_modules/@noble/curves/src/abstract/modular.ts", "../../viem/node_modules/@noble/curves/src/abstract/curve.ts", "../../viem/node_modules/@noble/curves/src/abstract/weierstrass.ts", "../../viem/node_modules/@noble/curves/src/_shortw_utils.ts", "../../viem/node_modules/@noble/curves/src/abstract/hash-to-curve.ts", "../../viem/node_modules/@noble/curves/src/secp256k1.ts"],
  "sourcesContent": ["/**\r\n * HMAC: RFC2104 message authentication code.\r\n * @module\r\n */\r\nimport { abytes, aexists, ahash, clean, Hash, toBytes, type CHash, type Input } from './utils.ts';\r\n\r\nexport class HMAC<T extends Hash<T>> extends Hash<HMAC<T>> {\r\n  oHash: T;\r\n  iHash: T;\r\n  blockLen: number;\r\n  outputLen: number;\r\n  private finished = false;\r\n  private destroyed = false;\r\n\r\n  constructor(hash: CHash, _key: Input) {\r\n    super();\r\n    ahash(hash);\r\n    const key = toBytes(_key);\r\n    this.iHash = hash.create() as T;\r\n    if (typeof this.iHash.update !== 'function')\r\n      throw new Error('Expected instance of class which extends utils.Hash');\r\n    this.blockLen = this.iHash.blockLen;\r\n    this.outputLen = this.iHash.outputLen;\r\n    const blockLen = this.blockLen;\r\n    const pad = new Uint8Array(blockLen);\r\n    // blockLen can be bigger than outputLen\r\n    pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\r\n    for (let i = 0; i < pad.length; i++) pad[i] ^= 0x36;\r\n    this.iHash.update(pad);\r\n    // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\r\n    this.oHash = hash.create() as T;\r\n    // Undo internal XOR && apply outer XOR\r\n    for (let i = 0; i < pad.length; i++) pad[i] ^= 0x36 ^ 0x5c;\r\n    this.oHash.update(pad);\r\n    clean(pad);\r\n  }\r\n  update(buf: Input): this {\r\n    aexists(this);\r\n    this.iHash.update(buf);\r\n    return this;\r\n  }\r\n  digestInto(out: Uint8Array): void {\r\n    aexists(this);\r\n    abytes(out, this.outputLen);\r\n    this.finished = true;\r\n    this.iHash.digestInto(out);\r\n    this.oHash.update(out);\r\n    this.oHash.digestInto(out);\r\n    this.destroy();\r\n  }\r\n  digest(): Uint8Array {\r\n    const out = new Uint8Array(this.oHash.outputLen);\r\n    this.digestInto(out);\r\n    return out;\r\n  }\r\n  _cloneInto(to?: HMAC<T>): HMAC<T> {\r\n    // Create new instance without calling constructor since key already in state and we don't know it.\r\n    to ||= Object.create(Object.getPrototypeOf(this), {});\r\n    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\r\n    to = to as this;\r\n    to.finished = finished;\r\n    to.destroyed = destroyed;\r\n    to.blockLen = blockLen;\r\n    to.outputLen = outputLen;\r\n    to.oHash = oHash._cloneInto(to.oHash);\r\n    to.iHash = iHash._cloneInto(to.iHash);\r\n    return to;\r\n  }\r\n  clone(): HMAC<T> {\r\n    return this._cloneInto();\r\n  }\r\n  destroy(): void {\r\n    this.destroyed = true;\r\n    this.oHash.destroy();\r\n    this.iHash.destroy();\r\n  }\r\n}\r\n\r\n/**\r\n * HMAC: RFC2104 message authentication code.\r\n * @param hash - function that would be used e.g. sha256\r\n * @param key - message key\r\n * @param message - message data\r\n * @example\r\n * import { hmac } from '@noble/hashes/hmac';\r\n * import { sha256 } from '@noble/hashes/sha2';\r\n * const mac1 = hmac(sha256, 'key', 'message');\r\n */\r\nexport const hmac: {\r\n  (hash: CHash, key: Input, message: Input): Uint8Array;\r\n  create(hash: CHash, key: Input): HMAC<any>;\r\n} = (hash: CHash, key: Input, message: Input): Uint8Array =>\r\n  new HMAC<any>(hash, key).update(message).digest();\r\nhmac.create = (hash: CHash, key: Input) => new HMAC<any>(hash, key);\r\n", "/**\r\n * Utils for modular division and fields.\r\n * Field over 11 is a finite (Galois) field is integer number operations `mod 11`.\r\n * There is no division: it is replaced by modular multiplicative inverse.\r\n * @module\r\n */\r\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\r\nimport {\r\n  _validateObject,\r\n  anumber,\r\n  bitMask,\r\n  bytesToNumberBE,\r\n  bytesToNumberLE,\r\n  ensureBytes,\r\n  numberToBytesBE,\r\n  numberToBytesLE,\r\n} from '../utils.ts';\r\n\r\n// prettier-ignore\r\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = /* @__PURE__ */ BigInt(2), _3n = /* @__PURE__ */ BigInt(3);\r\n// prettier-ignore\r\nconst _4n = /* @__PURE__ */ BigInt(4), _5n = /* @__PURE__ */ BigInt(5);\r\nconst _8n = /* @__PURE__ */ BigInt(8);\r\n\r\n// Calculates a modulo b\r\nexport function mod(a: bigint, b: bigint): bigint {\r\n  const result = a % b;\r\n  return result >= _0n ? result : b + result;\r\n}\r\n/**\r\n * Efficiently raise num to power and do modular division.\r\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\r\n * @example\r\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\r\n */\r\nexport function pow(num: bigint, power: bigint, modulo: bigint): bigint {\r\n  return FpPow(Field(modulo), num, power);\r\n}\r\n\r\n/** Does `x^(2^power)` mod p. `pow2(30, 4)` == `30^(2^4)` */\r\nexport function pow2(x: bigint, power: bigint, modulo: bigint): bigint {\r\n  let res = x;\r\n  while (power-- > _0n) {\r\n    res *= res;\r\n    res %= modulo;\r\n  }\r\n  return res;\r\n}\r\n\r\n/**\r\n * Inverses number over modulo.\r\n * Implemented using [Euclidean GCD](https://brilliant.org/wiki/extended-euclidean-algorithm/).\r\n */\r\nexport function invert(number: bigint, modulo: bigint): bigint {\r\n  if (number === _0n) throw new Error('invert: expected non-zero number');\r\n  if (modulo <= _0n) throw new Error('invert: expected positive modulus, got ' + modulo);\r\n  // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\r\n  let a = mod(number, modulo);\r\n  let b = modulo;\r\n  // prettier-ignore\r\n  let x = _0n, y = _1n, u = _1n, v = _0n;\r\n  while (a !== _0n) {\r\n    // JIT applies optimization if those two lines follow each other\r\n    const q = b / a;\r\n    const r = b % a;\r\n    const m = x - u * q;\r\n    const n = y - v * q;\r\n    // prettier-ignore\r\n    b = a, a = r, x = u, y = v, u = m, v = n;\r\n  }\r\n  const gcd = b;\r\n  if (gcd !== _1n) throw new Error('invert: does not exist');\r\n  return mod(x, modulo);\r\n}\r\n\r\n// Not all roots are possible! Example which will throw:\r\n// const NUM =\r\n// n = 72057594037927816n;\r\n// Fp = Field(BigInt('0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab'));\r\nfunction sqrt3mod4<T>(Fp: IField<T>, n: T) {\r\n  const p1div4 = (Fp.ORDER + _1n) / _4n;\r\n  const root = Fp.pow(n, p1div4);\r\n  // Throw if root^2 != n\r\n  if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');\r\n  return root;\r\n}\r\n\r\nfunction sqrt5mod8<T>(Fp: IField<T>, n: T) {\r\n  const p5div8 = (Fp.ORDER - _5n) / _8n;\r\n  const n2 = Fp.mul(n, _2n);\r\n  const v = Fp.pow(n2, p5div8);\r\n  const nv = Fp.mul(n, v);\r\n  const i = Fp.mul(Fp.mul(nv, _2n), v);\r\n  const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\r\n  if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');\r\n  return root;\r\n}\r\n\r\n// TODO: Commented-out for now. Provide test vectors.\r\n// Tonelli is too slow for extension fields Fp2.\r\n// That means we can't use sqrt (c1, c2...) even for initialization constants.\r\n// if (P % _16n === _9n) return sqrt9mod16;\r\n// // prettier-ignore\r\n// function sqrt9mod16<T>(Fp: IField<T>, n: T, p7div16?: bigint) {\r\n//   if (p7div16 === undefined) p7div16 = (Fp.ORDER + BigInt(7)) / _16n;\r\n//   const c1 = Fp.sqrt(Fp.neg(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\r\n//   const c2 = Fp.sqrt(c1);             //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\r\n//   const c3 = Fp.sqrt(Fp.neg(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\r\n//   const c4 = p7div16;                 //  4. c4 = (q + 7) / 16        # Integer arithmetic\r\n//   let tv1 = Fp.pow(n, c4);            //  1. tv1 = x^c4\r\n//   let tv2 = Fp.mul(c1, tv1);          //  2. tv2 = c1 * tv1\r\n//   const tv3 = Fp.mul(c2, tv1);        //  3. tv3 = c2 * tv1\r\n//   let tv4 = Fp.mul(c3, tv1);          //  4. tv4 = c3 * tv1\r\n//   const e1 = Fp.eql(Fp.sqr(tv2), n);  //  5.  e1 = (tv2^2) == x\r\n//   const e2 = Fp.eql(Fp.sqr(tv3), n);  //  6.  e2 = (tv3^2) == x\r\n//   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\r\n//   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\r\n//   const e3 = Fp.eql(Fp.sqr(tv2), n);  //  9.  e3 = (tv2^2) == x\r\n//   return Fp.cmov(tv1, tv2, e3); // 10.  z = CMOV(tv1, tv2, e3) # Select the sqrt from tv1 and tv2\r\n// }\r\n\r\n/**\r\n * Tonelli-Shanks square root search algorithm.\r\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\r\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\r\n * @param P field order\r\n * @returns function that takes field Fp (created from P) and number n\r\n */\r\nexport function tonelliShanks(P: bigint): <T>(Fp: IField<T>, n: T) => T {\r\n  // Initialization (precomputation).\r\n  // Caching initialization could boost perf by 7%.\r\n  if (P < BigInt(3)) throw new Error('sqrt is not defined for small field');\r\n  // Factor P - 1 = Q * 2^S, where Q is odd\r\n  let Q = P - _1n;\r\n  let S = 0;\r\n  while (Q % _2n === _0n) {\r\n    Q /= _2n;\r\n    S++;\r\n  }\r\n\r\n  // Find the first quadratic non-residue Z >= 2\r\n  let Z = _2n;\r\n  const _Fp = Field(P);\r\n  while (FpLegendre(_Fp, Z) === 1) {\r\n    // Basic primality test for P. After x iterations, chance of\r\n    // not finding quadratic non-residue is 2^x, so 2^1000.\r\n    if (Z++ > 1000) throw new Error('Cannot find square root: probably non-prime P');\r\n  }\r\n  // Fast-path; usually done before Z, but we do \"primality test\".\r\n  if (S === 1) return sqrt3mod4;\r\n\r\n  // Slow-path\r\n  // TODO: test on Fp2 and others\r\n  let cc = _Fp.pow(Z, Q); // c = z^Q\r\n  const Q1div2 = (Q + _1n) / _2n;\r\n  return function tonelliSlow<T>(Fp: IField<T>, n: T): T {\r\n    if (Fp.is0(n)) return n;\r\n    // Check if n is a quadratic residue using Legendre symbol\r\n    if (FpLegendre(Fp, n) !== 1) throw new Error('Cannot find square root');\r\n\r\n    // Initialize variables for the main loop\r\n    let M = S;\r\n    let c = Fp.mul(Fp.ONE, cc); // c = z^Q, move cc from field _Fp into field Fp\r\n    let t = Fp.pow(n, Q); // t = n^Q, first guess at the fudge factor\r\n    let R = Fp.pow(n, Q1div2); // R = n^((Q+1)/2), first guess at the square root\r\n\r\n    // Main loop\r\n    // while t != 1\r\n    while (!Fp.eql(t, Fp.ONE)) {\r\n      if (Fp.is0(t)) return Fp.ZERO; // if t=0 return R=0\r\n      let i = 1;\r\n\r\n      // Find the smallest i >= 1 such that t^(2^i) ‚â° 1 (mod P)\r\n      let t_tmp = Fp.sqr(t); // t^(2^1)\r\n      while (!Fp.eql(t_tmp, Fp.ONE)) {\r\n        i++;\r\n        t_tmp = Fp.sqr(t_tmp); // t^(2^2)...\r\n        if (i === M) throw new Error('Cannot find square root');\r\n      }\r\n\r\n      // Calculate the exponent for b: 2^(M - i - 1)\r\n      const exponent = _1n << BigInt(M - i - 1); // bigint is important\r\n      const b = Fp.pow(c, exponent); // b = 2^(M - i - 1)\r\n\r\n      // Update variables\r\n      M = i;\r\n      c = Fp.sqr(b); // c = b^2\r\n      t = Fp.mul(t, c); // t = (t * b^2)\r\n      R = Fp.mul(R, b); // R = R*b\r\n    }\r\n    return R;\r\n  };\r\n}\r\n\r\n/**\r\n * Square root for a finite field. Will try optimized versions first:\r\n *\r\n * 1. P ‚â° 3 (mod 4)\r\n * 2. P ‚â° 5 (mod 8)\r\n * 3. Tonelli-Shanks algorithm\r\n *\r\n * Different algorithms can give different roots, it is up to user to decide which one they want.\r\n * For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\r\n */\r\nexport function FpSqrt(P: bigint): <T>(Fp: IField<T>, n: T) => T {\r\n  // P ‚â° 3 (mod 4) => ‚àön = n^((P+1)/4)\r\n  if (P % _4n === _3n) return sqrt3mod4;\r\n  // P ‚â° 5 (mod 8) => Atkin algorithm, page 10 of https://eprint.iacr.org/2012/685.pdf\r\n  if (P % _8n === _5n) return sqrt5mod8;\r\n  // P ‚â° 9 (mod 16) not implemented, see above\r\n  // Tonelli-Shanks algorithm\r\n  return tonelliShanks(P);\r\n}\r\n\r\n// Little-endian check for first LE bit (last BE bit);\r\nexport const isNegativeLE = (num: bigint, modulo: bigint): boolean =>\r\n  (mod(num, modulo) & _1n) === _1n;\r\n\r\n/** Field is not always over prime: for example, Fp2 has ORDER(q)=p^m. */\r\nexport interface IField<T> {\r\n  ORDER: bigint;\r\n  isLE: boolean;\r\n  BYTES: number;\r\n  BITS: number;\r\n  MASK: bigint;\r\n  ZERO: T;\r\n  ONE: T;\r\n  // 1-arg\r\n  create: (num: T) => T;\r\n  isValid: (num: T) => boolean;\r\n  is0: (num: T) => boolean;\r\n  isValidNot0: (num: T) => boolean;\r\n  neg(num: T): T;\r\n  inv(num: T): T;\r\n  sqrt(num: T): T;\r\n  sqr(num: T): T;\r\n  // 2-args\r\n  eql(lhs: T, rhs: T): boolean;\r\n  add(lhs: T, rhs: T): T;\r\n  sub(lhs: T, rhs: T): T;\r\n  mul(lhs: T, rhs: T | bigint): T;\r\n  pow(lhs: T, power: bigint): T;\r\n  div(lhs: T, rhs: T | bigint): T;\r\n  // N for NonNormalized (for now)\r\n  addN(lhs: T, rhs: T): T;\r\n  subN(lhs: T, rhs: T): T;\r\n  mulN(lhs: T, rhs: T | bigint): T;\r\n  sqrN(num: T): T;\r\n\r\n  // Optional\r\n  // Should be same as sgn0 function in\r\n  // [RFC9380](https://www.rfc-editor.org/rfc/rfc9380#section-4.1).\r\n  // NOTE: sgn0 is 'negative in LE', which is same as odd. And negative in LE is kinda strange definition anyway.\r\n  isOdd?(num: T): boolean; // Odd instead of even since we have it for Fp2\r\n  // legendre?(num: T): T;\r\n  invertBatch: (lst: T[]) => T[];\r\n  toBytes(num: T): Uint8Array;\r\n  fromBytes(bytes: Uint8Array): T;\r\n  // If c is False, CMOV returns a, otherwise it returns b.\r\n  cmov(a: T, b: T, c: boolean): T;\r\n}\r\n// prettier-ignore\r\nconst FIELD_FIELDS = [\r\n  'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',\r\n  'eql', 'add', 'sub', 'mul', 'pow', 'div',\r\n  'addN', 'subN', 'mulN', 'sqrN'\r\n] as const;\r\nexport function validateField<T>(field: IField<T>): IField<T> {\r\n  const initial = {\r\n    ORDER: 'bigint',\r\n    MASK: 'bigint',\r\n    BYTES: 'number',\r\n    BITS: 'number',\r\n  } as Record<string, string>;\r\n  const opts = FIELD_FIELDS.reduce((map, val: string) => {\r\n    map[val] = 'function';\r\n    return map;\r\n  }, initial);\r\n  _validateObject(field, opts);\r\n  // const max = 16384;\r\n  // if (field.BYTES < 1 || field.BYTES > max) throw new Error('invalid field');\r\n  // if (field.BITS < 1 || field.BITS > 8 * max) throw new Error('invalid field');\r\n  return field;\r\n}\r\n\r\n// Generic field functions\r\n\r\n/**\r\n * Same as `pow` but for Fp: non-constant-time.\r\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\r\n */\r\nexport function FpPow<T>(Fp: IField<T>, num: T, power: bigint): T {\r\n  if (power < _0n) throw new Error('invalid exponent, negatives unsupported');\r\n  if (power === _0n) return Fp.ONE;\r\n  if (power === _1n) return num;\r\n  let p = Fp.ONE;\r\n  let d = num;\r\n  while (power > _0n) {\r\n    if (power & _1n) p = Fp.mul(p, d);\r\n    d = Fp.sqr(d);\r\n    power >>= _1n;\r\n  }\r\n  return p;\r\n}\r\n\r\n/**\r\n * Efficiently invert an array of Field elements.\r\n * Exception-free. Will return `undefined` for 0 elements.\r\n * @param passZero map 0 to 0 (instead of undefined)\r\n */\r\nexport function FpInvertBatch<T>(Fp: IField<T>, nums: T[], passZero = false): T[] {\r\n  const inverted = new Array(nums.length).fill(passZero ? Fp.ZERO : undefined);\r\n  // Walk from first to last, multiply them by each other MOD p\r\n  const multipliedAcc = nums.reduce((acc, num, i) => {\r\n    if (Fp.is0(num)) return acc;\r\n    inverted[i] = acc;\r\n    return Fp.mul(acc, num);\r\n  }, Fp.ONE);\r\n  // Invert last element\r\n  const invertedAcc = Fp.inv(multipliedAcc);\r\n  // Walk from last to first, multiply them by inverted each other MOD p\r\n  nums.reduceRight((acc, num, i) => {\r\n    if (Fp.is0(num)) return acc;\r\n    inverted[i] = Fp.mul(acc, inverted[i]);\r\n    return Fp.mul(acc, num);\r\n  }, invertedAcc);\r\n  return inverted;\r\n}\r\n\r\n// TODO: remove\r\nexport function FpDiv<T>(Fp: IField<T>, lhs: T, rhs: T | bigint): T {\r\n  return Fp.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, Fp.ORDER) : Fp.inv(rhs));\r\n}\r\n\r\n/**\r\n * Legendre symbol.\r\n * Legendre constant is used to calculate Legendre symbol (a | p)\r\n * which denotes the value of a^((p-1)/2) (mod p).\r\n *\r\n * * (a | p) ‚â° 1    if a is a square (mod p), quadratic residue\r\n * * (a | p) ‚â° -1   if a is not a square (mod p), quadratic non residue\r\n * * (a | p) ‚â° 0    if a ‚â° 0 (mod p)\r\n */\r\nexport function FpLegendre<T>(Fp: IField<T>, n: T): -1 | 0 | 1 {\r\n  // We can use 3rd argument as optional cache of this value\r\n  // but seems unneeded for now. The operation is very fast.\r\n  const p1mod2 = (Fp.ORDER - _1n) / _2n;\r\n  const powered = Fp.pow(n, p1mod2);\r\n  const yes = Fp.eql(powered, Fp.ONE);\r\n  const zero = Fp.eql(powered, Fp.ZERO);\r\n  const no = Fp.eql(powered, Fp.neg(Fp.ONE));\r\n  if (!yes && !zero && !no) throw new Error('invalid Legendre symbol result');\r\n  return yes ? 1 : zero ? 0 : -1;\r\n}\r\n\r\n// This function returns True whenever the value x is a square in the field F.\r\nexport function FpIsSquare<T>(Fp: IField<T>, n: T): boolean {\r\n  const l = FpLegendre(Fp, n);\r\n  return l === 1;\r\n}\r\n\r\nexport type NLength = { nByteLength: number; nBitLength: number };\r\n// CURVE.n lengths\r\nexport function nLength(n: bigint, nBitLength?: number): NLength {\r\n  // Bit size, byte size of CURVE.n\r\n  if (nBitLength !== undefined) anumber(nBitLength);\r\n  const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\r\n  const nByteLength = Math.ceil(_nBitLength / 8);\r\n  return { nBitLength: _nBitLength, nByteLength };\r\n}\r\n\r\ntype FpField = IField<bigint> & Required<Pick<IField<bigint>, 'isOdd'>>;\r\ntype SqrtFn = (n: bigint) => bigint;\r\ntype FieldOpts = Partial<{ sqrt: SqrtFn; isLE: boolean; BITS: number }>;\r\n/**\r\n * Creates a finite field. Major performance optimizations:\r\n * * 1. Denormalized operations like mulN instead of mul.\r\n * * 2. Identical object shape: never add or remove keys.\r\n * * 3. `Object.freeze`.\r\n * Fragile: always run a benchmark on a change.\r\n * Security note: operations don't check 'isValid' for all elements for performance reasons,\r\n * it is caller responsibility to check this.\r\n * This is low-level code, please make sure you know what you're doing.\r\n *\r\n * Note about field properties:\r\n * * CHARACTERISTIC p = prime number, number of elements in main subgroup.\r\n * * ORDER q = similar to cofactor in curves, may be composite `q = p^m`.\r\n *\r\n * @param ORDER field order, probably prime, or could be composite\r\n * @param bitLen how many bits the field consumes\r\n * @param isLE (default: false) if encoding / decoding should be in little-endian\r\n * @param redef optional faster redefinitions of sqrt and other methods\r\n */\r\nexport function Field(\r\n  ORDER: bigint,\r\n  bitLenOrOpts?: number | FieldOpts,\r\n  isLE = false,\r\n  opts: { sqrt?: SqrtFn } = {}\r\n): Readonly<FpField> {\r\n  if (ORDER <= _0n) throw new Error('invalid field: expected ORDER > 0, got ' + ORDER);\r\n  let _nbitLength: number | undefined = undefined;\r\n  let _sqrt: SqrtFn | undefined = undefined;\r\n  if (typeof bitLenOrOpts === 'object' && bitLenOrOpts != null) {\r\n    if (opts.sqrt || isLE) throw new Error('cannot specify opts in two arguments');\r\n    const _opts = bitLenOrOpts;\r\n    if (_opts.BITS) _nbitLength = _opts.BITS;\r\n    if (_opts.sqrt) _sqrt = _opts.sqrt;\r\n    if (typeof _opts.isLE === 'boolean') isLE = _opts.isLE;\r\n  } else {\r\n    if (typeof bitLenOrOpts === 'number') _nbitLength = bitLenOrOpts;\r\n    if (opts.sqrt) _sqrt = opts.sqrt;\r\n  }\r\n  const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, _nbitLength);\r\n  if (BYTES > 2048) throw new Error('invalid field: expected ORDER of <= 2048 bytes');\r\n  let sqrtP: ReturnType<typeof FpSqrt>; // cached sqrtP\r\n  const f: Readonly<FpField> = Object.freeze({\r\n    ORDER,\r\n    isLE,\r\n    BITS,\r\n    BYTES,\r\n    MASK: bitMask(BITS),\r\n    ZERO: _0n,\r\n    ONE: _1n,\r\n    create: (num) => mod(num, ORDER),\r\n    isValid: (num) => {\r\n      if (typeof num !== 'bigint')\r\n        throw new Error('invalid field element: expected bigint, got ' + typeof num);\r\n      return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\r\n    },\r\n    is0: (num) => num === _0n,\r\n    // is valid and invertible\r\n    isValidNot0: (num: bigint) => !f.is0(num) && f.isValid(num),\r\n    isOdd: (num) => (num & _1n) === _1n,\r\n    neg: (num) => mod(-num, ORDER),\r\n    eql: (lhs, rhs) => lhs === rhs,\r\n\r\n    sqr: (num) => mod(num * num, ORDER),\r\n    add: (lhs, rhs) => mod(lhs + rhs, ORDER),\r\n    sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\r\n    mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\r\n    pow: (num, power) => FpPow(f, num, power),\r\n    div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\r\n\r\n    // Same as above, but doesn't normalize\r\n    sqrN: (num) => num * num,\r\n    addN: (lhs, rhs) => lhs + rhs,\r\n    subN: (lhs, rhs) => lhs - rhs,\r\n    mulN: (lhs, rhs) => lhs * rhs,\r\n\r\n    inv: (num) => invert(num, ORDER),\r\n    sqrt:\r\n      _sqrt ||\r\n      ((n) => {\r\n        if (!sqrtP) sqrtP = FpSqrt(ORDER);\r\n        return sqrtP(f, n);\r\n      }),\r\n    toBytes: (num) => (isLE ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES)),\r\n    fromBytes: (bytes) => {\r\n      if (bytes.length !== BYTES)\r\n        throw new Error('Field.fromBytes: expected ' + BYTES + ' bytes, got ' + bytes.length);\r\n      return isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);\r\n    },\r\n    // TODO: we don't need it here, move out to separate fn\r\n    invertBatch: (lst) => FpInvertBatch(f, lst),\r\n    // We can't move this out because Fp6, Fp12 implement it\r\n    // and it's unclear what to return in there.\r\n    cmov: (a, b, c) => (c ? b : a),\r\n  } as FpField);\r\n  return Object.freeze(f);\r\n}\r\n\r\nexport function FpSqrtOdd<T>(Fp: IField<T>, elm: T): T {\r\n  if (!Fp.isOdd) throw new Error(\"Field doesn't have isOdd\");\r\n  const root = Fp.sqrt(elm);\r\n  return Fp.isOdd(root) ? root : Fp.neg(root);\r\n}\r\n\r\nexport function FpSqrtEven<T>(Fp: IField<T>, elm: T): T {\r\n  if (!Fp.isOdd) throw new Error(\"Field doesn't have isOdd\");\r\n  const root = Fp.sqrt(elm);\r\n  return Fp.isOdd(root) ? Fp.neg(root) : root;\r\n}\r\n\r\n/**\r\n * \"Constant-time\" private key generation utility.\r\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\r\n * Which makes it slightly more biased, less secure.\r\n * @deprecated use `mapKeyToField` instead\r\n */\r\nexport function hashToPrivateScalar(\r\n  hash: string | Uint8Array,\r\n  groupOrder: bigint,\r\n  isLE = false\r\n): bigint {\r\n  hash = ensureBytes('privateHash', hash);\r\n  const hashLen = hash.length;\r\n  const minLen = nLength(groupOrder).nByteLength + 8;\r\n  if (minLen < 24 || hashLen < minLen || hashLen > 1024)\r\n    throw new Error(\r\n      'hashToPrivateScalar: expected ' + minLen + '-1024 bytes of input, got ' + hashLen\r\n    );\r\n  const num = isLE ? bytesToNumberLE(hash) : bytesToNumberBE(hash);\r\n  return mod(num, groupOrder - _1n) + _1n;\r\n}\r\n\r\n/**\r\n * Returns total number of bytes consumed by the field element.\r\n * For example, 32 bytes for usual 256-bit weierstrass curve.\r\n * @param fieldOrder number of field elements, usually CURVE.n\r\n * @returns byte length of field\r\n */\r\nexport function getFieldBytesLength(fieldOrder: bigint): number {\r\n  if (typeof fieldOrder !== 'bigint') throw new Error('field order must be bigint');\r\n  const bitLength = fieldOrder.toString(2).length;\r\n  return Math.ceil(bitLength / 8);\r\n}\r\n\r\n/**\r\n * Returns minimal amount of bytes that can be safely reduced\r\n * by field order.\r\n * Should be 2^-128 for 128-bit curve such as P256.\r\n * @param fieldOrder number of field elements, usually CURVE.n\r\n * @returns byte length of target hash\r\n */\r\nexport function getMinHashLength(fieldOrder: bigint): number {\r\n  const length = getFieldBytesLength(fieldOrder);\r\n  return length + Math.ceil(length / 2);\r\n}\r\n\r\n/**\r\n * \"Constant-time\" private key generation utility.\r\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\r\n * and convert them into private scalar, with the modulo bias being negligible.\r\n * Needs at least 48 bytes of input for 32-byte private key.\r\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\r\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\r\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\r\n * @param hash hash output from SHA3 or a similar function\r\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\r\n * @param isLE interpret hash bytes as LE num\r\n * @returns valid private scalar\r\n */\r\nexport function mapHashToField(key: Uint8Array, fieldOrder: bigint, isLE = false): Uint8Array {\r\n  const len = key.length;\r\n  const fieldLen = getFieldBytesLength(fieldOrder);\r\n  const minLen = getMinHashLength(fieldOrder);\r\n  // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\r\n  if (len < 16 || len < minLen || len > 1024)\r\n    throw new Error('expected ' + minLen + '-1024 bytes of input, got ' + len);\r\n  const num = isLE ? bytesToNumberLE(key) : bytesToNumberBE(key);\r\n  // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\r\n  const reduced = mod(num, fieldOrder - _1n) + _1n;\r\n  return isLE ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);\r\n}\r\n", "/**\r\n * Methods for elliptic curve multiplication by scalars.\r\n * Contains wNAF, pippenger\r\n * @module\r\n */\r\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\r\nimport { bitLen, bitMask, validateObject } from '../utils.ts';\r\nimport { Field, FpInvertBatch, type IField, nLength, validateField } from './modular.ts';\r\n\r\nconst _0n = BigInt(0);\r\nconst _1n = BigInt(1);\r\n\r\nexport type AffinePoint<T> = {\r\n  x: T;\r\n  y: T;\r\n} & { z?: never; t?: never };\r\n\r\nexport interface Group<T extends Group<T>> {\r\n  double(): T;\r\n  negate(): T;\r\n  add(other: T): T;\r\n  subtract(other: T): T;\r\n  equals(other: T): boolean;\r\n  multiply(scalar: bigint): T;\r\n  toAffine?(invertedZ?: any): AffinePoint<any>;\r\n}\r\n\r\nexport type GroupConstructor<T> = {\r\n  BASE: T;\r\n  ZERO: T;\r\n};\r\nexport type ExtendedGroupConstructor<T> = GroupConstructor<T> & {\r\n  Fp: IField<any>;\r\n  Fn: IField<bigint>;\r\n  fromAffine(ap: AffinePoint<any>): T;\r\n};\r\nexport type Mapper<T> = (i: T[]) => T[];\r\n\r\nexport function negateCt<T extends Group<T>>(condition: boolean, item: T): T {\r\n  const neg = item.negate();\r\n  return condition ? neg : item;\r\n}\r\n\r\n/**\r\n * Takes a bunch of Projective Points but executes only one\r\n * inversion on all of them. Inversion is very slow operation,\r\n * so this improves performance massively.\r\n * Optimization: converts a list of projective points to a list of identical points with Z=1.\r\n */\r\nexport function normalizeZ<T>(\r\n  c: ExtendedGroupConstructor<T>,\r\n  property: 'pz' | 'ez',\r\n  points: T[]\r\n): T[] {\r\n  const getz = property === 'pz' ? (p: any) => p.pz : (p: any) => p.ez;\r\n  const toInv = FpInvertBatch(c.Fp, points.map(getz));\r\n  // @ts-ignore\r\n  const affined = points.map((p, i) => p.toAffine(toInv[i]));\r\n  return affined.map(c.fromAffine);\r\n}\r\n\r\nfunction validateW(W: number, bits: number) {\r\n  if (!Number.isSafeInteger(W) || W <= 0 || W > bits)\r\n    throw new Error('invalid window size, expected [1..' + bits + '], got W=' + W);\r\n}\r\n\r\n/** Internal wNAF opts for specific W and scalarBits */\r\nexport type WOpts = {\r\n  windows: number;\r\n  windowSize: number;\r\n  mask: bigint;\r\n  maxNumber: number;\r\n  shiftBy: bigint;\r\n};\r\n\r\nfunction calcWOpts(W: number, scalarBits: number): WOpts {\r\n  validateW(W, scalarBits);\r\n  const windows = Math.ceil(scalarBits / W) + 1; // W=8 33. Not 32, because we skip zero\r\n  const windowSize = 2 ** (W - 1); // W=8 128. Not 256, because we skip zero\r\n  const maxNumber = 2 ** W; // W=8 256\r\n  const mask = bitMask(W); // W=8 255 == mask 0b11111111\r\n  const shiftBy = BigInt(W); // W=8 8\r\n  return { windows, windowSize, mask, maxNumber, shiftBy };\r\n}\r\n\r\nfunction calcOffsets(n: bigint, window: number, wOpts: WOpts) {\r\n  const { windowSize, mask, maxNumber, shiftBy } = wOpts;\r\n  let wbits = Number(n & mask); // extract W bits.\r\n  let nextN = n >> shiftBy; // shift number by W bits.\r\n\r\n  // What actually happens here:\r\n  // const highestBit = Number(mask ^ (mask >> 1n));\r\n  // let wbits2 = wbits - 1; // skip zero\r\n  // if (wbits2 & highestBit) { wbits2 ^= Number(mask); // (~);\r\n\r\n  // split if bits > max: +224 => 256-32\r\n  if (wbits > windowSize) {\r\n    // we skip zero, which means instead of `>= size-1`, we do `> size`\r\n    wbits -= maxNumber; // -32, can be maxNumber - wbits, but then we need to set isNeg here.\r\n    nextN += _1n; // +256 (carry)\r\n  }\r\n  const offsetStart = window * windowSize;\r\n  const offset = offsetStart + Math.abs(wbits) - 1; // -1 because we skip zero\r\n  const isZero = wbits === 0; // is current window slice a 0?\r\n  const isNeg = wbits < 0; // is current window slice negative?\r\n  const isNegF = window % 2 !== 0; // fake random statement for noise\r\n  const offsetF = offsetStart; // fake offset for noise\r\n  return { nextN, offset, isZero, isNeg, isNegF, offsetF };\r\n}\r\n\r\nfunction validateMSMPoints(points: any[], c: any) {\r\n  if (!Array.isArray(points)) throw new Error('array expected');\r\n  points.forEach((p, i) => {\r\n    if (!(p instanceof c)) throw new Error('invalid point at index ' + i);\r\n  });\r\n}\r\nfunction validateMSMScalars(scalars: any[], field: any) {\r\n  if (!Array.isArray(scalars)) throw new Error('array of scalars expected');\r\n  scalars.forEach((s, i) => {\r\n    if (!field.isValid(s)) throw new Error('invalid scalar at index ' + i);\r\n  });\r\n}\r\n\r\n// Since points in different groups cannot be equal (different object constructor),\r\n// we can have single place to store precomputes.\r\n// Allows to make points frozen / immutable.\r\nconst pointPrecomputes = new WeakMap<any, any[]>();\r\nconst pointWindowSizes = new WeakMap<any, number>();\r\n\r\nfunction getW(P: any): number {\r\n  return pointWindowSizes.get(P) || 1;\r\n}\r\n\r\nfunction assert0(n: bigint): void {\r\n  if (n !== _0n) throw new Error('invalid wNAF');\r\n}\r\n\r\nexport type IWNAF<T extends Group<T>> = {\r\n  constTimeNegate: <T extends Group<T>>(condition: boolean, item: T) => T;\r\n  hasPrecomputes(elm: T): boolean;\r\n  unsafeLadder(elm: T, n: bigint, p?: T): T;\r\n  precomputeWindow(elm: T, W: number): Group<T>[];\r\n  getPrecomputes(W: number, P: T, transform?: Mapper<T>): T[];\r\n  wNAF(W: number, precomputes: T[], n: bigint): { p: T; f: T };\r\n  wNAFUnsafe(W: number, precomputes: T[], n: bigint, acc?: T): T;\r\n  wNAFCached(P: T, n: bigint, transform?: Mapper<T>): { p: T; f: T };\r\n  wNAFCachedUnsafe(P: T, n: bigint, transform?: Mapper<T>, prev?: T): T;\r\n  setWindowSize(P: T, W: number): void;\r\n};\r\n\r\n/**\r\n * Elliptic curve multiplication of Point by scalar. Fragile.\r\n * Scalars should always be less than curve order: this should be checked inside of a curve itself.\r\n * Creates precomputation tables for fast multiplication:\r\n * - private scalar is split by fixed size windows of W bits\r\n * - every window point is collected from window's table & added to accumulator\r\n * - since windows are different, same point inside tables won't be accessed more than once per calc\r\n * - each multiplication is 'Math.ceil(CURVE_ORDER / ùëä) + 1' point additions (fixed for any scalar)\r\n * - +1 window is neccessary for wNAF\r\n * - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\r\n *\r\n * @todo Research returning 2d JS array of windows, instead of a single window.\r\n * This would allow windows to be in different memory locations\r\n */\r\nexport function wNAF<T extends Group<T>>(c: GroupConstructor<T>, bits: number): IWNAF<T> {\r\n  return {\r\n    constTimeNegate: negateCt,\r\n\r\n    hasPrecomputes(elm: T) {\r\n      return getW(elm) !== 1;\r\n    },\r\n\r\n    // non-const time multiplication ladder\r\n    unsafeLadder(elm: T, n: bigint, p = c.ZERO) {\r\n      let d: T = elm;\r\n      while (n > _0n) {\r\n        if (n & _1n) p = p.add(d);\r\n        d = d.double();\r\n        n >>= _1n;\r\n      }\r\n      return p;\r\n    },\r\n\r\n    /**\r\n     * Creates a wNAF precomputation window. Used for caching.\r\n     * Default window size is set by `utils.precompute()` and is equal to 8.\r\n     * Number of precomputed points depends on the curve size:\r\n     * 2^(ùëä‚àí1) * (Math.ceil(ùëõ / ùëä) + 1), where:\r\n     * - ùëä is the window size\r\n     * - ùëõ is the bitlength of the curve order.\r\n     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\r\n     * @param elm Point instance\r\n     * @param W window size\r\n     * @returns precomputed point tables flattened to a single array\r\n     */\r\n    precomputeWindow(elm: T, W: number): Group<T>[] {\r\n      const { windows, windowSize } = calcWOpts(W, bits);\r\n      const points: T[] = [];\r\n      let p: T = elm;\r\n      let base = p;\r\n      for (let window = 0; window < windows; window++) {\r\n        base = p;\r\n        points.push(base);\r\n        // i=1, bc we skip 0\r\n        for (let i = 1; i < windowSize; i++) {\r\n          base = base.add(p);\r\n          points.push(base);\r\n        }\r\n        p = base.double();\r\n      }\r\n      return points;\r\n    },\r\n\r\n    /**\r\n     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\r\n     * @param W window size\r\n     * @param precomputes precomputed tables\r\n     * @param n scalar (we don't check here, but should be less than curve order)\r\n     * @returns real and fake (for const-time) points\r\n     */\r\n    wNAF(W: number, precomputes: T[], n: bigint): { p: T; f: T } {\r\n      // Smaller version:\r\n      // https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541\r\n      // TODO: check the scalar is less than group order?\r\n      // wNAF behavior is undefined otherwise. But have to carefully remove\r\n      // other checks before wNAF. ORDER == bits here.\r\n      // Accumulators\r\n      let p = c.ZERO;\r\n      let f = c.BASE;\r\n      // This code was first written with assumption that 'f' and 'p' will never be infinity point:\r\n      // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\r\n      // there is negate now: it is possible that negated element from low value\r\n      // would be the same as high element, which will create carry into next window.\r\n      // It's not obvious how this can fail, but still worth investigating later.\r\n      const wo = calcWOpts(W, bits);\r\n      for (let window = 0; window < wo.windows; window++) {\r\n        // (n === _0n) is handled and not early-exited. isEven and offsetF are used for noise\r\n        const { nextN, offset, isZero, isNeg, isNegF, offsetF } = calcOffsets(n, window, wo);\r\n        n = nextN;\r\n        if (isZero) {\r\n          // bits are 0: add garbage to fake point\r\n          // Important part for const-time getPublicKey: add random \"noise\" point to f.\r\n          f = f.add(negateCt(isNegF, precomputes[offsetF]));\r\n        } else {\r\n          // bits are 1: add to result point\r\n          p = p.add(negateCt(isNeg, precomputes[offset]));\r\n        }\r\n      }\r\n      assert0(n);\r\n      // Return both real and fake points: JIT won't eliminate f.\r\n      // At this point there is a way to F be infinity-point even if p is not,\r\n      // which makes it less const-time: around 1 bigint multiply.\r\n      return { p, f };\r\n    },\r\n\r\n    /**\r\n     * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.\r\n     * @param W window size\r\n     * @param precomputes precomputed tables\r\n     * @param n scalar (we don't check here, but should be less than curve order)\r\n     * @param acc accumulator point to add result of multiplication\r\n     * @returns point\r\n     */\r\n    wNAFUnsafe(W: number, precomputes: T[], n: bigint, acc: T = c.ZERO): T {\r\n      const wo = calcWOpts(W, bits);\r\n      for (let window = 0; window < wo.windows; window++) {\r\n        if (n === _0n) break; // Early-exit, skip 0 value\r\n        const { nextN, offset, isZero, isNeg } = calcOffsets(n, window, wo);\r\n        n = nextN;\r\n        if (isZero) {\r\n          // Window bits are 0: skip processing.\r\n          // Move to next window.\r\n          continue;\r\n        } else {\r\n          const item = precomputes[offset];\r\n          acc = acc.add(isNeg ? item.negate() : item); // Re-using acc allows to save adds in MSM\r\n        }\r\n      }\r\n      assert0(n);\r\n      return acc;\r\n    },\r\n\r\n    getPrecomputes(W: number, P: T, transform?: Mapper<T>): T[] {\r\n      // Calculate precomputes on a first run, reuse them after\r\n      let comp = pointPrecomputes.get(P);\r\n      if (!comp) {\r\n        comp = this.precomputeWindow(P, W) as T[];\r\n        if (W !== 1) {\r\n          // Doing transform outside of if brings 15% perf hit\r\n          if (typeof transform === 'function') comp = transform(comp);\r\n          pointPrecomputes.set(P, comp);\r\n        }\r\n      }\r\n      return comp;\r\n    },\r\n\r\n    wNAFCached(P: T, n: bigint, transform?: Mapper<T>): { p: T; f: T } {\r\n      const W = getW(P);\r\n      return this.wNAF(W, this.getPrecomputes(W, P, transform), n);\r\n    },\r\n\r\n    wNAFCachedUnsafe(P: T, n: bigint, transform?: Mapper<T>, prev?: T): T {\r\n      const W = getW(P);\r\n      if (W === 1) return this.unsafeLadder(P, n, prev); // For W=1 ladder is ~x2 faster\r\n      return this.wNAFUnsafe(W, this.getPrecomputes(W, P, transform), n, prev);\r\n    },\r\n\r\n    // We calculate precomputes for elliptic curve point multiplication\r\n    // using windowed method. This specifies window size and\r\n    // stores precomputed values. Usually only base point would be precomputed.\r\n\r\n    setWindowSize(P: T, W: number) {\r\n      validateW(W, bits);\r\n      pointWindowSizes.set(P, W);\r\n      pointPrecomputes.delete(P);\r\n    },\r\n  };\r\n}\r\n\r\n/**\r\n * Endomorphism-specific multiplication for Koblitz curves.\r\n * Cost: 128 dbl, 0-256 adds.\r\n */\r\nexport function mulEndoUnsafe<T extends Group<T>>(\r\n  c: GroupConstructor<T>,\r\n  point: T,\r\n  k1: bigint,\r\n  k2: bigint\r\n): { p1: T; p2: T } {\r\n  let acc = point;\r\n  let p1 = c.ZERO;\r\n  let p2 = c.ZERO;\r\n  while (k1 > _0n || k2 > _0n) {\r\n    if (k1 & _1n) p1 = p1.add(acc);\r\n    if (k2 & _1n) p2 = p2.add(acc);\r\n    acc = acc.double();\r\n    k1 >>= _1n;\r\n    k2 >>= _1n;\r\n  }\r\n  return { p1, p2 };\r\n}\r\n\r\n/**\r\n * Pippenger algorithm for multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\r\n * 30x faster vs naive addition on L=4096, 10x faster than precomputes.\r\n * For N=254bit, L=1, it does: 1024 ADD + 254 DBL. For L=5: 1536 ADD + 254 DBL.\r\n * Algorithmically constant-time (for same L), even when 1 point + scalar, or when scalar = 0.\r\n * @param c Curve Point constructor\r\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\r\n * @param points array of L curve points\r\n * @param scalars array of L scalars (aka private keys / bigints)\r\n */\r\nexport function pippenger<T extends Group<T>>(\r\n  c: GroupConstructor<T>,\r\n  fieldN: IField<bigint>,\r\n  points: T[],\r\n  scalars: bigint[]\r\n): T {\r\n  // If we split scalars by some window (let's say 8 bits), every chunk will only\r\n  // take 256 buckets even if there are 4096 scalars, also re-uses double.\r\n  // TODO:\r\n  // - https://eprint.iacr.org/2024/750.pdf\r\n  // - https://tches.iacr.org/index.php/TCHES/article/view/10287\r\n  // 0 is accepted in scalars\r\n  validateMSMPoints(points, c);\r\n  validateMSMScalars(scalars, fieldN);\r\n  const plength = points.length;\r\n  const slength = scalars.length;\r\n  if (plength !== slength) throw new Error('arrays of points and scalars must have equal length');\r\n  // if (plength === 0) throw new Error('array must be of length >= 2');\r\n  const zero = c.ZERO;\r\n  const wbits = bitLen(BigInt(plength));\r\n  let windowSize = 1; // bits\r\n  if (wbits > 12) windowSize = wbits - 3;\r\n  else if (wbits > 4) windowSize = wbits - 2;\r\n  else if (wbits > 0) windowSize = 2;\r\n  const MASK = bitMask(windowSize);\r\n  const buckets = new Array(Number(MASK) + 1).fill(zero); // +1 for zero array\r\n  const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;\r\n  let sum = zero;\r\n  for (let i = lastBits; i >= 0; i -= windowSize) {\r\n    buckets.fill(zero);\r\n    for (let j = 0; j < slength; j++) {\r\n      const scalar = scalars[j];\r\n      const wbits = Number((scalar >> BigInt(i)) & MASK);\r\n      buckets[wbits] = buckets[wbits].add(points[j]);\r\n    }\r\n    let resI = zero; // not using this will do small speed-up, but will lose ct\r\n    // Skip first bucket, because it is zero\r\n    for (let j = buckets.length - 1, sumI = zero; j > 0; j--) {\r\n      sumI = sumI.add(buckets[j]);\r\n      resI = resI.add(sumI);\r\n    }\r\n    sum = sum.add(resI);\r\n    if (i !== 0) for (let j = 0; j < windowSize; j++) sum = sum.double();\r\n  }\r\n  return sum as T;\r\n}\r\n/**\r\n * Precomputed multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\r\n * @param c Curve Point constructor\r\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\r\n * @param points array of L curve points\r\n * @returns function which multiplies points with scaars\r\n */\r\nexport function precomputeMSMUnsafe<T extends Group<T>>(\r\n  c: GroupConstructor<T>,\r\n  fieldN: IField<bigint>,\r\n  points: T[],\r\n  windowSize: number\r\n): (scalars: bigint[]) => T {\r\n  /**\r\n   * Performance Analysis of Window-based Precomputation\r\n   *\r\n   * Base Case (256-bit scalar, 8-bit window):\r\n   * - Standard precomputation requires:\r\n   *   - 31 additions per scalar √ó 256 scalars = 7,936 ops\r\n   *   - Plus 255 summary additions = 8,191 total ops\r\n   *   Note: Summary additions can be optimized via accumulator\r\n   *\r\n   * Chunked Precomputation Analysis:\r\n   * - Using 32 chunks requires:\r\n   *   - 255 additions per chunk\r\n   *   - 256 doublings\r\n   *   - Total: (255 √ó 32) + 256 = 8,416 ops\r\n   *\r\n   * Memory Usage Comparison:\r\n   * Window Size | Standard Points | Chunked Points\r\n   * ------------|-----------------|---------------\r\n   *     4-bit   |     520         |      15\r\n   *     8-bit   |    4,224        |     255\r\n   *    10-bit   |   13,824        |   1,023\r\n   *    16-bit   |  557,056        |  65,535\r\n   *\r\n   * Key Advantages:\r\n   * 1. Enables larger window sizes due to reduced memory overhead\r\n   * 2. More efficient for smaller scalar counts:\r\n   *    - 16 chunks: (16 √ó 255) + 256 = 4,336 ops\r\n   *    - ~2x faster than standard 8,191 ops\r\n   *\r\n   * Limitations:\r\n   * - Not suitable for plain precomputes (requires 256 constant doublings)\r\n   * - Performance degrades with larger scalar counts:\r\n   *   - Optimal for ~256 scalars\r\n   *   - Less efficient for 4096+ scalars (Pippenger preferred)\r\n   */\r\n  validateW(windowSize, fieldN.BITS);\r\n  validateMSMPoints(points, c);\r\n  const zero = c.ZERO;\r\n  const tableSize = 2 ** windowSize - 1; // table size (without zero)\r\n  const chunks = Math.ceil(fieldN.BITS / windowSize); // chunks of item\r\n  const MASK = bitMask(windowSize);\r\n  const tables = points.map((p: T) => {\r\n    const res = [];\r\n    for (let i = 0, acc = p; i < tableSize; i++) {\r\n      res.push(acc);\r\n      acc = acc.add(p);\r\n    }\r\n    return res;\r\n  });\r\n  return (scalars: bigint[]): T => {\r\n    validateMSMScalars(scalars, fieldN);\r\n    if (scalars.length > points.length)\r\n      throw new Error('array of scalars must be smaller than array of points');\r\n    let res = zero;\r\n    for (let i = 0; i < chunks; i++) {\r\n      // No need to double if accumulator is still zero.\r\n      if (res !== zero) for (let j = 0; j < windowSize; j++) res = res.double();\r\n      const shiftBy = BigInt(chunks * windowSize - (i + 1) * windowSize);\r\n      for (let j = 0; j < scalars.length; j++) {\r\n        const n = scalars[j];\r\n        const curr = Number((n >> shiftBy) & MASK);\r\n        if (!curr) continue; // skip zero scalars chunks\r\n        res = res.add(tables[j][curr - 1]);\r\n      }\r\n    }\r\n    return res;\r\n  };\r\n}\r\n\r\n/**\r\n * Generic BasicCurve interface: works even for polynomial fields (BLS): P, n, h would be ok.\r\n * Though generator can be different (Fp2 / Fp6 for BLS).\r\n */\r\nexport type BasicCurve<T> = {\r\n  Fp: IField<T>; // Field over which we'll do calculations (Fp)\r\n  n: bigint; // Curve order, total count of valid points in the field\r\n  nBitLength?: number; // bit length of curve order\r\n  nByteLength?: number; // byte length of curve order\r\n  h: bigint; // cofactor. we can assign default=1, but users will just ignore it w/o validation\r\n  hEff?: bigint; // Number to multiply to clear cofactor\r\n  Gx: T; // base point X coordinate\r\n  Gy: T; // base point Y coordinate\r\n  allowInfinityPoint?: boolean; // bls12-381 requires it. ZERO point is valid, but invalid pubkey\r\n};\r\n\r\n// TODO: remove\r\n/** @deprecated */\r\nexport function validateBasic<FP, T>(\r\n  curve: BasicCurve<FP> & T\r\n): Readonly<\r\n  {\r\n    readonly nBitLength: number;\r\n    readonly nByteLength: number;\r\n  } & BasicCurve<FP> &\r\n    T & {\r\n      p: bigint;\r\n    }\r\n> {\r\n  validateField(curve.Fp);\r\n  validateObject(\r\n    curve,\r\n    {\r\n      n: 'bigint',\r\n      h: 'bigint',\r\n      Gx: 'field',\r\n      Gy: 'field',\r\n    },\r\n    {\r\n      nBitLength: 'isSafeInteger',\r\n      nByteLength: 'isSafeInteger',\r\n    }\r\n  );\r\n  // Set defaults\r\n  return Object.freeze({\r\n    ...nLength(curve.n, curve.nBitLength),\r\n    ...curve,\r\n    ...{ p: curve.Fp.ORDER },\r\n  } as const);\r\n}\r\n\r\nexport type ValidCurveParams<T> = {\r\n  a: T;\r\n  p: bigint;\r\n  n: bigint;\r\n  h: bigint;\r\n  Gx: T;\r\n  Gy: T;\r\n} & ({ b: T } | { d: T });\r\n\r\nfunction createField<T>(order: bigint, field?: IField<T>): IField<T> {\r\n  if (field) {\r\n    if (field.ORDER !== order) throw new Error('Field.ORDER must match order: Fp == p, Fn == n');\r\n    validateField(field);\r\n    return field;\r\n  } else {\r\n    return Field(order) as unknown as IField<T>;\r\n  }\r\n}\r\nexport type FpFn<T> = { Fp: IField<T>; Fn: IField<bigint> };\r\n/** Validates CURVE opts and creates fields */\r\nexport function _createCurveFields<T>(\r\n  type: 'weierstrass' | 'edwards',\r\n  CURVE: ValidCurveParams<T>,\r\n  curveOpts: Partial<FpFn<T>> = {}\r\n): FpFn<T> {\r\n  if (!CURVE || typeof CURVE !== 'object') throw new Error(`expected valid ${type} CURVE object`);\r\n  for (const p of ['p', 'n', 'h'] as const) {\r\n    const val = CURVE[p];\r\n    if (!(typeof val === 'bigint' && val > _0n))\r\n      throw new Error(`CURVE.${p} must be positive bigint`);\r\n  }\r\n  const Fp = createField(CURVE.p, curveOpts.Fp);\r\n  const Fn = createField(CURVE.n, curveOpts.Fn);\r\n  const _b: 'b' | 'd' = type === 'weierstrass' ? 'b' : 'd';\r\n  const params = ['Gx', 'Gy', 'a', _b] as const;\r\n  for (const p of params) {\r\n    // @ts-ignore\r\n    if (!Fp.isValid(CURVE[p]))\r\n      throw new Error(`CURVE.${p} must be valid field element of CURVE.Fp`);\r\n  }\r\n  return { Fp, Fn };\r\n}\r\n", "/**\r\n * Short Weierstrass curve methods. The formula is: y¬≤ = x¬≥ + ax + b.\r\n *\r\n * ### Design rationale for types\r\n *\r\n * * Interaction between classes from different curves should fail:\r\n *   `k256.Point.BASE.add(p256.Point.BASE)`\r\n * * For this purpose we want to use `instanceof` operator, which is fast and works during runtime\r\n * * Different calls of `curve()` would return different classes -\r\n *   `curve(params) !== curve(params)`: if somebody decided to monkey-patch their curve,\r\n *   it won't affect others\r\n *\r\n * TypeScript can't infer types for classes created inside a function. Classes is one instance\r\n * of nominative types in TypeScript and interfaces only check for shape, so it's hard to create\r\n * unique type for every function call.\r\n *\r\n * We can use generic types via some param, like curve opts, but that would:\r\n *     1. Enable interaction between `curve(params)` and `curve(params)` (curves of same params)\r\n *     which is hard to debug.\r\n *     2. Params can be generic and we can't enforce them to be constant value:\r\n *     if somebody creates curve from non-constant params,\r\n *     it would be allowed to interact with other curves with non-constant params\r\n *\r\n * @todo https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html#unique-symbol\r\n * @module\r\n */\r\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\r\nimport { hmac } from '@noble/hashes/hmac.js';\r\nimport {\r\n  _validateObject,\r\n  abool,\r\n  abytes,\r\n  aInRange,\r\n  bitMask,\r\n  bytesToHex,\r\n  bytesToNumberBE,\r\n  concatBytes,\r\n  createHmacDrbg,\r\n  ensureBytes,\r\n  hexToBytes,\r\n  inRange,\r\n  isBytes,\r\n  memoized,\r\n  numberToHexUnpadded,\r\n  randomBytes,\r\n  type CHash,\r\n  type Hex,\r\n  type PrivKey,\r\n} from '../utils.ts';\r\nimport {\r\n  _createCurveFields,\r\n  mulEndoUnsafe,\r\n  negateCt,\r\n  normalizeZ,\r\n  pippenger,\r\n  wNAF,\r\n  type AffinePoint,\r\n  type BasicCurve,\r\n  type Group,\r\n  type GroupConstructor,\r\n} from './curve.ts';\r\nimport {\r\n  Field,\r\n  FpInvertBatch,\r\n  getMinHashLength,\r\n  mapHashToField,\r\n  validateField,\r\n  type IField,\r\n  type NLength,\r\n} from './modular.ts';\r\n\r\nexport type { AffinePoint };\r\nexport type HmacFnSync = (key: Uint8Array, ...messages: Uint8Array[]) => Uint8Array;\r\n/**\r\n * When Weierstrass curve has `a=0`, it becomes Koblitz curve.\r\n * Koblitz curves allow using **efficiently-computable GLV endomorphism œà**.\r\n * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.\r\n * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.\r\n *\r\n * Endomorphism consists of beta, lambda and splitScalar:\r\n *\r\n * 1. GLV endomorphism œà transforms a point: `P = (x, y) ‚Ü¶ œà(P) = (Œ≤¬∑x mod p, y)`\r\n * 2. GLV scalar decomposition transforms a scalar: `k ‚â° k‚ÇÅ + k‚ÇÇ¬∑Œª (mod n)`\r\n * 3. Then these are combined: `k¬∑P = k‚ÇÅ¬∑P + k‚ÇÇ¬∑œà(P)`\r\n * 4. Two 128-bit point-by-scalar multiplications + one point addition is faster than\r\n *    one 256-bit multiplication.\r\n *\r\n * where\r\n * * beta: Œ≤ ‚àà F‚Çö with Œ≤¬≥ = 1, Œ≤ ‚â† 1\r\n * * lambda: Œª ‚àà F‚Çô with Œª¬≥ = 1, Œª ‚â† 1\r\n * * splitScalar decomposes k ‚Ü¶ k‚ÇÅ, k‚ÇÇ, by using reduced basis vectors.\r\n *   Gauss lattice reduction calculates them from initial basis vectors `(n, 0), (-Œª, 0)`\r\n *\r\n * Check out `test/misc/endomorphism.js` and\r\n * [gist](https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066).\r\n */\r\nexport type EndomorphismOpts = {\r\n  beta: bigint;\r\n  splitScalar: (k: bigint) => { k1neg: boolean; k1: bigint; k2neg: boolean; k2: bigint };\r\n};\r\nexport type BasicWCurve<T> = BasicCurve<T> & {\r\n  // Params: a, b\r\n  a: T;\r\n  b: T;\r\n\r\n  // Optional params\r\n  allowedPrivateKeyLengths?: readonly number[]; // for P521\r\n  wrapPrivateKey?: boolean; // bls12-381 requires mod(n) instead of rejecting keys >= n\r\n  endo?: EndomorphismOpts;\r\n  // When a cofactor != 1, there can be an effective methods to:\r\n  // 1. Determine whether a point is torsion-free\r\n  isTorsionFree?: (c: ProjConstructor<T>, point: ProjPointType<T>) => boolean;\r\n  // 2. Clear torsion component\r\n  clearCofactor?: (c: ProjConstructor<T>, point: ProjPointType<T>) => ProjPointType<T>;\r\n};\r\n\r\nexport type Entropy = Hex | boolean;\r\nexport type SignOpts = { lowS?: boolean; extraEntropy?: Entropy; prehash?: boolean };\r\nexport type VerOpts = {\r\n  lowS?: boolean;\r\n  prehash?: boolean;\r\n  format?: 'compact' | 'der' | 'js' | undefined;\r\n};\r\n\r\nfunction validateSigVerOpts(opts: SignOpts | VerOpts) {\r\n  if (opts.lowS !== undefined) abool('lowS', opts.lowS);\r\n  if (opts.prehash !== undefined) abool('prehash', opts.prehash);\r\n}\r\n\r\n/** Instance methods for 3D XYZ points. */\r\nexport interface ProjPointType<T> extends Group<ProjPointType<T>> {\r\n  /** projective x coordinate. Note: different from .x */\r\n  readonly px: T;\r\n  /** projective y coordinate. Note: different from .y */\r\n  readonly py: T;\r\n  /** projective z coordinate */\r\n  readonly pz: T;\r\n  /** affine x coordinate */\r\n  get x(): T;\r\n  /** affine y coordinate */\r\n  get y(): T;\r\n  assertValidity(): void;\r\n  clearCofactor(): ProjPointType<T>;\r\n  is0(): boolean;\r\n  isTorsionFree(): boolean;\r\n  multiplyUnsafe(scalar: bigint): ProjPointType<T>;\r\n  /**\r\n   * Massively speeds up `p.multiply(n)` by using wnaf precompute tables (caching).\r\n   * Table generation takes 30MB of ram and 10ms on high-end CPU, but may take\r\n   * much longer on slow devices.\r\n   * Actual generation will happen on first call of `.multiply()`.\r\n   * By default, BASE point is precomputed.\r\n   * @param windowSize - table window size\r\n   * @param isLazy - (default true) allows to defer generation\r\n   */\r\n  precompute(windowSize?: number, isLazy?: boolean): ProjPointType<T>;\r\n\r\n  /** Converts 3D XYZ projective point to 2D xy affine coordinates */\r\n  toAffine(invertedZ?: T): AffinePoint<T>;\r\n  /** Encodes point using IEEE P1363 (DER) encoding. First byte is 2/3/4. Default = isCompressed. */\r\n  toBytes(isCompressed?: boolean): Uint8Array;\r\n  toHex(isCompressed?: boolean): string;\r\n\r\n  /** @deprecated use `toBytes` */\r\n  toRawBytes(isCompressed?: boolean): Uint8Array;\r\n  /** @deprecated use `multiplyUnsafe` */\r\n  multiplyAndAddUnsafe(Q: ProjPointType<T>, a: bigint, b: bigint): ProjPointType<T> | undefined;\r\n  /** @deprecated use `p.y % 2n === 0n` */\r\n  hasEvenY(): boolean;\r\n  /** @deprecated use `p.precompute(windowSize)` */\r\n  _setWindowSize(windowSize: number): void;\r\n}\r\n\r\n/** Static methods for 3D XYZ points. */\r\nexport interface ProjConstructor<T> extends GroupConstructor<ProjPointType<T>> {\r\n  Fp: IField<T>;\r\n  Fn: IField<bigint>;\r\n  /** Does NOT validate if the point is valid. Use `.assertValidity()`. */\r\n  new (x: T, y: T, z: T): ProjPointType<T>;\r\n  /** Does NOT validate if the point is valid. Use `.assertValidity()`. */\r\n  fromAffine(p: AffinePoint<T>): ProjPointType<T>;\r\n  fromBytes(encodedPoint: Uint8Array): ProjPointType<T>;\r\n  fromHex(hex: Hex): ProjPointType<T>;\r\n  fromPrivateKey(privateKey: PrivKey): ProjPointType<T>;\r\n  normalizeZ(points: ProjPointType<T>[]): ProjPointType<T>[];\r\n  msm(points: ProjPointType<T>[], scalars: bigint[]): ProjPointType<T>;\r\n}\r\n\r\nexport type CurvePointsType<T> = BasicWCurve<T> & {\r\n  fromBytes?: (bytes: Uint8Array) => AffinePoint<T>;\r\n  toBytes?: (c: ProjConstructor<T>, point: ProjPointType<T>, isCompressed: boolean) => Uint8Array;\r\n};\r\n\r\n// LegacyWeierstrassOpts\r\nexport type CurvePointsTypeWithLength<T> = Readonly<CurvePointsType<T> & Partial<NLength>>;\r\n\r\n// LegacyWeierstrass\r\nexport type CurvePointsRes<T> = {\r\n  /** @deprecated import individual CURVE params */\r\n  CURVE: CurvePointsType<T>;\r\n  Point: ProjConstructor<T>;\r\n  /** @deprecated use `Point` */\r\n  ProjectivePoint: ProjConstructor<T>;\r\n  /** @deprecated */\r\n  normPrivateKeyToScalar: (key: PrivKey) => bigint;\r\n  /** @deprecated */\r\n  weierstrassEquation: (x: T) => T;\r\n  /** @deprecated use `Point.Fn.isValidNot0(num)` */\r\n  isWithinCurveOrder: (num: bigint) => boolean;\r\n};\r\n\r\n// Aliases to legacy types\r\n// export type CurveType = LegacyECDSAOpts;\r\n// export type CurveFn = LegacyECDSA;\r\n// export type CurvePointsRes<T> = LegacyWeierstrass<T>;\r\n// export type CurvePointsType<T> = LegacyWeierstrassOpts<T>;\r\n// export type CurvePointsTypeWithLength<T> = LegacyWeierstrassOpts<T>;\r\n// export type BasicWCurve<T> = LegacyWeierstrassOpts<T>;\r\n\r\n/**\r\n * Weierstrass curve options.\r\n *\r\n * * p: prime characteristic (order) of finite field, in which arithmetics is done\r\n * * n: order of prime subgroup a.k.a total amount of valid curve points\r\n * * h: cofactor, usually 1. h*n is group order; n is subgroup order\r\n * * a: formula param, must be in field of p\r\n * * b: formula param, must be in field of p\r\n * * Gx: x coordinate of generator point a.k.a. base point\r\n * * Gy: y coordinate of generator point\r\n */\r\nexport type WeierstrassOpts<T> = Readonly<{\r\n  p: bigint;\r\n  n: bigint;\r\n  h: bigint;\r\n  a: T;\r\n  b: T;\r\n  Gx: T;\r\n  Gy: T;\r\n}>;\r\n\r\n// When a cofactor != 1, there can be an effective methods to:\r\n// 1. Determine whether a point is torsion-free\r\n// 2. Clear torsion component\r\n// wrapPrivateKey: bls12-381 requires mod(n) instead of rejecting keys >= n\r\nexport type WeierstrassExtraOpts<T> = Partial<{\r\n  Fp: IField<T>;\r\n  Fn: IField<bigint>;\r\n  // TODO: remove\r\n  allowedPrivateKeyLengths: readonly number[]; // for P521\r\n  allowInfinityPoint: boolean;\r\n  endo: EndomorphismOpts;\r\n  wrapPrivateKey: boolean;\r\n  isTorsionFree: (c: ProjConstructor<T>, point: ProjPointType<T>) => boolean;\r\n  clearCofactor: (c: ProjConstructor<T>, point: ProjPointType<T>) => ProjPointType<T>;\r\n  fromBytes: (bytes: Uint8Array) => AffinePoint<T>;\r\n  toBytes: (c: ProjConstructor<T>, point: ProjPointType<T>, isCompressed: boolean) => Uint8Array;\r\n}>;\r\n\r\n/**\r\n * Options for ECDSA signatures over a Weierstrass curve.\r\n */\r\nexport type ECDSAOpts = {\r\n  hash: CHash;\r\n  hmac?: HmacFnSync;\r\n  randomBytes?: (bytesLength?: number) => Uint8Array;\r\n  lowS?: boolean;\r\n  bits2int?: (bytes: Uint8Array) => bigint;\r\n  bits2int_modN?: (bytes: Uint8Array) => bigint;\r\n};\r\n\r\n/** ECDSA is only supported for prime fields, not Fp2 (extension fields). */\r\nexport interface ECDSA {\r\n  getPublicKey: (privateKey: PrivKey, isCompressed?: boolean) => Uint8Array;\r\n  getSharedSecret: (privateA: PrivKey, publicB: Hex, isCompressed?: boolean) => Uint8Array;\r\n  sign: (msgHash: Hex, privKey: PrivKey, opts?: SignOpts) => RecoveredSignatureType;\r\n  verify: (signature: Hex | SignatureLike, msgHash: Hex, publicKey: Hex, opts?: VerOpts) => boolean;\r\n  Point: ProjConstructor<bigint>;\r\n  Signature: SignatureConstructor;\r\n  utils: {\r\n    isValidPrivateKey(privateKey: PrivKey): boolean;\r\n    randomPrivateKey: () => Uint8Array;\r\n    // TODO: deprecate those two\r\n    normPrivateKeyToScalar: (key: PrivKey) => bigint;\r\n    /** @deprecated */\r\n    precompute: (windowSize?: number, point?: ProjPointType<bigint>) => ProjPointType<bigint>;\r\n  };\r\n}\r\nexport class DERErr extends Error {\r\n  constructor(m = '') {\r\n    super(m);\r\n  }\r\n}\r\nexport type IDER = {\r\n  // asn.1 DER encoding utils\r\n  Err: typeof DERErr;\r\n  // Basic building block is TLV (Tag-Length-Value)\r\n  _tlv: {\r\n    encode: (tag: number, data: string) => string;\r\n    // v - value, l - left bytes (unparsed)\r\n    decode(tag: number, data: Uint8Array): { v: Uint8Array; l: Uint8Array };\r\n  };\r\n  // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\r\n  // since we always use positive integers here. It must always be empty:\r\n  // - add zero byte if exists\r\n  // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\r\n  _int: {\r\n    encode(num: bigint): string;\r\n    decode(data: Uint8Array): bigint;\r\n  };\r\n  toSig(hex: string | Uint8Array): { r: bigint; s: bigint };\r\n  hexFromSig(sig: { r: bigint; s: bigint }): string;\r\n};\r\n/**\r\n * ASN.1 DER encoding utilities. ASN is very complex & fragile. Format:\r\n *\r\n *     [0x30 (SEQUENCE), bytelength, 0x02 (INTEGER), intLength, R, 0x02 (INTEGER), intLength, S]\r\n *\r\n * Docs: https://letsencrypt.org/docs/a-warm-welcome-to-asn1-and-der/, https://luca.ntop.org/Teaching/Appunti/asn1.html\r\n */\r\nexport const DER: IDER = {\r\n  // asn.1 DER encoding utils\r\n  Err: DERErr,\r\n  // Basic building block is TLV (Tag-Length-Value)\r\n  _tlv: {\r\n    encode: (tag: number, data: string): string => {\r\n      const { Err: E } = DER;\r\n      if (tag < 0 || tag > 256) throw new E('tlv.encode: wrong tag');\r\n      if (data.length & 1) throw new E('tlv.encode: unpadded data');\r\n      const dataLen = data.length / 2;\r\n      const len = numberToHexUnpadded(dataLen);\r\n      if ((len.length / 2) & 0b1000_0000) throw new E('tlv.encode: long form length too big');\r\n      // length of length with long form flag\r\n      const lenLen = dataLen > 127 ? numberToHexUnpadded((len.length / 2) | 0b1000_0000) : '';\r\n      const t = numberToHexUnpadded(tag);\r\n      return t + lenLen + len + data;\r\n    },\r\n    // v - value, l - left bytes (unparsed)\r\n    decode(tag: number, data: Uint8Array): { v: Uint8Array; l: Uint8Array } {\r\n      const { Err: E } = DER;\r\n      let pos = 0;\r\n      if (tag < 0 || tag > 256) throw new E('tlv.encode: wrong tag');\r\n      if (data.length < 2 || data[pos++] !== tag) throw new E('tlv.decode: wrong tlv');\r\n      const first = data[pos++];\r\n      const isLong = !!(first & 0b1000_0000); // First bit of first length byte is flag for short/long form\r\n      let length = 0;\r\n      if (!isLong) length = first;\r\n      else {\r\n        // Long form: [longFlag(1bit), lengthLength(7bit), length (BE)]\r\n        const lenLen = first & 0b0111_1111;\r\n        if (!lenLen) throw new E('tlv.decode(long): indefinite length not supported');\r\n        if (lenLen > 4) throw new E('tlv.decode(long): byte length is too big'); // this will overflow u32 in js\r\n        const lengthBytes = data.subarray(pos, pos + lenLen);\r\n        if (lengthBytes.length !== lenLen) throw new E('tlv.decode: length bytes not complete');\r\n        if (lengthBytes[0] === 0) throw new E('tlv.decode(long): zero leftmost byte');\r\n        for (const b of lengthBytes) length = (length << 8) | b;\r\n        pos += lenLen;\r\n        if (length < 128) throw new E('tlv.decode(long): not minimal encoding');\r\n      }\r\n      const v = data.subarray(pos, pos + length);\r\n      if (v.length !== length) throw new E('tlv.decode: wrong value length');\r\n      return { v, l: data.subarray(pos + length) };\r\n    },\r\n  },\r\n  // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\r\n  // since we always use positive integers here. It must always be empty:\r\n  // - add zero byte if exists\r\n  // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\r\n  _int: {\r\n    encode(num: bigint): string {\r\n      const { Err: E } = DER;\r\n      if (num < _0n) throw new E('integer: negative integers are not allowed');\r\n      let hex = numberToHexUnpadded(num);\r\n      // Pad with zero byte if negative flag is present\r\n      if (Number.parseInt(hex[0], 16) & 0b1000) hex = '00' + hex;\r\n      if (hex.length & 1) throw new E('unexpected DER parsing assertion: unpadded hex');\r\n      return hex;\r\n    },\r\n    decode(data: Uint8Array): bigint {\r\n      const { Err: E } = DER;\r\n      if (data[0] & 0b1000_0000) throw new E('invalid signature integer: negative');\r\n      if (data[0] === 0x00 && !(data[1] & 0b1000_0000))\r\n        throw new E('invalid signature integer: unnecessary leading zero');\r\n      return bytesToNumberBE(data);\r\n    },\r\n  },\r\n  toSig(hex: string | Uint8Array): { r: bigint; s: bigint } {\r\n    // parse DER signature\r\n    const { Err: E, _int: int, _tlv: tlv } = DER;\r\n    const data = ensureBytes('signature', hex);\r\n    const { v: seqBytes, l: seqLeftBytes } = tlv.decode(0x30, data);\r\n    if (seqLeftBytes.length) throw new E('invalid signature: left bytes after parsing');\r\n    const { v: rBytes, l: rLeftBytes } = tlv.decode(0x02, seqBytes);\r\n    const { v: sBytes, l: sLeftBytes } = tlv.decode(0x02, rLeftBytes);\r\n    if (sLeftBytes.length) throw new E('invalid signature: left bytes after parsing');\r\n    return { r: int.decode(rBytes), s: int.decode(sBytes) };\r\n  },\r\n  hexFromSig(sig: { r: bigint; s: bigint }): string {\r\n    const { _tlv: tlv, _int: int } = DER;\r\n    const rs = tlv.encode(0x02, int.encode(sig.r));\r\n    const ss = tlv.encode(0x02, int.encode(sig.s));\r\n    const seq = rs + ss;\r\n    return tlv.encode(0x30, seq);\r\n  },\r\n};\r\n\r\n// Be friendly to bad ECMAScript parsers by not using bigint literals\r\n// prettier-ignore\r\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\r\n\r\n// TODO: remove\r\nexport function _legacyHelperEquat<T>(Fp: IField<T>, a: T, b: T): (x: T) => T {\r\n  /**\r\n   * y¬≤ = x¬≥ + ax + b: Short weierstrass curve formula. Takes x, returns y¬≤.\r\n   * @returns y¬≤\r\n   */\r\n  function weierstrassEquation(x: T): T {\r\n    const x2 = Fp.sqr(x); // x * x\r\n    const x3 = Fp.mul(x2, x); // x¬≤ * x\r\n    return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x¬≥ + a * x + b\r\n  }\r\n  return weierstrassEquation;\r\n}\r\nexport function _legacyHelperNormPriv(\r\n  Fn: IField<bigint>,\r\n  allowedPrivateKeyLengths?: readonly number[],\r\n  wrapPrivateKey?: boolean\r\n): (key: PrivKey) => bigint {\r\n  const { BYTES: expected } = Fn;\r\n  // Validates if priv key is valid and converts it to bigint.\r\n  function normPrivateKeyToScalar(key: PrivKey): bigint {\r\n    let num: bigint;\r\n    if (typeof key === 'bigint') {\r\n      num = key;\r\n    } else {\r\n      let bytes = ensureBytes('private key', key);\r\n      if (allowedPrivateKeyLengths) {\r\n        if (!allowedPrivateKeyLengths.includes(bytes.length * 2))\r\n          throw new Error('invalid private key');\r\n        const padded = new Uint8Array(expected);\r\n        padded.set(bytes, padded.length - bytes.length);\r\n        bytes = padded;\r\n      }\r\n      try {\r\n        num = Fn.fromBytes(bytes);\r\n      } catch (error) {\r\n        throw new Error(\r\n          `invalid private key: expected ui8a of size ${expected}, got ${typeof key}`\r\n        );\r\n      }\r\n    }\r\n    if (wrapPrivateKey) num = Fn.create(num); // disabled by default, enabled for BLS\r\n    if (!Fn.isValidNot0(num)) throw new Error('invalid private key: out of range [1..N-1]');\r\n    return num;\r\n  }\r\n  return normPrivateKeyToScalar;\r\n}\r\n\r\nexport function weierstrassN<T>(\r\n  CURVE: WeierstrassOpts<T>,\r\n  curveOpts: WeierstrassExtraOpts<T> = {}\r\n): ProjConstructor<T> {\r\n  const { Fp, Fn } = _createCurveFields('weierstrass', CURVE, curveOpts);\r\n  const { h: cofactor, n: CURVE_ORDER } = CURVE;\r\n  _validateObject(\r\n    curveOpts,\r\n    {},\r\n    {\r\n      allowInfinityPoint: 'boolean',\r\n      clearCofactor: 'function',\r\n      isTorsionFree: 'function',\r\n      fromBytes: 'function',\r\n      toBytes: 'function',\r\n      endo: 'object',\r\n      wrapPrivateKey: 'boolean',\r\n    }\r\n  );\r\n\r\n  const { endo } = curveOpts;\r\n  if (endo) {\r\n    // validateObject(endo, { beta: 'bigint', splitScalar: 'function' });\r\n    if (\r\n      !Fp.is0(CURVE.a) ||\r\n      typeof endo.beta !== 'bigint' ||\r\n      typeof endo.splitScalar !== 'function'\r\n    ) {\r\n      throw new Error('invalid endo: expected \"beta\": bigint and \"splitScalar\": function');\r\n    }\r\n  }\r\n\r\n  function assertCompressionIsSupported() {\r\n    if (!Fp.isOdd) throw new Error('compression is not supported: Field does not have .isOdd()');\r\n  }\r\n\r\n  // Implements IEEE P1363 point encoding\r\n  function pointToBytes(\r\n    _c: ProjConstructor<T>,\r\n    point: ProjPointType<T>,\r\n    isCompressed: boolean\r\n  ): Uint8Array {\r\n    const { x, y } = point.toAffine();\r\n    const bx = Fp.toBytes(x);\r\n    abool('isCompressed', isCompressed);\r\n    if (isCompressed) {\r\n      assertCompressionIsSupported();\r\n      const hasEvenY = !Fp.isOdd!(y);\r\n      return concatBytes(pprefix(hasEvenY), bx);\r\n    } else {\r\n      return concatBytes(Uint8Array.of(0x04), bx, Fp.toBytes(y));\r\n    }\r\n  }\r\n  function pointFromBytes(bytes: Uint8Array) {\r\n    abytes(bytes);\r\n    const L = Fp.BYTES;\r\n    const LC = L + 1; // length compressed, e.g. 33 for 32-byte field\r\n    const LU = 2 * L + 1; // length uncompressed, e.g. 65 for 32-byte field\r\n    const length = bytes.length;\r\n    const head = bytes[0];\r\n    const tail = bytes.subarray(1);\r\n    // No actual validation is done here: use .assertValidity()\r\n    if (length === LC && (head === 0x02 || head === 0x03)) {\r\n      const x = Fp.fromBytes(tail);\r\n      if (!Fp.isValid(x)) throw new Error('bad point: is not on curve, wrong x');\r\n      const y2 = weierstrassEquation(x); // y¬≤ = x¬≥ + ax + b\r\n      let y: T;\r\n      try {\r\n        y = Fp.sqrt(y2); // y = y¬≤ ^ (p+1)/4\r\n      } catch (sqrtError) {\r\n        const err = sqrtError instanceof Error ? ': ' + sqrtError.message : '';\r\n        throw new Error('bad point: is not on curve, sqrt error' + err);\r\n      }\r\n      assertCompressionIsSupported();\r\n      const isYOdd = Fp.isOdd!(y); // (y & _1n) === _1n;\r\n      const isHeadOdd = (head & 1) === 1; // ECDSA-specific\r\n      if (isHeadOdd !== isYOdd) y = Fp.neg(y);\r\n      return { x, y };\r\n    } else if (length === LU && head === 0x04) {\r\n      // TODO: more checks\r\n      const x = Fp.fromBytes(tail.subarray(L * 0, L * 1));\r\n      const y = Fp.fromBytes(tail.subarray(L * 1, L * 2));\r\n      if (!isValidXY(x, y)) throw new Error('bad point: is not on curve');\r\n      return { x, y };\r\n    } else {\r\n      throw new Error(\r\n        `bad point: got length ${length}, expected compressed=${LC} or uncompressed=${LU}`\r\n      );\r\n    }\r\n  }\r\n\r\n  const toBytes = curveOpts.toBytes || pointToBytes;\r\n  const fromBytes = curveOpts.fromBytes || pointFromBytes;\r\n  const weierstrassEquation = _legacyHelperEquat(Fp, CURVE.a, CURVE.b);\r\n\r\n  // TODO: move top-level\r\n  /** Checks whether equation holds for given x, y: y¬≤ == x¬≥ + ax + b */\r\n  function isValidXY(x: T, y: T): boolean {\r\n    const left = Fp.sqr(y); // y¬≤\r\n    const right = weierstrassEquation(x); // x¬≥ + ax + b\r\n    return Fp.eql(left, right);\r\n  }\r\n\r\n  // Validate whether the passed curve params are valid.\r\n  // Test 1: equation y¬≤ = x¬≥ + ax + b should work for generator point.\r\n  if (!isValidXY(CURVE.Gx, CURVE.Gy)) throw new Error('bad curve params: generator point');\r\n\r\n  // Test 2: discriminant Œî part should be non-zero: 4a¬≥ + 27b¬≤ != 0.\r\n  // Guarantees curve is genus-1, smooth (non-singular).\r\n  const _4a3 = Fp.mul(Fp.pow(CURVE.a, _3n), _4n);\r\n  const _27b2 = Fp.mul(Fp.sqr(CURVE.b), BigInt(27));\r\n  if (Fp.is0(Fp.add(_4a3, _27b2))) throw new Error('bad curve params: a or b');\r\n\r\n  /** Asserts coordinate is valid: 0 <= n < Fp.ORDER. */\r\n  function acoord(title: string, n: T, banZero = false) {\r\n    if (!Fp.isValid(n) || (banZero && Fp.is0(n))) throw new Error(`bad point coordinate ${title}`);\r\n    return n;\r\n  }\r\n\r\n  function aprjpoint(other: unknown) {\r\n    if (!(other instanceof Point)) throw new Error('ProjectivePoint expected');\r\n  }\r\n\r\n  // Memoized toAffine / validity check. They are heavy. Points are immutable.\r\n\r\n  // Converts Projective point to affine (x, y) coordinates.\r\n  // Can accept precomputed Z^-1 - for example, from invertBatch.\r\n  // (X, Y, Z) ‚àã (x=X/Z, y=Y/Z)\r\n  const toAffineMemo = memoized((p: Point, iz?: T): AffinePoint<T> => {\r\n    const { px: x, py: y, pz: z } = p;\r\n    // Fast-path for normalized points\r\n    if (Fp.eql(z, Fp.ONE)) return { x, y };\r\n    const is0 = p.is0();\r\n    // If invZ was 0, we return zero point. However we still want to execute\r\n    // all operations, so we replace invZ with a random number, 1.\r\n    if (iz == null) iz = is0 ? Fp.ONE : Fp.inv(z);\r\n    const ax = Fp.mul(x, iz);\r\n    const ay = Fp.mul(y, iz);\r\n    const zz = Fp.mul(z, iz);\r\n    if (is0) return { x: Fp.ZERO, y: Fp.ZERO };\r\n    if (!Fp.eql(zz, Fp.ONE)) throw new Error('invZ was invalid');\r\n    return { x: ax, y: ay };\r\n  });\r\n  // NOTE: on exception this will crash 'cached' and no value will be set.\r\n  // Otherwise true will be return\r\n  const assertValidMemo = memoized((p: Point) => {\r\n    if (p.is0()) {\r\n      // (0, 1, 0) aka ZERO is invalid in most contexts.\r\n      // In BLS, ZERO can be serialized, so we allow it.\r\n      // (0, 0, 0) is invalid representation of ZERO.\r\n      if (curveOpts.allowInfinityPoint && !Fp.is0(p.py)) return;\r\n      throw new Error('bad point: ZERO');\r\n    }\r\n    // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\r\n    const { x, y } = p.toAffine();\r\n    if (!Fp.isValid(x) || !Fp.isValid(y)) throw new Error('bad point: x or y not field elements');\r\n    if (!isValidXY(x, y)) throw new Error('bad point: equation left != right');\r\n    if (!p.isTorsionFree()) throw new Error('bad point: not in prime-order subgroup');\r\n    return true;\r\n  });\r\n\r\n  function finishEndo(\r\n    endoBeta: EndomorphismOpts['beta'],\r\n    k1p: Point,\r\n    k2p: Point,\r\n    k1neg: boolean,\r\n    k2neg: boolean\r\n  ) {\r\n    k2p = new Point(Fp.mul(k2p.px, endoBeta), k2p.py, k2p.pz);\r\n    k1p = negateCt(k1neg, k1p);\r\n    k2p = negateCt(k2neg, k2p);\r\n    return k1p.add(k2p);\r\n  }\r\n\r\n  /**\r\n   * Projective Point works in 3d / projective (homogeneous) coordinates:(X, Y, Z) ‚àã (x=X/Z, y=Y/Z).\r\n   * Default Point works in 2d / affine coordinates: (x, y).\r\n   * We're doing calculations in projective, because its operations don't require costly inversion.\r\n   */\r\n  class Point implements ProjPointType<T> {\r\n    // base / generator point\r\n    static readonly BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\r\n    // zero / infinity / identity point\r\n    static readonly ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO); // 0, 1, 0\r\n    // fields\r\n    static readonly Fp = Fp;\r\n    static readonly Fn = Fn;\r\n\r\n    readonly px: T;\r\n    readonly py: T;\r\n    readonly pz: T;\r\n\r\n    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */\r\n    constructor(px: T, py: T, pz: T) {\r\n      this.px = acoord('x', px);\r\n      this.py = acoord('y', py, true);\r\n      this.pz = acoord('z', pz);\r\n      Object.freeze(this);\r\n    }\r\n\r\n    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */\r\n    static fromAffine(p: AffinePoint<T>): Point {\r\n      const { x, y } = p || {};\r\n      if (!p || !Fp.isValid(x) || !Fp.isValid(y)) throw new Error('invalid affine point');\r\n      if (p instanceof Point) throw new Error('projective point not allowed');\r\n      // (0, 0) would've produced (0, 0, 1) - instead, we need (0, 1, 0)\r\n      if (Fp.is0(x) && Fp.is0(y)) return Point.ZERO;\r\n      return new Point(x, y, Fp.ONE);\r\n    }\r\n\r\n    get x(): T {\r\n      return this.toAffine().x;\r\n    }\r\n    get y(): T {\r\n      return this.toAffine().y;\r\n    }\r\n\r\n    static normalizeZ(points: Point[]): Point[] {\r\n      return normalizeZ(Point, 'pz', points);\r\n    }\r\n\r\n    static fromBytes(bytes: Uint8Array): Point {\r\n      abytes(bytes);\r\n      return Point.fromHex(bytes);\r\n    }\r\n\r\n    /** Converts hash string or Uint8Array to Point. */\r\n    static fromHex(hex: Hex): Point {\r\n      const P = Point.fromAffine(fromBytes(ensureBytes('pointHex', hex)));\r\n      P.assertValidity();\r\n      return P;\r\n    }\r\n\r\n    /** Multiplies generator point by privateKey. */\r\n    static fromPrivateKey(privateKey: PrivKey) {\r\n      const normPrivateKeyToScalar = _legacyHelperNormPriv(\r\n        Fn,\r\n        curveOpts.allowedPrivateKeyLengths,\r\n        curveOpts.wrapPrivateKey\r\n      );\r\n      return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));\r\n    }\r\n\r\n    /** Multiscalar Multiplication */\r\n    static msm(points: Point[], scalars: bigint[]): Point {\r\n      return pippenger(Point, Fn, points, scalars);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param windowSize\r\n     * @param isLazy true will defer table computation until the first multiplication\r\n     * @returns\r\n     */\r\n    precompute(windowSize: number = 8, isLazy = true): Point {\r\n      wnaf.setWindowSize(this, windowSize);\r\n      if (!isLazy) this.multiply(_3n); // random number\r\n      return this;\r\n    }\r\n\r\n    /** \"Private method\", don't use it directly */\r\n    _setWindowSize(windowSize: number) {\r\n      this.precompute(windowSize);\r\n    }\r\n\r\n    // TODO: return `this`\r\n    /** A point on curve is valid if it conforms to equation. */\r\n    assertValidity(): void {\r\n      assertValidMemo(this);\r\n    }\r\n\r\n    hasEvenY(): boolean {\r\n      const { y } = this.toAffine();\r\n      if (!Fp.isOdd) throw new Error(\"Field doesn't support isOdd\");\r\n      return !Fp.isOdd(y);\r\n    }\r\n\r\n    /** Compare one point to another. */\r\n    equals(other: Point): boolean {\r\n      aprjpoint(other);\r\n      const { px: X1, py: Y1, pz: Z1 } = this;\r\n      const { px: X2, py: Y2, pz: Z2 } = other;\r\n      const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\r\n      const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\r\n      return U1 && U2;\r\n    }\r\n\r\n    /** Flips point to one corresponding to (x, -y) in Affine coordinates. */\r\n    negate(): Point {\r\n      return new Point(this.px, Fp.neg(this.py), this.pz);\r\n    }\r\n\r\n    // Renes-Costello-Batina exception-free doubling formula.\r\n    // There is 30% faster Jacobian formula, but it is not complete.\r\n    // https://eprint.iacr.org/2015/1060, algorithm 3\r\n    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\r\n    double() {\r\n      const { a, b } = CURVE;\r\n      const b3 = Fp.mul(b, _3n);\r\n      const { px: X1, py: Y1, pz: Z1 } = this;\r\n      let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\r\n      let t0 = Fp.mul(X1, X1); // step 1\r\n      let t1 = Fp.mul(Y1, Y1);\r\n      let t2 = Fp.mul(Z1, Z1);\r\n      let t3 = Fp.mul(X1, Y1);\r\n      t3 = Fp.add(t3, t3); // step 5\r\n      Z3 = Fp.mul(X1, Z1);\r\n      Z3 = Fp.add(Z3, Z3);\r\n      X3 = Fp.mul(a, Z3);\r\n      Y3 = Fp.mul(b3, t2);\r\n      Y3 = Fp.add(X3, Y3); // step 10\r\n      X3 = Fp.sub(t1, Y3);\r\n      Y3 = Fp.add(t1, Y3);\r\n      Y3 = Fp.mul(X3, Y3);\r\n      X3 = Fp.mul(t3, X3);\r\n      Z3 = Fp.mul(b3, Z3); // step 15\r\n      t2 = Fp.mul(a, t2);\r\n      t3 = Fp.sub(t0, t2);\r\n      t3 = Fp.mul(a, t3);\r\n      t3 = Fp.add(t3, Z3);\r\n      Z3 = Fp.add(t0, t0); // step 20\r\n      t0 = Fp.add(Z3, t0);\r\n      t0 = Fp.add(t0, t2);\r\n      t0 = Fp.mul(t0, t3);\r\n      Y3 = Fp.add(Y3, t0);\r\n      t2 = Fp.mul(Y1, Z1); // step 25\r\n      t2 = Fp.add(t2, t2);\r\n      t0 = Fp.mul(t2, t3);\r\n      X3 = Fp.sub(X3, t0);\r\n      Z3 = Fp.mul(t2, t1);\r\n      Z3 = Fp.add(Z3, Z3); // step 30\r\n      Z3 = Fp.add(Z3, Z3);\r\n      return new Point(X3, Y3, Z3);\r\n    }\r\n\r\n    // Renes-Costello-Batina exception-free addition formula.\r\n    // There is 30% faster Jacobian formula, but it is not complete.\r\n    // https://eprint.iacr.org/2015/1060, algorithm 1\r\n    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\r\n    add(other: Point): Point {\r\n      aprjpoint(other);\r\n      const { px: X1, py: Y1, pz: Z1 } = this;\r\n      const { px: X2, py: Y2, pz: Z2 } = other;\r\n      let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\r\n      const a = CURVE.a;\r\n      const b3 = Fp.mul(CURVE.b, _3n);\r\n      let t0 = Fp.mul(X1, X2); // step 1\r\n      let t1 = Fp.mul(Y1, Y2);\r\n      let t2 = Fp.mul(Z1, Z2);\r\n      let t3 = Fp.add(X1, Y1);\r\n      let t4 = Fp.add(X2, Y2); // step 5\r\n      t3 = Fp.mul(t3, t4);\r\n      t4 = Fp.add(t0, t1);\r\n      t3 = Fp.sub(t3, t4);\r\n      t4 = Fp.add(X1, Z1);\r\n      let t5 = Fp.add(X2, Z2); // step 10\r\n      t4 = Fp.mul(t4, t5);\r\n      t5 = Fp.add(t0, t2);\r\n      t4 = Fp.sub(t4, t5);\r\n      t5 = Fp.add(Y1, Z1);\r\n      X3 = Fp.add(Y2, Z2); // step 15\r\n      t5 = Fp.mul(t5, X3);\r\n      X3 = Fp.add(t1, t2);\r\n      t5 = Fp.sub(t5, X3);\r\n      Z3 = Fp.mul(a, t4);\r\n      X3 = Fp.mul(b3, t2); // step 20\r\n      Z3 = Fp.add(X3, Z3);\r\n      X3 = Fp.sub(t1, Z3);\r\n      Z3 = Fp.add(t1, Z3);\r\n      Y3 = Fp.mul(X3, Z3);\r\n      t1 = Fp.add(t0, t0); // step 25\r\n      t1 = Fp.add(t1, t0);\r\n      t2 = Fp.mul(a, t2);\r\n      t4 = Fp.mul(b3, t4);\r\n      t1 = Fp.add(t1, t2);\r\n      t2 = Fp.sub(t0, t2); // step 30\r\n      t2 = Fp.mul(a, t2);\r\n      t4 = Fp.add(t4, t2);\r\n      t0 = Fp.mul(t1, t4);\r\n      Y3 = Fp.add(Y3, t0);\r\n      t0 = Fp.mul(t5, t4); // step 35\r\n      X3 = Fp.mul(t3, X3);\r\n      X3 = Fp.sub(X3, t0);\r\n      t0 = Fp.mul(t3, t1);\r\n      Z3 = Fp.mul(t5, Z3);\r\n      Z3 = Fp.add(Z3, t0); // step 40\r\n      return new Point(X3, Y3, Z3);\r\n    }\r\n\r\n    subtract(other: Point) {\r\n      return this.add(other.negate());\r\n    }\r\n\r\n    is0(): boolean {\r\n      return this.equals(Point.ZERO);\r\n    }\r\n\r\n    /**\r\n     * Constant time multiplication.\r\n     * Uses wNAF method. Windowed method may be 10% faster,\r\n     * but takes 2x longer to generate and consumes 2x memory.\r\n     * Uses precomputes when available.\r\n     * Uses endomorphism for Koblitz curves.\r\n     * @param scalar by which the point would be multiplied\r\n     * @returns New point\r\n     */\r\n    multiply(scalar: bigint): Point {\r\n      const { endo } = curveOpts;\r\n      if (!Fn.isValidNot0(scalar)) throw new Error('invalid scalar: out of range'); // 0 is invalid\r\n      let point: Point, fake: Point; // Fake point is used to const-time mult\r\n      const mul = (n: bigint) => wnaf.wNAFCached(this, n, Point.normalizeZ);\r\n      /** See docs for {@link EndomorphismOpts} */\r\n      if (endo) {\r\n        const { k1neg, k1, k2neg, k2 } = endo.splitScalar(scalar);\r\n        const { p: k1p, f: k1f } = mul(k1);\r\n        const { p: k2p, f: k2f } = mul(k2);\r\n        fake = k1f.add(k2f);\r\n        point = finishEndo(endo.beta, k1p, k2p, k1neg, k2neg);\r\n      } else {\r\n        const { p, f } = mul(scalar);\r\n        point = p;\r\n        fake = f;\r\n      }\r\n      // Normalize `z` for both points, but return only real one\r\n      return Point.normalizeZ([point, fake])[0];\r\n    }\r\n\r\n    /**\r\n     * Non-constant-time multiplication. Uses double-and-add algorithm.\r\n     * It's faster, but should only be used when you don't care about\r\n     * an exposed private key e.g. sig verification, which works over *public* keys.\r\n     */\r\n    multiplyUnsafe(sc: bigint): Point {\r\n      const { endo } = curveOpts;\r\n      const p = this;\r\n      if (!Fn.isValid(sc)) throw new Error('invalid scalar: out of range'); // 0 is valid\r\n      if (sc === _0n || p.is0()) return Point.ZERO;\r\n      if (sc === _1n) return p; // fast-path\r\n      if (wnaf.hasPrecomputes(this)) return this.multiply(sc);\r\n      if (endo) {\r\n        const { k1neg, k1, k2neg, k2 } = endo.splitScalar(sc);\r\n        // `wNAFCachedUnsafe` is 30% slower\r\n        const { p1, p2 } = mulEndoUnsafe(Point, p, k1, k2);\r\n        return finishEndo(endo.beta, p1, p2, k1neg, k2neg);\r\n      } else {\r\n        return wnaf.wNAFCachedUnsafe(p, sc);\r\n      }\r\n    }\r\n\r\n    multiplyAndAddUnsafe(Q: Point, a: bigint, b: bigint): Point | undefined {\r\n      const sum = this.multiplyUnsafe(a).add(Q.multiplyUnsafe(b));\r\n      return sum.is0() ? undefined : sum;\r\n    }\r\n\r\n    /**\r\n     * Converts Projective point to affine (x, y) coordinates.\r\n     * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch\r\n     */\r\n    toAffine(invertedZ?: T): AffinePoint<T> {\r\n      return toAffineMemo(this, invertedZ);\r\n    }\r\n\r\n    /**\r\n     * Checks whether Point is free of torsion elements (is in prime subgroup).\r\n     * Always torsion-free for cofactor=1 curves.\r\n     */\r\n    isTorsionFree(): boolean {\r\n      const { isTorsionFree } = curveOpts;\r\n      if (cofactor === _1n) return true;\r\n      if (isTorsionFree) return isTorsionFree(Point, this);\r\n      return wnaf.wNAFCachedUnsafe(this, CURVE_ORDER).is0();\r\n    }\r\n\r\n    clearCofactor(): Point {\r\n      const { clearCofactor } = curveOpts;\r\n      if (cofactor === _1n) return this; // Fast-path\r\n      if (clearCofactor) return clearCofactor(Point, this) as Point;\r\n      return this.multiplyUnsafe(cofactor);\r\n    }\r\n\r\n    toBytes(isCompressed = true): Uint8Array {\r\n      abool('isCompressed', isCompressed);\r\n      this.assertValidity();\r\n      return toBytes(Point, this, isCompressed);\r\n    }\r\n\r\n    /** @deprecated use `toBytes` */\r\n    toRawBytes(isCompressed = true): Uint8Array {\r\n      return this.toBytes(isCompressed);\r\n    }\r\n\r\n    toHex(isCompressed = true): string {\r\n      return bytesToHex(this.toBytes(isCompressed));\r\n    }\r\n\r\n    toString() {\r\n      return `<Point ${this.is0() ? 'ZERO' : this.toHex()}>`;\r\n    }\r\n  }\r\n  const bits = Fn.BITS;\r\n  const wnaf = wNAF(Point, curveOpts.endo ? Math.ceil(bits / 2) : bits);\r\n  return Point;\r\n}\r\n\r\n// _legacyWeierstrass\r\n/** @deprecated use `weierstrassN` */\r\nexport function weierstrassPoints<T>(c: CurvePointsTypeWithLength<T>): CurvePointsRes<T> {\r\n  const { CURVE, curveOpts } = _weierstrass_legacy_opts_to_new(c);\r\n  const Point = weierstrassN(CURVE, curveOpts);\r\n  return _weierstrass_new_output_to_legacy(c, Point);\r\n}\r\n\r\n// Instance\r\nexport interface SignatureType {\r\n  readonly r: bigint;\r\n  readonly s: bigint;\r\n  readonly recovery?: number;\r\n  assertValidity(): void;\r\n  addRecoveryBit(recovery: number): RecoveredSignatureType;\r\n  hasHighS(): boolean;\r\n  normalizeS(): SignatureType;\r\n  recoverPublicKey(msgHash: Hex): ProjPointType<bigint>;\r\n  toCompactRawBytes(): Uint8Array;\r\n  toCompactHex(): string;\r\n  toDERRawBytes(): Uint8Array;\r\n  toDERHex(): string;\r\n  // toBytes(format?: string): Uint8Array;\r\n}\r\nexport type RecoveredSignatureType = SignatureType & {\r\n  readonly recovery: number;\r\n};\r\n// Static methods\r\nexport type SignatureConstructor = {\r\n  new (r: bigint, s: bigint, recovery?: number): SignatureType;\r\n  fromCompact(hex: Hex): SignatureType;\r\n  fromDER(hex: Hex): SignatureType;\r\n};\r\nexport type SignatureLike = { r: bigint; s: bigint };\r\nexport type PubKey = Hex | ProjPointType<bigint>;\r\n\r\nexport type CurveType = BasicWCurve<bigint> & {\r\n  hash: CHash; // CHash not FHash because we need outputLen for DRBG\r\n  hmac?: HmacFnSync;\r\n  randomBytes?: (bytesLength?: number) => Uint8Array;\r\n  lowS?: boolean;\r\n  bits2int?: (bytes: Uint8Array) => bigint;\r\n  bits2int_modN?: (bytes: Uint8Array) => bigint;\r\n};\r\n\r\n// Points start with byte 0x02 when y is even; otherwise 0x03\r\nfunction pprefix(hasEvenY: boolean): Uint8Array {\r\n  return Uint8Array.of(hasEvenY ? 0x02 : 0x03);\r\n}\r\n\r\nexport type CurveFn = {\r\n  CURVE: CurvePointsType<bigint>;\r\n  getPublicKey: (privateKey: PrivKey, isCompressed?: boolean) => Uint8Array;\r\n  getSharedSecret: (privateA: PrivKey, publicB: Hex, isCompressed?: boolean) => Uint8Array;\r\n  sign: (msgHash: Hex, privKey: PrivKey, opts?: SignOpts) => RecoveredSignatureType;\r\n  verify: (signature: Hex | SignatureLike, msgHash: Hex, publicKey: Hex, opts?: VerOpts) => boolean;\r\n  Point: ProjConstructor<bigint>;\r\n  /** @deprecated use `Point` */\r\n  ProjectivePoint: ProjConstructor<bigint>;\r\n  Signature: SignatureConstructor;\r\n  utils: {\r\n    normPrivateKeyToScalar: (key: PrivKey) => bigint;\r\n    isValidPrivateKey(privateKey: PrivKey): boolean;\r\n    randomPrivateKey: () => Uint8Array;\r\n    precompute: (windowSize?: number, point?: ProjPointType<bigint>) => ProjPointType<bigint>;\r\n  };\r\n};\r\n\r\nexport function ecdsa(\r\n  Point: ProjConstructor<bigint>,\r\n  ecdsaOpts: ECDSAOpts,\r\n  curveOpts: WeierstrassExtraOpts<bigint> = {}\r\n): ECDSA {\r\n  _validateObject(\r\n    ecdsaOpts,\r\n    { hash: 'function' },\r\n    {\r\n      hmac: 'function',\r\n      lowS: 'boolean',\r\n      randomBytes: 'function',\r\n      bits2int: 'function',\r\n      bits2int_modN: 'function',\r\n    }\r\n  );\r\n\r\n  const randomBytes_ = ecdsaOpts.randomBytes || randomBytes;\r\n  const hmac_: HmacFnSync =\r\n    ecdsaOpts.hmac ||\r\n    (((key, ...msgs) => hmac(ecdsaOpts.hash, key, concatBytes(...msgs))) satisfies HmacFnSync);\r\n\r\n  const { Fp, Fn } = Point;\r\n  const { ORDER: CURVE_ORDER, BITS: fnBits } = Fn;\r\n\r\n  function isBiggerThanHalfOrder(number: bigint) {\r\n    const HALF = CURVE_ORDER >> _1n;\r\n    return number > HALF;\r\n  }\r\n\r\n  function normalizeS(s: bigint) {\r\n    return isBiggerThanHalfOrder(s) ? Fn.neg(s) : s;\r\n  }\r\n  function aValidRS(title: string, num: bigint) {\r\n    if (!Fn.isValidNot0(num))\r\n      throw new Error(`invalid signature ${title}: out of range 1..CURVE.n`);\r\n  }\r\n\r\n  /**\r\n   * ECDSA signature with its (r, s) properties. Supports DER & compact representations.\r\n   */\r\n  class Signature implements SignatureType {\r\n    readonly r: bigint;\r\n    readonly s: bigint;\r\n    readonly recovery?: number;\r\n    constructor(r: bigint, s: bigint, recovery?: number) {\r\n      aValidRS('r', r); // r in [1..N-1]\r\n      aValidRS('s', s); // s in [1..N-1]\r\n      this.r = r;\r\n      this.s = s;\r\n      if (recovery != null) this.recovery = recovery;\r\n      Object.freeze(this);\r\n    }\r\n\r\n    // pair (bytes of r, bytes of s)\r\n    static fromCompact(hex: Hex) {\r\n      const L = Fn.BYTES;\r\n      const b = ensureBytes('compactSignature', hex, L * 2);\r\n      return new Signature(Fn.fromBytes(b.subarray(0, L)), Fn.fromBytes(b.subarray(L, L * 2)));\r\n    }\r\n\r\n    // DER encoded ECDSA signature\r\n    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script\r\n    static fromDER(hex: Hex) {\r\n      const { r, s } = DER.toSig(ensureBytes('DER', hex));\r\n      return new Signature(r, s);\r\n    }\r\n\r\n    /**\r\n     * @todo remove\r\n     * @deprecated\r\n     */\r\n    assertValidity(): void {}\r\n\r\n    addRecoveryBit(recovery: number): RecoveredSignature {\r\n      return new Signature(this.r, this.s, recovery) as RecoveredSignature;\r\n    }\r\n\r\n    // ProjPointType<bigint>\r\n    recoverPublicKey(msgHash: Hex): typeof Point.BASE {\r\n      const FIELD_ORDER = Fp.ORDER;\r\n      const { r, s, recovery: rec } = this;\r\n      if (rec == null || ![0, 1, 2, 3].includes(rec)) throw new Error('recovery id invalid');\r\n\r\n      // ECDSA recovery is hard for cofactor > 1 curves.\r\n      // In sign, `r = q.x mod n`, and here we recover q.x from r.\r\n      // While recovering q.x >= n, we need to add r+n for cofactor=1 curves.\r\n      // However, for cofactor>1, r+n may not get q.x:\r\n      // r+n*i would need to be done instead where i is unknown.\r\n      // To easily get i, we either need to:\r\n      // a. increase amount of valid recid values (4, 5...); OR\r\n      // b. prohibit non-prime-order signatures (recid > 1).\r\n      const hasCofactor = CURVE_ORDER * _2n < FIELD_ORDER;\r\n      if (hasCofactor && rec > 1) throw new Error('recovery id is ambiguous for h>1 curve');\r\n\r\n      const radj = rec === 2 || rec === 3 ? r + CURVE_ORDER : r;\r\n      if (!Fp.isValid(radj)) throw new Error('recovery id 2 or 3 invalid');\r\n      const x = Fp.toBytes(radj);\r\n      const R = Point.fromHex(concatBytes(pprefix((rec & 1) === 0), x));\r\n      const ir = Fn.inv(radj); // r^-1\r\n      const h = bits2int_modN(ensureBytes('msgHash', msgHash)); // Truncate hash\r\n      const u1 = Fn.create(-h * ir); // -hr^-1\r\n      const u2 = Fn.create(s * ir); // sr^-1\r\n      // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1). unsafe is fine: there is no private data.\r\n      const Q = Point.BASE.multiplyUnsafe(u1).add(R.multiplyUnsafe(u2));\r\n      if (Q.is0()) throw new Error('point at infinify');\r\n      Q.assertValidity();\r\n      return Q;\r\n    }\r\n\r\n    // Signatures should be low-s, to prevent malleability.\r\n    hasHighS(): boolean {\r\n      return isBiggerThanHalfOrder(this.s);\r\n    }\r\n\r\n    normalizeS() {\r\n      return this.hasHighS() ? new Signature(this.r, Fn.neg(this.s), this.recovery) : this;\r\n    }\r\n\r\n    toBytes(format: 'compact' | 'der') {\r\n      if (format === 'compact') return concatBytes(Fn.toBytes(this.r), Fn.toBytes(this.s));\r\n      if (format === 'der') return hexToBytes(DER.hexFromSig(this));\r\n      throw new Error('invalid format');\r\n    }\r\n\r\n    // DER-encoded\r\n    toDERRawBytes() {\r\n      return this.toBytes('der');\r\n    }\r\n    toDERHex() {\r\n      return bytesToHex(this.toBytes('der'));\r\n    }\r\n\r\n    // padded bytes of r, then padded bytes of s\r\n    toCompactRawBytes() {\r\n      return this.toBytes('compact');\r\n    }\r\n    toCompactHex() {\r\n      return bytesToHex(this.toBytes('compact'));\r\n    }\r\n  }\r\n  type RecoveredSignature = Signature & { recovery: number };\r\n\r\n  const normPrivateKeyToScalar = _legacyHelperNormPriv(\r\n    Fn,\r\n    curveOpts.allowedPrivateKeyLengths,\r\n    curveOpts.wrapPrivateKey\r\n  );\r\n\r\n  const utils = {\r\n    isValidPrivateKey(privateKey: PrivKey) {\r\n      try {\r\n        normPrivateKeyToScalar(privateKey);\r\n        return true;\r\n      } catch (error) {\r\n        return false;\r\n      }\r\n    },\r\n    normPrivateKeyToScalar: normPrivateKeyToScalar,\r\n\r\n    /**\r\n     * Produces cryptographically secure private key from random of size\r\n     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\r\n     */\r\n    randomPrivateKey: (): Uint8Array => {\r\n      const n = CURVE_ORDER;\r\n      return mapHashToField(randomBytes_(getMinHashLength(n)), n);\r\n    },\r\n\r\n    precompute(windowSize = 8, point = Point.BASE): typeof Point.BASE {\r\n      return point.precompute(windowSize, false);\r\n    },\r\n  };\r\n\r\n  /**\r\n   * Computes public key for a private key. Checks for validity of the private key.\r\n   * @param privateKey private key\r\n   * @param isCompressed whether to return compact (default), or full key\r\n   * @returns Public key, full when isCompressed=false; short when isCompressed=true\r\n   */\r\n  function getPublicKey(privateKey: PrivKey, isCompressed = true): Uint8Array {\r\n    return Point.fromPrivateKey(privateKey).toBytes(isCompressed);\r\n  }\r\n\r\n  /**\r\n   * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\r\n   */\r\n  function isProbPub(item: PrivKey | PubKey): boolean | undefined {\r\n    if (typeof item === 'bigint') return false;\r\n    if (item instanceof Point) return true;\r\n    const arr = ensureBytes('key', item);\r\n    const length = arr.length;\r\n    const L = Fp.BYTES;\r\n    const LC = L + 1; // e.g. 33 for 32\r\n    const LU = 2 * L + 1; // e.g. 65 for 32\r\n    if (curveOpts.allowedPrivateKeyLengths || Fn.BYTES === LC) {\r\n      return undefined;\r\n    } else {\r\n      return length === LC || length === LU;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * ECDH (Elliptic Curve Diffie Hellman).\r\n   * Computes shared public key from private key and public key.\r\n   * Checks: 1) private key validity 2) shared key is on-curve.\r\n   * Does NOT hash the result.\r\n   * @param privateA private key\r\n   * @param publicB different public key\r\n   * @param isCompressed whether to return compact (default), or full key\r\n   * @returns shared public key\r\n   */\r\n  function getSharedSecret(privateA: PrivKey, publicB: Hex, isCompressed = true): Uint8Array {\r\n    if (isProbPub(privateA) === true) throw new Error('first arg must be private key');\r\n    if (isProbPub(publicB) === false) throw new Error('second arg must be public key');\r\n    const b = Point.fromHex(publicB); // check for being on-curve\r\n    return b.multiply(normPrivateKeyToScalar(privateA)).toBytes(isCompressed);\r\n  }\r\n\r\n  // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\r\n  // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\r\n  // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\r\n  // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\r\n  const bits2int =\r\n    ecdsaOpts.bits2int ||\r\n    function (bytes: Uint8Array): bigint {\r\n      // Our custom check \"just in case\", for protection against DoS\r\n      if (bytes.length > 8192) throw new Error('input is too large');\r\n      // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\r\n      // for some cases, since bytes.length * 8 is not actual bitLength.\r\n      const num = bytesToNumberBE(bytes); // check for == u8 done here\r\n      const delta = bytes.length * 8 - fnBits; // truncate to nBitLength leftmost bits\r\n      return delta > 0 ? num >> BigInt(delta) : num;\r\n    };\r\n  const bits2int_modN =\r\n    ecdsaOpts.bits2int_modN ||\r\n    function (bytes: Uint8Array): bigint {\r\n      return Fn.create(bits2int(bytes)); // can't use bytesToNumberBE here\r\n    };\r\n  // NOTE: pads output with zero as per spec\r\n  const ORDER_MASK = bitMask(fnBits);\r\n  /**\r\n   * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.\r\n   */\r\n  function int2octets(num: bigint): Uint8Array {\r\n    // IMPORTANT: the check ensures working for case `Fn.BYTES != Fn.BITS * 8`\r\n    aInRange('num < 2^' + fnBits, num, _0n, ORDER_MASK);\r\n    return Fn.toBytes(num);\r\n  }\r\n\r\n  // Steps A, D of RFC6979 3.2\r\n  // Creates RFC6979 seed; converts msg/privKey to numbers.\r\n  // Used only in sign, not in verify.\r\n  // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order,\r\n  // this will be invalid at least for P521. Also it can be bigger for P224 + SHA256\r\n  function prepSig(msgHash: Hex, privateKey: PrivKey, opts = defaultSigOpts) {\r\n    if (['recovered', 'canonical'].some((k) => k in opts))\r\n      throw new Error('sign() legacy options not supported');\r\n    const { hash } = ecdsaOpts;\r\n    let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default\r\n    if (lowS == null) lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash\r\n    msgHash = ensureBytes('msgHash', msgHash);\r\n    validateSigVerOpts(opts);\r\n    if (prehash) msgHash = ensureBytes('prehashed msgHash', hash(msgHash));\r\n\r\n    // We can't later call bits2octets, since nested bits2int is broken for curves\r\n    // with fnBits % 8 !== 0. Because of that, we unwrap it here as int2octets call.\r\n    // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\r\n    const h1int = bits2int_modN(msgHash);\r\n    const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint\r\n    const seedArgs = [int2octets(d), int2octets(h1int)];\r\n    // extraEntropy. RFC6979 3.6: additional k' (optional).\r\n    if (ent != null && ent !== false) {\r\n      // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\r\n      const e = ent === true ? randomBytes_(Fp.BYTES) : ent; // generate random bytes OR pass as-is\r\n      seedArgs.push(ensureBytes('extraEntropy', e)); // check for being bytes\r\n    }\r\n    const seed = concatBytes(...seedArgs); // Step D of RFC6979 3.2\r\n    const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\r\n    // Converts signature params into point w r/s, checks result for validity.\r\n    // Can use scalar blinding b^-1(bm + bdr) where b ‚àà [1,q‚àí1] according to\r\n    // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\r\n    // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\r\n    function k2sig(kBytes: Uint8Array): RecoveredSignature | undefined {\r\n      // RFC 6979 Section 3.2, step 3: k = bits2int(T)\r\n      // Important: all mod() calls here must be done over N\r\n      const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\r\n      if (!Fn.isValidNot0(k)) return; // Valid scalars (including k) must be in 1..N-1\r\n      const ik = Fn.inv(k); // k^-1 mod n\r\n      const q = Point.BASE.multiply(k).toAffine(); // q = Gk\r\n      const r = Fn.create(q.x); // r = q.x mod n\r\n      if (r === _0n) return;\r\n      const s = Fn.create(ik * Fn.create(m + r * d)); // Not using blinding here, see comment above\r\n      if (s === _0n) return;\r\n      let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\r\n      let normS = s;\r\n      if (lowS && isBiggerThanHalfOrder(s)) {\r\n        normS = normalizeS(s); // if lowS was passed, ensure s is always\r\n        recovery ^= 1; // // in the bottom half of N\r\n      }\r\n      return new Signature(r, normS, recovery) as RecoveredSignature; // use normS, not s\r\n    }\r\n    return { seed, k2sig };\r\n  }\r\n  const defaultSigOpts: SignOpts = { lowS: ecdsaOpts.lowS, prehash: false };\r\n  const defaultVerOpts: VerOpts = { lowS: ecdsaOpts.lowS, prehash: false };\r\n\r\n  /**\r\n   * Signs message hash with a private key.\r\n   * ```\r\n   * sign(m, d, k) where\r\n   *   (x, y) = G √ó k\r\n   *   r = x mod n\r\n   *   s = (m + dr)/k mod n\r\n   * ```\r\n   * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.\r\n   * @param privKey private key\r\n   * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.\r\n   * @returns signature with recovery param\r\n   */\r\n  function sign(msgHash: Hex, privKey: PrivKey, opts = defaultSigOpts): RecoveredSignature {\r\n    const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.\r\n    const drbg = createHmacDrbg<RecoveredSignature>(ecdsaOpts.hash.outputLen, Fn.BYTES, hmac_);\r\n    return drbg(seed, k2sig); // Steps B, C, D, E, F, G\r\n  }\r\n\r\n  // Enable precomputes. Slows down first publicKey computation by 20ms.\r\n  Point.BASE.precompute(8);\r\n\r\n  /**\r\n   * Verifies a signature against message hash and public key.\r\n   * Rejects lowS signatures by default: to override,\r\n   * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\r\n   *\r\n   * ```\r\n   * verify(r, s, h, P) where\r\n   *   U1 = hs^-1 mod n\r\n   *   U2 = rs^-1 mod n\r\n   *   R = U1‚ãÖG - U2‚ãÖP\r\n   *   mod(R.x, n) == r\r\n   * ```\r\n   */\r\n  function verify(\r\n    signature: Hex | SignatureLike,\r\n    msgHash: Hex,\r\n    publicKey: Hex,\r\n    opts = defaultVerOpts\r\n  ): boolean {\r\n    const sg = signature;\r\n    msgHash = ensureBytes('msgHash', msgHash);\r\n    publicKey = ensureBytes('publicKey', publicKey);\r\n\r\n    // Verify opts\r\n    validateSigVerOpts(opts);\r\n    const { lowS, prehash, format } = opts;\r\n\r\n    // TODO: remove\r\n    if ('strict' in opts) throw new Error('options.strict was renamed to lowS');\r\n\r\n    if (format !== undefined && !['compact', 'der', 'js'].includes(format))\r\n      throw new Error('format must be \"compact\", \"der\" or \"js\"');\r\n    const isHex = typeof sg === 'string' || isBytes(sg);\r\n    const isObj =\r\n      !isHex &&\r\n      !format &&\r\n      typeof sg === 'object' &&\r\n      sg !== null &&\r\n      typeof sg.r === 'bigint' &&\r\n      typeof sg.s === 'bigint';\r\n    if (!isHex && !isObj)\r\n      throw new Error('invalid signature, expected Uint8Array, hex string or Signature instance');\r\n    let _sig: Signature | undefined = undefined;\r\n    let P: ProjPointType<bigint>;\r\n\r\n    // deduce signature format\r\n    try {\r\n      // if (format === 'js') {\r\n      //   if (sg != null && !isBytes(sg)) _sig = new Signature(sg.r, sg.s);\r\n      // } else if (format === 'compact') {\r\n      //   _sig = Signature.fromCompact(sg);\r\n      // } else if (format === 'der') {\r\n      //   _sig = Signature.fromDER(sg);\r\n      // } else {\r\n      //   throw new Error('invalid format');\r\n      // }\r\n      if (isObj) {\r\n        if (format === undefined || format === 'js') {\r\n          _sig = new Signature(sg.r, sg.s);\r\n        } else {\r\n          throw new Error('invalid format');\r\n        }\r\n      }\r\n      if (isHex) {\r\n        // TODO: remove this malleable check\r\n        // Signature can be represented in 2 ways: compact (2*Fn.BYTES) & DER (variable-length).\r\n        // Since DER can also be 2*Fn.BYTES bytes, we check for it first.\r\n        try {\r\n          if (format !== 'compact') _sig = Signature.fromDER(sg);\r\n        } catch (derError) {\r\n          if (!(derError instanceof DER.Err)) throw derError;\r\n        }\r\n        if (!_sig && format !== 'der') _sig = Signature.fromCompact(sg);\r\n      }\r\n      P = Point.fromHex(publicKey);\r\n    } catch (error) {\r\n      return false;\r\n    }\r\n    if (!_sig) return false;\r\n    if (lowS && _sig.hasHighS()) return false;\r\n    // todo: optional.hash => hash\r\n    if (prehash) msgHash = ecdsaOpts.hash(msgHash);\r\n    const { r, s } = _sig;\r\n    const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element\r\n    const is = Fn.inv(s); // s^-1\r\n    const u1 = Fn.create(h * is); // u1 = hs^-1 mod n\r\n    const u2 = Fn.create(r * is); // u2 = rs^-1 mod n\r\n    const R = Point.BASE.multiplyUnsafe(u1).add(P.multiplyUnsafe(u2));\r\n    if (R.is0()) return false;\r\n    const v = Fn.create(R.x); // v = r.x mod n\r\n    return v === r;\r\n  }\r\n  // TODO: clarify API for cloning .clone({hash: sha512}) ? .createWith({hash: sha512})?\r\n  // const clone = (hash: CHash): ECDSA => ecdsa(Point, { ...ecdsaOpts, ...getHash(hash) }, curveOpts);\r\n  return Object.freeze({\r\n    getPublicKey,\r\n    getSharedSecret,\r\n    sign,\r\n    verify,\r\n    utils,\r\n    Point,\r\n    Signature,\r\n  });\r\n}\r\n\r\nexport type WsPointComposed<T> = {\r\n  CURVE: WeierstrassOpts<T>;\r\n  curveOpts: WeierstrassExtraOpts<T>;\r\n};\r\nexport type WsComposed = {\r\n  CURVE: WeierstrassOpts<bigint>;\r\n  curveOpts: WeierstrassExtraOpts<bigint>;\r\n  ecdsaOpts: ECDSAOpts;\r\n};\r\nfunction _weierstrass_legacy_opts_to_new<T>(c: CurvePointsType<T>): WsPointComposed<T> {\r\n  const CURVE: WeierstrassOpts<T> = {\r\n    a: c.a,\r\n    b: c.b,\r\n    p: c.Fp.ORDER,\r\n    n: c.n,\r\n    h: c.h,\r\n    Gx: c.Gx,\r\n    Gy: c.Gy,\r\n  };\r\n  const Fp = c.Fp;\r\n  const Fn = Field(CURVE.n, c.nBitLength);\r\n  const curveOpts: WeierstrassExtraOpts<T> = {\r\n    Fp,\r\n    Fn,\r\n    allowedPrivateKeyLengths: c.allowedPrivateKeyLengths,\r\n    allowInfinityPoint: c.allowInfinityPoint,\r\n    endo: c.endo,\r\n    wrapPrivateKey: c.wrapPrivateKey,\r\n    isTorsionFree: c.isTorsionFree,\r\n    clearCofactor: c.clearCofactor,\r\n    fromBytes: c.fromBytes,\r\n    toBytes: c.toBytes,\r\n  };\r\n  return { CURVE, curveOpts };\r\n}\r\nfunction _ecdsa_legacy_opts_to_new(c: CurveType): WsComposed {\r\n  const { CURVE, curveOpts } = _weierstrass_legacy_opts_to_new(c);\r\n  const ecdsaOpts: ECDSAOpts = {\r\n    hash: c.hash,\r\n    hmac: c.hmac,\r\n    randomBytes: c.randomBytes,\r\n    lowS: c.lowS,\r\n    bits2int: c.bits2int,\r\n    bits2int_modN: c.bits2int_modN,\r\n  };\r\n  return { CURVE, curveOpts, ecdsaOpts };\r\n}\r\nfunction _weierstrass_new_output_to_legacy<T>(\r\n  c: CurvePointsType<T>,\r\n  Point: ProjConstructor<T>\r\n): CurvePointsRes<T> {\r\n  const { Fp, Fn } = Point;\r\n  // TODO: remove\r\n  function isWithinCurveOrder(num: bigint): boolean {\r\n    return inRange(num, _1n, Fn.ORDER);\r\n  }\r\n  const weierstrassEquation = _legacyHelperEquat(Fp, c.a, c.b);\r\n  const normPrivateKeyToScalar = _legacyHelperNormPriv(\r\n    Fn,\r\n    c.allowedPrivateKeyLengths,\r\n    c.wrapPrivateKey\r\n  );\r\n  return Object.assign(\r\n    {},\r\n    {\r\n      CURVE: c,\r\n      Point: Point,\r\n      ProjectivePoint: Point,\r\n      normPrivateKeyToScalar,\r\n      weierstrassEquation,\r\n      isWithinCurveOrder,\r\n    }\r\n  );\r\n}\r\nfunction _ecdsa_new_output_to_legacy(c: CurveType, ecdsa: ECDSA): CurveFn {\r\n  return Object.assign({}, ecdsa, {\r\n    ProjectivePoint: ecdsa.Point,\r\n    CURVE: c,\r\n  });\r\n}\r\n\r\n// _ecdsa_legacy\r\nexport function weierstrass(c: CurveType): CurveFn {\r\n  const { CURVE, curveOpts, ecdsaOpts } = _ecdsa_legacy_opts_to_new(c);\r\n  const Point = weierstrassN(CURVE, curveOpts);\r\n  const signs = ecdsa(Point, ecdsaOpts, curveOpts);\r\n  return _ecdsa_new_output_to_legacy(c, signs);\r\n}\r\n\r\n/**\r\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\r\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\r\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\r\n * b = False and y = sqrt(Z * (u / v)) otherwise.\r\n * @param Fp\r\n * @param Z\r\n * @returns\r\n */\r\nexport function SWUFpSqrtRatio<T>(\r\n  Fp: IField<T>,\r\n  Z: T\r\n): (u: T, v: T) => { isValid: boolean; value: T } {\r\n  // Generic implementation\r\n  const q = Fp.ORDER;\r\n  let l = _0n;\r\n  for (let o = q - _1n; o % _2n === _0n; o /= _2n) l += _1n;\r\n  const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\r\n  // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\r\n  // 2n ** c1 == 2n << (c1-1)\r\n  const _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);\r\n  const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\r\n  const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\r\n  const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\r\n  const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\r\n  const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\r\n  const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\r\n  const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\r\n  let sqrtRatio = (u: T, v: T): { isValid: boolean; value: T } => {\r\n    let tv1 = c6; // 1. tv1 = c6\r\n    let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\r\n    let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\r\n    tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\r\n    let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\r\n    tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\r\n    tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\r\n    tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\r\n    tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\r\n    let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\r\n    tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\r\n    let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\r\n    tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\r\n    tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\r\n    tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\r\n    tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\r\n    // 17. for i in (c1, c1 - 1, ..., 2):\r\n    for (let i = c1; i > _1n; i--) {\r\n      let tv5 = i - _2n; // 18.    tv5 = i - 2\r\n      tv5 = _2n << (tv5 - _1n); // 19.    tv5 = 2^tv5\r\n      let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\r\n      const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\r\n      tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\r\n      tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\r\n      tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\r\n      tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\r\n      tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\r\n    }\r\n    return { isValid: isQR, value: tv3 };\r\n  };\r\n  if (Fp.ORDER % _4n === _3n) {\r\n    // sqrt_ratio_3mod4(u, v)\r\n    const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\r\n    const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\r\n    sqrtRatio = (u: T, v: T) => {\r\n      let tv1 = Fp.sqr(v); // 1. tv1 = v^2\r\n      const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\r\n      tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\r\n      let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\r\n      y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\r\n      const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\r\n      const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\r\n      const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\r\n      let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\r\n      return { isValid: isQR, value: y }; // 11. return (isQR, y) isQR ? y : y*c2\r\n    };\r\n  }\r\n  // No curves uses that\r\n  // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\r\n  return sqrtRatio;\r\n}\r\n/**\r\n * Simplified Shallue-van de Woestijne-Ulas Method\r\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\r\n */\r\nexport function mapToCurveSimpleSWU<T>(\r\n  Fp: IField<T>,\r\n  opts: {\r\n    A: T;\r\n    B: T;\r\n    Z: T;\r\n  }\r\n): (u: T) => { x: T; y: T } {\r\n  validateField(Fp);\r\n  const { A, B, Z } = opts;\r\n  if (!Fp.isValid(A) || !Fp.isValid(B) || !Fp.isValid(Z))\r\n    throw new Error('mapToCurveSimpleSWU: invalid opts');\r\n  const sqrtRatio = SWUFpSqrtRatio(Fp, Z);\r\n  if (!Fp.isOdd) throw new Error('Field does not have .isOdd()');\r\n  // Input: u, an element of F.\r\n  // Output: (x, y), a point on E.\r\n  return (u: T): { x: T; y: T } => {\r\n    // prettier-ignore\r\n    let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\r\n    tv1 = Fp.sqr(u); // 1.  tv1 = u^2\r\n    tv1 = Fp.mul(tv1, Z); // 2.  tv1 = Z * tv1\r\n    tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\r\n    tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\r\n    tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\r\n    tv3 = Fp.mul(tv3, B); // 6.  tv3 = B * tv3\r\n    tv4 = Fp.cmov(Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\r\n    tv4 = Fp.mul(tv4, A); // 8.  tv4 = A * tv4\r\n    tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\r\n    tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\r\n    tv5 = Fp.mul(tv6, A); // 11. tv5 = A * tv6\r\n    tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\r\n    tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\r\n    tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\r\n    tv5 = Fp.mul(tv6, B); // 15. tv5 = B * tv6\r\n    tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\r\n    x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\r\n    const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\r\n    y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\r\n    y = Fp.mul(y, value); // 20.   y = y * y1\r\n    x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\r\n    y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\r\n    const e1 = Fp.isOdd!(u) === Fp.isOdd!(y); // 23.  e1 = sgn0(u) == sgn0(y)\r\n    y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\r\n    const tv4_inv = FpInvertBatch(Fp, [tv4], true)[0];\r\n    x = Fp.mul(x, tv4_inv); // 25.   x = x / tv4\r\n    return { x, y };\r\n  };\r\n}\r\n", "/**\r\n * Utilities for short weierstrass curves, combined with noble-hashes.\r\n * @module\r\n */\r\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\r\nimport { type CurveFn, type CurveType, weierstrass } from './abstract/weierstrass.ts';\r\nimport type { CHash } from './utils.ts';\r\n\r\n/** connects noble-curves to noble-hashes */\r\nexport function getHash(hash: CHash): { hash: CHash } {\r\n  return { hash };\r\n}\r\n/** Same API as @noble/hashes, with ability to create curve with custom hash */\r\nexport type CurveDef = Readonly<Omit<CurveType, 'hash'>>;\r\nexport type CurveFnWithCreate = CurveFn & { create: (hash: CHash) => CurveFn };\r\n\r\nexport function createCurve(curveDef: CurveDef, defHash: CHash): CurveFnWithCreate {\r\n  const create = (hash: CHash): CurveFn => weierstrass({ ...curveDef, hash: hash });\r\n  return { ...create(defHash), create };\r\n}\r\n", "/**\r\n * hash-to-curve from RFC 9380.\r\n * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F.\r\n * https://www.rfc-editor.org/rfc/rfc9380\r\n * @module\r\n */\r\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\r\nimport type { CHash } from '../utils.ts';\r\nimport {\r\n  _validateObject,\r\n  abytes,\r\n  bytesToNumberBE,\r\n  concatBytes,\r\n  isBytes,\r\n  isHash,\r\n  utf8ToBytes,\r\n} from '../utils.ts';\r\nimport type { AffinePoint, Group, GroupConstructor } from './curve.ts';\r\nimport { FpInvertBatch, type IField, mod } from './modular.ts';\r\n\r\nexport type UnicodeOrBytes = string | Uint8Array;\r\n\r\n/**\r\n * * `DST` is a domain separation tag, defined in section 2.2.5\r\n * * `p` characteristic of F, where F is a finite field of characteristic p and order q = p^m\r\n * * `m` is extension degree (1 for prime fields)\r\n * * `k` is the target security target in bits (e.g. 128), from section 5.1\r\n * * `expand` is `xmd` (SHA2, SHA3, BLAKE) or `xof` (SHAKE, BLAKE-XOF)\r\n * * `hash` conforming to `utils.CHash` interface, with `outputLen` / `blockLen` props\r\n */\r\nexport type H2COpts = {\r\n  DST: UnicodeOrBytes;\r\n  expand: 'xmd' | 'xof';\r\n  hash: CHash;\r\n  p: bigint;\r\n  m: number;\r\n  k: number;\r\n};\r\nexport type H2CHashOpts = {\r\n  expand: 'xmd' | 'xof';\r\n  hash: CHash;\r\n};\r\n// todo: remove\r\nexport type Opts = H2COpts;\r\n\r\n// Octet Stream to Integer. \"spec\" implementation of os2ip is 2.5x slower vs bytesToNumberBE.\r\nconst os2ip = bytesToNumberBE;\r\n\r\n// Integer to Octet Stream (numberToBytesBE)\r\nfunction i2osp(value: number, length: number): Uint8Array {\r\n  anum(value);\r\n  anum(length);\r\n  if (value < 0 || value >= 1 << (8 * length)) throw new Error('invalid I2OSP input: ' + value);\r\n  const res = Array.from({ length }).fill(0) as number[];\r\n  for (let i = length - 1; i >= 0; i--) {\r\n    res[i] = value & 0xff;\r\n    value >>>= 8;\r\n  }\r\n  return new Uint8Array(res);\r\n}\r\n\r\nfunction strxor(a: Uint8Array, b: Uint8Array): Uint8Array {\r\n  const arr = new Uint8Array(a.length);\r\n  for (let i = 0; i < a.length; i++) {\r\n    arr[i] = a[i] ^ b[i];\r\n  }\r\n  return arr;\r\n}\r\n\r\nfunction anum(item: unknown): void {\r\n  if (!Number.isSafeInteger(item)) throw new Error('number expected');\r\n}\r\n\r\n/**\r\n * Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits.\r\n * [RFC 9380 5.3.1](https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1).\r\n */\r\nexport function expand_message_xmd(\r\n  msg: Uint8Array,\r\n  DST: Uint8Array,\r\n  lenInBytes: number,\r\n  H: CHash\r\n): Uint8Array {\r\n  abytes(msg);\r\n  abytes(DST);\r\n  anum(lenInBytes);\r\n  // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\r\n  if (DST.length > 255) DST = H(concatBytes(utf8ToBytes('H2C-OVERSIZE-DST-'), DST));\r\n  const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;\r\n  const ell = Math.ceil(lenInBytes / b_in_bytes);\r\n  if (lenInBytes > 65535 || ell > 255) throw new Error('expand_message_xmd: invalid lenInBytes');\r\n  const DST_prime = concatBytes(DST, i2osp(DST.length, 1));\r\n  const Z_pad = i2osp(0, r_in_bytes);\r\n  const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str\r\n  const b = new Array<Uint8Array>(ell);\r\n  const b_0 = H(concatBytes(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));\r\n  b[0] = H(concatBytes(b_0, i2osp(1, 1), DST_prime));\r\n  for (let i = 1; i <= ell; i++) {\r\n    const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];\r\n    b[i] = H(concatBytes(...args));\r\n  }\r\n  const pseudo_random_bytes = concatBytes(...b);\r\n  return pseudo_random_bytes.slice(0, lenInBytes);\r\n}\r\n\r\n/**\r\n * Produces a uniformly random byte string using an extendable-output function (XOF) H.\r\n * 1. The collision resistance of H MUST be at least k bits.\r\n * 2. H MUST be an XOF that has been proved indifferentiable from\r\n *    a random oracle under a reasonable cryptographic assumption.\r\n * [RFC 9380 5.3.2](https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2).\r\n */\r\nexport function expand_message_xof(\r\n  msg: Uint8Array,\r\n  DST: Uint8Array,\r\n  lenInBytes: number,\r\n  k: number,\r\n  H: CHash\r\n): Uint8Array {\r\n  abytes(msg);\r\n  abytes(DST);\r\n  anum(lenInBytes);\r\n  // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\r\n  // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));\r\n  if (DST.length > 255) {\r\n    const dkLen = Math.ceil((2 * k) / 8);\r\n    DST = H.create({ dkLen }).update(utf8ToBytes('H2C-OVERSIZE-DST-')).update(DST).digest();\r\n  }\r\n  if (lenInBytes > 65535 || DST.length > 255)\r\n    throw new Error('expand_message_xof: invalid lenInBytes');\r\n  return (\r\n    H.create({ dkLen: lenInBytes })\r\n      .update(msg)\r\n      .update(i2osp(lenInBytes, 2))\r\n      // 2. DST_prime = DST || I2OSP(len(DST), 1)\r\n      .update(DST)\r\n      .update(i2osp(DST.length, 1))\r\n      .digest()\r\n  );\r\n}\r\n\r\n/**\r\n * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F.\r\n * [RFC 9380 5.2](https://www.rfc-editor.org/rfc/rfc9380#section-5.2).\r\n * @param msg a byte string containing the message to hash\r\n * @param count the number of elements of F to output\r\n * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above\r\n * @returns [u_0, ..., u_(count - 1)], a list of field elements.\r\n */\r\nexport function hash_to_field(msg: Uint8Array, count: number, options: H2COpts): bigint[][] {\r\n  _validateObject(options, {\r\n    p: 'bigint',\r\n    m: 'number',\r\n    k: 'number',\r\n    hash: 'function',\r\n  });\r\n  const { p, k, m, hash, expand, DST: _DST } = options;\r\n  if (!isBytes(_DST) && typeof _DST !== 'string')\r\n    throw new Error('DST must be string or uint8array');\r\n  if (!isHash(options.hash)) throw new Error('expected valid hash');\r\n  abytes(msg);\r\n  anum(count);\r\n  const DST = typeof _DST === 'string' ? utf8ToBytes(_DST) : _DST;\r\n  const log2p = p.toString(2).length;\r\n  const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above\r\n  const len_in_bytes = count * m * L;\r\n  let prb; // pseudo_random_bytes\r\n  if (expand === 'xmd') {\r\n    prb = expand_message_xmd(msg, DST, len_in_bytes, hash);\r\n  } else if (expand === 'xof') {\r\n    prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);\r\n  } else if (expand === '_internal_pass') {\r\n    // for internal tests only\r\n    prb = msg;\r\n  } else {\r\n    throw new Error('expand must be \"xmd\" or \"xof\"');\r\n  }\r\n  const u = new Array(count);\r\n  for (let i = 0; i < count; i++) {\r\n    const e = new Array(m);\r\n    for (let j = 0; j < m; j++) {\r\n      const elm_offset = L * (j + i * m);\r\n      const tv = prb.subarray(elm_offset, elm_offset + L);\r\n      e[j] = mod(os2ip(tv), p);\r\n    }\r\n    u[i] = e;\r\n  }\r\n  return u;\r\n}\r\n\r\nexport type XY<T> = (x: T, y: T) => { x: T; y: T };\r\nexport type XYRatio<T> = [T[], T[], T[], T[]]; // xn/xd, yn/yd\r\nexport function isogenyMap<T, F extends IField<T>>(field: F, map: XYRatio<T>): XY<T> {\r\n  // Make same order as in spec\r\n  const coeff = map.map((i) => Array.from(i).reverse());\r\n  return (x: T, y: T) => {\r\n    const [xn, xd, yn, yd] = coeff.map((val) =>\r\n      val.reduce((acc, i) => field.add(field.mul(acc, x), i))\r\n    );\r\n    // 6.6.3\r\n    // Exceptional cases of iso_map are inputs that cause the denominator of\r\n    // either rational function to evaluate to zero; such cases MUST return\r\n    // the identity point on E.\r\n    const [xd_inv, yd_inv] = FpInvertBatch(field, [xd, yd], true);\r\n    x = field.mul(xn, xd_inv); // xNum / xDen\r\n    y = field.mul(y, field.mul(yn, yd_inv)); // y * (yNum / yDev)\r\n    return { x, y };\r\n  };\r\n}\r\n\r\n/** Point interface, which curves must implement to work correctly with the module. */\r\nexport interface H2CPoint<T> extends Group<H2CPoint<T>> {\r\n  add(rhs: H2CPoint<T>): H2CPoint<T>;\r\n  toAffine(iz?: bigint): AffinePoint<T>;\r\n  clearCofactor(): H2CPoint<T>;\r\n  assertValidity(): void;\r\n}\r\n\r\nexport interface H2CPointConstructor<T> extends GroupConstructor<H2CPoint<T>> {\r\n  fromAffine(ap: AffinePoint<T>): H2CPoint<T>;\r\n}\r\n\r\nexport type MapToCurve<T> = (scalar: bigint[]) => AffinePoint<T>;\r\n\r\n// Separated from initialization opts, so users won't accidentally change per-curve parameters\r\n// (changing DST is ok!)\r\nexport type htfBasicOpts = { DST: UnicodeOrBytes };\r\nexport type H2CMethod<T> = (msg: Uint8Array, options?: htfBasicOpts) => H2CPoint<T>;\r\n// TODO: remove\r\nexport type HTFMethod<T> = H2CMethod<T>;\r\nexport type MapMethod<T> = (scalars: bigint[]) => H2CPoint<T>;\r\n/**\r\n * RFC 9380 methods, with cofactor clearing. See https://www.rfc-editor.org/rfc/rfc9380#section-3.\r\n *\r\n * * hashToCurve: `map(hash(input))`, encodes RANDOM bytes to curve (WITH hashing)\r\n * * encodeToCurve: `map(hash(input))`, encodes NON-UNIFORM bytes to curve (WITH hashing)\r\n * * mapToCurve: `map(scalars)`, encodes NON-UNIFORM scalars to curve (NO hashing)\r\n */\r\nexport type H2CHasher<T> = {\r\n  hashToCurve: H2CMethod<T>;\r\n  encodeToCurve: H2CMethod<T>;\r\n  mapToCurve: MapMethod<T>;\r\n  defaults: H2COpts & { encodeDST?: UnicodeOrBytes };\r\n};\r\n// TODO: remove\r\nexport type Hasher<T> = H2CHasher<T>;\r\n\r\n/** Creates hash-to-curve methods from EC Point and mapToCurve function. See {@link H2CHasher}. */\r\nexport function createHasher<T>(\r\n  Point: H2CPointConstructor<T>,\r\n  mapToCurve: MapToCurve<T>,\r\n  defaults: H2COpts & { encodeDST?: UnicodeOrBytes }\r\n): H2CHasher<T> {\r\n  if (typeof mapToCurve !== 'function') throw new Error('mapToCurve() must be defined');\r\n  function map(num: bigint[]) {\r\n    return Point.fromAffine(mapToCurve(num));\r\n  }\r\n  function clear(initial: H2CPoint<T>) {\r\n    const P = initial.clearCofactor();\r\n    if (P.equals(Point.ZERO)) return Point.ZERO; // zero will throw in assert\r\n    P.assertValidity();\r\n    return P;\r\n  }\r\n\r\n  return {\r\n    defaults,\r\n    hashToCurve(msg: Uint8Array, options?: htfBasicOpts): H2CPoint<T> {\r\n      const dst = defaults.DST ? defaults.DST : {};\r\n      const opts = Object.assign({}, defaults, dst, options);\r\n      const u = hash_to_field(msg, 2, opts);\r\n      const u0 = map(u[0]);\r\n      const u1 = map(u[1]);\r\n      return clear(u0.add(u1));\r\n    },\r\n    encodeToCurve(msg: Uint8Array, options?: htfBasicOpts): H2CPoint<T> {\r\n      const dst = defaults.encodeDST ? defaults.encodeDST : {};\r\n      const opts = Object.assign({}, defaults, dst, options);\r\n      const u = hash_to_field(msg, 1, opts);\r\n      return clear(map(u[0]));\r\n    },\r\n    /** See {@link H2CHasher} */\r\n    mapToCurve(scalars: bigint[]): H2CPoint<T> {\r\n      if (!Array.isArray(scalars)) throw new Error('expected array of bigints');\r\n      for (const i of scalars)\r\n        if (typeof i !== 'bigint') throw new Error('expected array of bigints');\r\n      return clear(map(scalars));\r\n    },\r\n  };\r\n}\r\n", "/**\r\n * SECG secp256k1. See [pdf](https://www.secg.org/sec2-v2.pdf).\r\n *\r\n * Belongs to Koblitz curves: it has efficiently-computable GLV endomorphism œà,\r\n * check out {@link EndomorphismOpts}. Seems to be rigid (not backdoored).\r\n * @module\r\n */\r\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\r\nimport { sha256 } from '@noble/hashes/sha2.js';\r\nimport { randomBytes } from '@noble/hashes/utils.js';\r\nimport { createCurve, type CurveFnWithCreate } from './_shortw_utils.ts';\r\nimport {\r\n  createHasher,\r\n  type H2CHasher,\r\n  type H2CMethod,\r\n  isogenyMap,\r\n} from './abstract/hash-to-curve.ts';\r\nimport { Field, mod, pow2 } from './abstract/modular.ts';\r\nimport {\r\n  type EndomorphismOpts,\r\n  mapToCurveSimpleSWU,\r\n  type ProjPointType as PointType,\r\n  type WeierstrassOpts,\r\n} from './abstract/weierstrass.ts';\r\nimport type { Hex, PrivKey } from './utils.ts';\r\nimport {\r\n  aInRange,\r\n  bytesToNumberBE,\r\n  concatBytes,\r\n  ensureBytes,\r\n  inRange,\r\n  numberToBytesBE,\r\n} from './utils.ts';\r\n\r\n// Seems like generator was produced from some seed:\r\n// `Point.BASE.multiply(Point.Fn.inv(2n, N)).toAffine().x`\r\n// // gives short x 0x3b78ce563f89a0ed9414f5aa28ad0d96d6795f9c63n\r\nconst secp256k1_CURVE: WeierstrassOpts<bigint> = {\r\n  p: BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f'),\r\n  n: BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141'),\r\n  h: BigInt(1),\r\n  a: BigInt(0),\r\n  b: BigInt(7),\r\n  Gx: BigInt('0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),\r\n  Gy: BigInt('0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8'),\r\n};\r\nconst _0n = BigInt(0);\r\nconst _1n = BigInt(1);\r\nconst _2n = BigInt(2);\r\nconst divNearest = (a: bigint, b: bigint) => (a + b / _2n) / b;\r\n\r\n/**\r\n * ‚àön = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.\r\n * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]\r\n */\r\nfunction sqrtMod(y: bigint): bigint {\r\n  const P = secp256k1_CURVE.p;\r\n  // prettier-ignore\r\n  const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);\r\n  // prettier-ignore\r\n  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);\r\n  const b2 = (y * y * y) % P; // x^3, 11\r\n  const b3 = (b2 * b2 * y) % P; // x^7\r\n  const b6 = (pow2(b3, _3n, P) * b3) % P;\r\n  const b9 = (pow2(b6, _3n, P) * b3) % P;\r\n  const b11 = (pow2(b9, _2n, P) * b2) % P;\r\n  const b22 = (pow2(b11, _11n, P) * b11) % P;\r\n  const b44 = (pow2(b22, _22n, P) * b22) % P;\r\n  const b88 = (pow2(b44, _44n, P) * b44) % P;\r\n  const b176 = (pow2(b88, _88n, P) * b88) % P;\r\n  const b220 = (pow2(b176, _44n, P) * b44) % P;\r\n  const b223 = (pow2(b220, _3n, P) * b3) % P;\r\n  const t1 = (pow2(b223, _23n, P) * b22) % P;\r\n  const t2 = (pow2(t1, _6n, P) * b2) % P;\r\n  const root = pow2(t2, _2n, P);\r\n  if (!Fpk1.eql(Fpk1.sqr(root), y)) throw new Error('Cannot find square root');\r\n  return root;\r\n}\r\n\r\nconst Fpk1 = Field(secp256k1_CURVE.p, undefined, undefined, { sqrt: sqrtMod });\r\n\r\n/**\r\n * secp256k1 curve, ECDSA and ECDH methods.\r\n *\r\n * Field: `2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n`\r\n *\r\n * @example\r\n * ```js\r\n * import { secp256k1 } from '@noble/curves/secp256k1';\r\n * const priv = secp256k1.utils.randomPrivateKey();\r\n * const pub = secp256k1.getPublicKey(priv);\r\n * const msg = new Uint8Array(32).fill(1); // message hash (not message) in ecdsa\r\n * const sig = secp256k1.sign(msg, priv); // `{prehash: true}` option is available\r\n * const isValid = secp256k1.verify(sig, msg, pub) === true;\r\n * ```\r\n */\r\nexport const secp256k1: CurveFnWithCreate = createCurve(\r\n  {\r\n    ...secp256k1_CURVE,\r\n    Fp: Fpk1,\r\n    lowS: true, // Allow only low-S signatures by default in sign() and verify()\r\n    endo: {\r\n      // Endomorphism, see above\r\n      beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\r\n      splitScalar: (k: bigint) => {\r\n        const n = secp256k1_CURVE.n;\r\n        const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');\r\n        const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');\r\n        const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');\r\n        const b2 = a1;\r\n        const POW_2_128 = BigInt('0x100000000000000000000000000000000'); // (2n**128n).toString(16)\r\n\r\n        const c1 = divNearest(b2 * k, n);\r\n        const c2 = divNearest(-b1 * k, n);\r\n        let k1 = mod(k - c1 * a1 - c2 * a2, n);\r\n        let k2 = mod(-c1 * b1 - c2 * b2, n);\r\n        const k1neg = k1 > POW_2_128;\r\n        const k2neg = k2 > POW_2_128;\r\n        if (k1neg) k1 = n - k1;\r\n        if (k2neg) k2 = n - k2;\r\n        if (k1 > POW_2_128 || k2 > POW_2_128) {\r\n          throw new Error('splitScalar: Endomorphism failed, k=' + k);\r\n        }\r\n        return { k1neg, k1, k2neg, k2 };\r\n      },\r\n    } satisfies EndomorphismOpts,\r\n  },\r\n  sha256\r\n);\r\n\r\n// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.\r\n// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\r\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */\r\nconst TAGGED_HASH_PREFIXES: { [tag: string]: Uint8Array } = {};\r\nfunction taggedHash(tag: string, ...messages: Uint8Array[]): Uint8Array {\r\n  let tagP = TAGGED_HASH_PREFIXES[tag];\r\n  if (tagP === undefined) {\r\n    const tagH = sha256(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\r\n    tagP = concatBytes(tagH, tagH);\r\n    TAGGED_HASH_PREFIXES[tag] = tagP;\r\n  }\r\n  return sha256(concatBytes(tagP, ...messages));\r\n}\r\n\r\n// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03\r\nconst pointToBytes = (point: PointType<bigint>) => point.toBytes(true).slice(1);\r\nconst numTo32b = (n: bigint) => numberToBytesBE(n, 32);\r\nconst modP = (x: bigint) => mod(x, secp256k1_CURVE.p);\r\nconst modN = (x: bigint) => mod(x, secp256k1_CURVE.n);\r\nconst Point = /* @__PURE__ */ (() => secp256k1.Point)();\r\nconst hasEven = (y: bigint) => y % _2n === _0n;\r\n\r\n// Calculate point, scalar and bytes\r\nfunction schnorrGetExtPubKey(priv: PrivKey) {\r\n  let d_ = secp256k1.utils.normPrivateKeyToScalar(priv); // same method executed in fromPrivateKey\r\n  let p = Point.fromPrivateKey(d_); // P = d'‚ãÖG; 0 < d' < n check is done inside\r\n  const scalar = hasEven(p.y) ? d_ : modN(-d_);\r\n  return { scalar: scalar, bytes: pointToBytes(p) };\r\n}\r\n/**\r\n * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.\r\n * @returns valid point checked for being on-curve\r\n */\r\nfunction lift_x(x: bigint): PointType<bigint> {\r\n  aInRange('x', x, _1n, secp256k1_CURVE.p); // Fail if x ‚â• p.\r\n  const xx = modP(x * x);\r\n  const c = modP(xx * x + BigInt(7)); // Let c = x¬≥ + 7 mod p.\r\n  let y = sqrtMod(c); // Let y = c^(p+1)/4 mod p.\r\n  if (!hasEven(y)) y = modP(-y); // Return the unique point P such that x(P) = x and\r\n  const p = Point.fromAffine({ x, y }); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.\r\n  p.assertValidity();\r\n  return p;\r\n}\r\nconst num = bytesToNumberBE;\r\n/**\r\n * Create tagged hash, convert it to bigint, reduce modulo-n.\r\n */\r\nfunction challenge(...args: Uint8Array[]): bigint {\r\n  return modN(num(taggedHash('BIP0340/challenge', ...args)));\r\n}\r\n\r\n/**\r\n * Schnorr public key is just `x` coordinate of Point as per BIP340.\r\n */\r\nfunction schnorrGetPublicKey(privateKey: Hex): Uint8Array {\r\n  return schnorrGetExtPubKey(privateKey).bytes; // d'=int(sk). Fail if d'=0 or d'‚â•n. Ret bytes(d'‚ãÖG)\r\n}\r\n\r\n/**\r\n * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.\r\n * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.\r\n */\r\nfunction schnorrSign(\r\n  message: Hex,\r\n  privateKey: PrivKey,\r\n  auxRand: Hex = randomBytes(32)\r\n): Uint8Array {\r\n  const m = ensureBytes('message', message);\r\n  const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey); // checks for isWithinCurveOrder\r\n  const a = ensureBytes('auxRand', auxRand, 32); // Auxiliary random data a: a 32-byte array\r\n  const t = numTo32b(d ^ num(taggedHash('BIP0340/aux', a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)\r\n  const rand = taggedHash('BIP0340/nonce', t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)\r\n  const k_ = modN(num(rand)); // Let k' = int(rand) mod n\r\n  if (k_ === _0n) throw new Error('sign failed: k is zero'); // Fail if k' = 0.\r\n  const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_); // Let R = k'‚ãÖG.\r\n  const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.\r\n  const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).\r\n  sig.set(rx, 0);\r\n  sig.set(numTo32b(modN(k + e * d)), 32);\r\n  // If Verify(bytes(P), m, sig) (see below) returns failure, abort\r\n  if (!schnorrVerify(sig, m, px)) throw new Error('sign: Invalid signature produced');\r\n  return sig;\r\n}\r\n\r\n/**\r\n * Verifies Schnorr signature.\r\n * Will swallow errors & return false except for initial type validation of arguments.\r\n */\r\nfunction schnorrVerify(signature: Hex, message: Hex, publicKey: Hex): boolean {\r\n  const sig = ensureBytes('signature', signature, 64);\r\n  const m = ensureBytes('message', message);\r\n  const pub = ensureBytes('publicKey', publicKey, 32);\r\n  try {\r\n    const P = lift_x(num(pub)); // P = lift_x(int(pk)); fail if that fails\r\n    const r = num(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r ‚â• p.\r\n    if (!inRange(r, _1n, secp256k1_CURVE.p)) return false;\r\n    const s = num(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s ‚â• n.\r\n    if (!inRange(s, _1n, secp256k1_CURVE.n)) return false;\r\n    const e = challenge(numTo32b(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n\r\n    // R = s‚ãÖG - e‚ãÖP, where -eP == (n-e)P\r\n    const R = Point.BASE.multiplyUnsafe(s).add(P.multiplyUnsafe(modN(-e)));\r\n    const { x, y } = R.toAffine();\r\n    // Fail if is_infinite(R) / not has_even_y(R) / x(R) ‚â† r.\r\n    if (R.is0() || !hasEven(y) || x !== r) return false;\r\n    return true;\r\n  } catch (error) {\r\n    return false;\r\n  }\r\n}\r\n\r\nexport type SecpSchnorr = {\r\n  getPublicKey: typeof schnorrGetPublicKey;\r\n  sign: typeof schnorrSign;\r\n  verify: typeof schnorrVerify;\r\n  utils: {\r\n    randomPrivateKey: () => Uint8Array;\r\n    lift_x: typeof lift_x;\r\n    pointToBytes: (point: PointType<bigint>) => Uint8Array;\r\n    numberToBytesBE: typeof numberToBytesBE;\r\n    bytesToNumberBE: typeof bytesToNumberBE;\r\n    taggedHash: typeof taggedHash;\r\n    mod: typeof mod;\r\n  };\r\n};\r\n/**\r\n * Schnorr signatures over secp256k1.\r\n * https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\r\n * @example\r\n * ```js\r\n * import { schnorr } from '@noble/curves/secp256k1';\r\n * const priv = schnorr.utils.randomPrivateKey();\r\n * const pub = schnorr.getPublicKey(priv);\r\n * const msg = new TextEncoder().encode('hello');\r\n * const sig = schnorr.sign(msg, priv);\r\n * const isValid = schnorr.verify(sig, msg, pub);\r\n * ```\r\n */\r\nexport const schnorr: SecpSchnorr = /* @__PURE__ */ (() => ({\r\n  getPublicKey: schnorrGetPublicKey,\r\n  sign: schnorrSign,\r\n  verify: schnorrVerify,\r\n  utils: {\r\n    randomPrivateKey: secp256k1.utils.randomPrivateKey,\r\n    lift_x,\r\n    pointToBytes,\r\n    numberToBytesBE,\r\n    bytesToNumberBE,\r\n    taggedHash,\r\n    mod,\r\n  },\r\n}))();\r\n\r\nconst isoMap = /* @__PURE__ */ (() =>\r\n  isogenyMap(\r\n    Fpk1,\r\n    [\r\n      // xNum\r\n      [\r\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7',\r\n        '0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581',\r\n        '0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262',\r\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c',\r\n      ],\r\n      // xDen\r\n      [\r\n        '0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b',\r\n        '0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14',\r\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\r\n      ],\r\n      // yNum\r\n      [\r\n        '0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c',\r\n        '0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3',\r\n        '0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931',\r\n        '0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84',\r\n      ],\r\n      // yDen\r\n      [\r\n        '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b',\r\n        '0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573',\r\n        '0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f',\r\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\r\n      ],\r\n    ].map((i) => i.map((j) => BigInt(j))) as [bigint[], bigint[], bigint[], bigint[]]\r\n  ))();\r\nconst mapSWU = /* @__PURE__ */ (() =>\r\n  mapToCurveSimpleSWU(Fpk1, {\r\n    A: BigInt('0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533'),\r\n    B: BigInt('1771'),\r\n    Z: Fpk1.create(BigInt('-11')),\r\n  }))();\r\n/** Hashing / encoding to secp256k1 points / field. RFC 9380 methods. */\r\nexport const secp256k1_hasher: H2CHasher<bigint> = /* @__PURE__ */ (() =>\r\n  createHasher(\r\n    secp256k1.Point,\r\n    (scalars: bigint[]) => {\r\n      const { x, y } = mapSWU(Fpk1.create(scalars[0]));\r\n      return isoMap(x, y);\r\n    },\r\n    {\r\n      DST: 'secp256k1_XMD:SHA-256_SSWU_RO_',\r\n      encodeDST: 'secp256k1_XMD:SHA-256_SSWU_NU_',\r\n      p: Fpk1.ORDER,\r\n      m: 1,\r\n      k: 128,\r\n      expand: 'xmd',\r\n      hash: sha256,\r\n    }\r\n  ))();\r\n\r\nexport const hashToCurve: H2CMethod<bigint> = /* @__PURE__ */ (() =>\r\n  secp256k1_hasher.hashToCurve)();\r\n\r\nexport const encodeToCurve: H2CMethod<bigint> = /* @__PURE__ */ (() =>\r\n  secp256k1_hasher.encodeToCurve)();\r\n"],
  "mappings": "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K,GAAG,IAAI,IAAI,EAAE;AACtB,UAAI,KAAK,GAAG,IAAI,IAAI,EAAE;AACtB,UAAI,KAAK,GAAG,IAAI,IAAI,EAAE;AACtB,UAAI,KAAK,GAAG,IAAI,IAAI,EAAE;AACtB,UAAI,KAAK,GAAG,IAAI,IAAI,EAAE;AACtB,WAAK,GAAG,IAAI,IAAI,EAAE;AAClB,WAAK,GAAG,IAAI,IAAI,EAAE;AAClB,WAAK,GAAG,IAAI,IAAI,EAAE;AAClB,WAAK,GAAG,IAAI,IAAI,EAAE;AAClB,UAAI,KAAK,GAAG,IAAI,IAAI,EAAE;AACtB,WAAK,GAAG,IAAI,IAAI,EAAE;AAClB,WAAK,GAAG,IAAI,IAAI,EAAE;AAClB,WAAK,GAAG,IAAI,IAAI,EAAE;AAClB,WAAK,GAAG,IAAI,IAAI,EAAE;AAClB,WAAK,GAAG,IAAI,IAAI,EAAE;AAClB,WAAK,GAAG,IAAI,IAAI,EAAE;AAClB,WAAK,GAAG,IAAI,IAAI,EAAE;AAClB,WAAK,GAAG,IAAI,IAAI,EAAE;AAClB,WAAK,GAAG,IAAI,GAAG,EAAE;AACjB,WAAK,GAAG,IAAI,IAAI,EAAE;AAClB,WAAK,GAAG,IAAI,IAAI,EAAE;AAClB,WAAK,GAAG,IAAI,IAAI,EAAE;AAClB,WAAK,GAAG,IAAI,IAAI,EAAE;AAClB,WAAK,GAAG,IAAI,IAAI,EAAE;AAClB,WAAK,GAAG,IAAI,IAAI,EAAE;AAClB,WAAK,GAAG,IAAI,IAAI,EAAE;AAClB,WAAK,GAAG,IAAI,GAAG,EAAE;AACjB,WAAK,GAAG,IAAI,IAAI,EAAE;AAClB,WAAK,GAAG,IAAI,IAAI,EAAE;AAClB,WAAK,GAAG,IAAI,IAAI,EAAE;AAClB,WAAK,GAAG,IAAI,GAAG,EAAE;AACjB,WAAK,GAAG,IAAI,IAAI,EAAE;AAClB,WAAK,GAAG,IAAI,IAAI,EAAE;AAClB,WAAK,GAAG,IAAI,IAAI,EAAE;AAClB,WAAK,GAAG,IAAI,IAAI,EAAE;AAClB,WAAK,GAAG,IAAI,IAAI,EAAE;AAClB,WAAK,GAAG,IAAI,IAAI,EAAE;AAClB,WAAK,GAAG,IAAI,IAAI,EAAE;AAClB,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",
  "names": ["num", "num", "num", "_0n", "_1n", "wbits", "_0n", "num", "_0n", "_1n", "_2n", "_3n", "_4n", "pointToBytes", "toBytes", "Point", "endo", "Point", "_1n", "num", "_2n", "_0n", "ecdsa", "Point", "_0n", "_1n", "_2n", "tv5", "_4n", "_3n", "c1", "c2", "Point", "num", "_0n", "_1n", "_2n", "_3n"]
}
