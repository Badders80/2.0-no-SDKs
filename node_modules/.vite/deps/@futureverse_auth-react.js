import {
  XM,
  jt
} from "./chunk-GTHX6AIB.js";
import "./chunk-A6GZNS2Z.js";
import "./chunk-DMPPMQ45.js";
import "./chunk-PCIH4M2A.js";
import "./chunk-KINQ5DOG.js";
import "./chunk-USOZON4W.js";
import {
  WagmiProvider,
  useAccount,
  useConfig,
  useConnect,
  useDisconnect,
  useWalletClient
} from "./chunk-FXIQ42SI.js";
import {
  useQuery
} from "./chunk-QK3LK67H.js";
import "./chunk-E7QJU2JJ.js";
import "./chunk-GOUVGRKW.js";
import "./chunk-N5UGU3Z2.js";
import "./chunk-T43U4WM3.js";
import "./chunk-ROA2PIJ7.js";
import {
  require_jsx_runtime
} from "./chunk-7HNDBV6L.js";
import "./chunk-UBNZMIM6.js";
import "./chunk-P4U7HCNA.js";
import "./chunk-YNUQFDQ6.js";
import "./chunk-YLGHVNRG.js";
import "./chunk-QVC62WT2.js";
import "./chunk-MI6XDP3Q.js";
import "./chunk-IHMPSRA7.js";
import "./chunk-VJBJ3BMK.js";
import "./chunk-5MKN5QPP.js";
import {
  require_react
} from "./chunk-4BATM3TV.js";
import {
  __toESM
} from "./chunk-MMN2DTB3.js";

// node_modules/@futureverse/auth-react/index.js
var import_jsx_runtime = __toESM(require_jsx_runtime());
var import_react = __toESM(require_react());
var F = (0, import_react.createContext)(null);
var z = ({
  authClient: n,
  children: t,
  signer: o
}) => {
  const [r, c] = (0, import_react.useState)(n.userSession), { disconnect: i } = useDisconnect(), { isFetching: a } = useQuery({
    queryKey: ["verifyAndLoadUser"],
    queryFn: async () => await n.verifyAndLoadUser(),
    refetchOnWindowFocus: "always"
  });
  (0, import_react.useEffect)(() => {
    r == null && i();
  }, [i, r]), (0, import_react.useEffect)(() => {
    const e = (s) => {
      c(s);
    };
    return n.addUserStateListener(e), () => n.removeUserStateListener(e);
  }, [n]);
  const f = (0, import_react.useMemo)(() => {
    if (r != null)
      return n.getSessionAuthType();
  }, [n, r]), d = (0, import_react.useCallback)(
    async (e) => await n.signInPass({
      signer: o,
      ...e
    }),
    [n, o]
  ), g = (0, import_react.useCallback)(
    async (e = { flow: "redirect" }) => {
      await n.signOut({
        flow: e == null ? void 0 : e.flow,
        onBeforeRedirect: e == null ? void 0 : e.beforeSignOut
      }), i();
    },
    [n, i]
  ), w = (0, import_react.useCallback)(
    async (e = { flow: "redirect" }) => {
      await n.signOutPass(e), i();
    },
    [n, i]
  );
  return (0, import_jsx_runtime.jsx)(
    F.Provider,
    {
      value: {
        signIn: d,
        signOut: g,
        signOutPass: w,
        authClient: n,
        userSession: r,
        authMethod: f,
        isFetchingSession: a
      },
      children: t
    }
  );
};
var B = ({
  initialState: n,
  getWagmiConfig: t,
  reconnectOnMount: o,
  children: r
}) => {
  const { data: c } = useQuery({
    queryKey: ["wagmiConfig"],
    queryFn: async () => await t(),
    structuralSharing: false,
    refetchOnWindowFocus: false,
    refetchOnMount: false
  });
  return c ? (0, import_jsx_runtime.jsx)(
    WagmiProvider,
    {
      config: c,
      initialState: n,
      reconnectOnMount: o,
      children: r
    }
  ) : null;
};
function M() {
  const n = (0, import_react.useContext)(F);
  if (n === null)
    throw new Error("useAuth must be used inside FutureverseAuthProvider");
  return n;
}
var N = () => {
  const { isConnected: n, connector: t, isConnecting: o } = useAccount(), { connectAsync: r, connectors: c } = useConnect(), { disconnectAsync: i } = useDisconnect(), a = useConfig(), { authClient: f } = M(), d = (0, import_react.useCallback)(
    // This curious type is a string type with autocomplete for known values
    async (e) => {
      const s = c.find((h) => h.id === e);
      if (!s)
        throw new Error(`Failed to find connector ${e}`);
      return s !== t && await (t == null ? void 0 : t.disconnect()), await s.isAuthorized() || await r({ connector: s }), await s.getAccounts();
    },
    [r, t, c]
  ), g = (0, import_react.useCallback)(
    async (e) => {
      const s = c.find((y) => y.id === e) ?? t;
      s || console.warn("No active connector to disconnect from"), await i({ connector: s });
    },
    [c, i, t]
  ), w = (0, import_react.useCallback)(
    async (e, s) => XM(e, f, a, s),
    [f, a]
  );
  return {
    connect: d,
    connectAndSignIn: w,
    disconnect: g,
    isConnected: n,
    connector: t,
    isConnecting: o,
    connectors: c
  };
};
function Q({
  chainId: n,
  connector: t
} = {}) {
  const { data: o } = useWalletClient({ chainId: n, connector: t });
  return (0, import_react.useMemo)(() => o ? jt(o) : void 0, [o]);
}
export {
  z as FutureverseAuthProvider,
  B as FutureverseWagmiProvider,
  F as futureverseAuthContext,
  M as useAuth,
  N as useConnector,
  Q as useFutureverseSigner
};
//# sourceMappingURL=@futureverse_auth-react.js.map
