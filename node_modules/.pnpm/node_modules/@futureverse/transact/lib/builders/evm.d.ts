import { ApiPromise } from '@polkadot/api';
import { Extrinsic, Signer } from '@futureverse/signer';
import { Abi } from 'viem';
import { RootTransactionBuilder } from './base';
import { u256 } from '@polkadot/types';
/**
 * The EvmBuilder class provides methods to build transactions for EVM pallet
 *
 * @param api - the trnApi to use for interaction
 * @param signer - the signer to use for signing transactions
 * @param walletAddress - the wallet address to use for interaction - should be the EOA address for the signer, not the FuturePass address
 * @param contractAddress - the contract address to use for interaction
 * @returns an EvmBuilder instance
 * @note the Evm Builder Class acts differently from the other builders in relation to the FuturePass and FeeProxy logic =>
 *        You need to to set the fromFuturePass flag to true when calling the writeContract method to use the FuturePass
 */
export declare class EvmBuilder extends RootTransactionBuilder {
    private _contractAddress;
    private _evmGasInfo;
    private _evmCall;
    protected futurePassEvmCall: Extrinsic | null;
    protected isEvmFuturePass: boolean;
    protected transactionData: string | null;
    protected addressToUse: string | null;
    protected gasLimit: bigint;
    protected evmGasPrice: bigint;
    protected nonce: string | null;
    constructor(api: ApiPromise, signer: Signer, walletAddress: string, contractAddress?: string);
    protected exists(): Promise<boolean>;
    /**
     * Resets the EvmBuilder instance
     *
     * @param contractAddress - (optional) the contract address to reset the EvmBuilder with (if provided)
     * @returns the EvmBuilder instance
     */
    reset(contractAddress?: string): this;
    /**
     * Call to interact with the EVM with data already encoded.
     * Initially designed for internal use only as a way to override an evm call made through Wagmi with the Xaman Connector.
     *
     * @param to - the address sending the transaction to
     * @param data - the data to send with the transaction
     * @param value - the value to send with the transaction
     * @param maxPriorityFeePerGas - the max priority fee per gas to use
     * @param nonce - the nonce to use for the transaction
     * @param fromFuturePass - whether to use the FuturePass for the transaction
     * @returns the EvmBuilder instance
     */
    evmOverride({ to, data, value, maxPriorityFeePerGas, nonce, fromFuturePass, }: {
        to?: string | null | undefined;
        data: `${string}`;
        value?: bigint | undefined;
        maxPriorityFeePerGas?: string | null;
        nonce?: string | null;
        fromFuturePass?: boolean;
    }): Promise<EvmBuilder>;
    /**
     * Call to interact with a contract on the EVM
     * Function will encode the function data and prepare the transaction when the appropriate parameters are passed
     *
     * @param abi - the ABI of the contract to call
     * @param functionName - the name of the function to call
     * @param args - the arguments to pass to the function
     * @param fromFuturePass - whether to use the FuturePass for the transaction
     * @returns the EvmBuilder instance
     */
    writeContract({ to, abi, functionName, args, fromFuturePass, value, maxPriorityFeePerGas, nonce, }: {
        to?: string;
        abi?: Abi;
        functionName?: string;
        args?: any[] | undefined;
        fromFuturePass?: boolean;
        value?: string;
        maxPriorityFeePerGas?: string | null;
        nonce?: string | null;
    }): Promise<EvmBuilder>;
    readContract<T>({ contractAddress, abi, functionName, args, }: {
        contractAddress: string;
        abi: Abi;
        functionName: string;
        args?: never[] | undefined;
    }): Promise<T>;
    /**
     * Used to prepare the transaction for sending to the EVM
     *
     * @param to - the address sending the transaction to
     * @param data - the data to send with the transaction
     * @param value - the value to send with the transaction
     * @param maxPriorityFeePerGas - the max priority fee per gas to use
     * @param nonce - the nonce to use for the transaction
     * @param fromFuturePass - whether to use the FuturePass for the transaction
     * @returns the address to use for the transaction
     */
    protected prepareTransaction({ to, data, value, maxPriorityFeePerGas, nonce, fromFuturePass, }: {
        to?: string | null | undefined;
        data: string;
        value: string;
        maxPriorityFeePerGas?: string | null;
        nonce?: string | number | null;
        fromFuturePass?: boolean;
    }): Promise<string>;
    /**
     * Gets the EVM gas Price for the transaction
     *
     * @param slippage - the slippage to use for the fee - in percentage
     * @returns the EVM gas Price for the transaction
     */
    protected getEthGasPrice(slippage?: number): Promise<bigint>;
    /**
     * Gets the EVM gas info for the transaction
     *
     * @returns the EVM gas info for the transaction
     */
    protected getEvmGasInfo(): Promise<u256>;
    /**
     * Helper function to wrap the extrinsic in a FuturePass
     *
     * @param futurePass - the future pass to proxy the extrinsic through
     * @param assetId - the asset ID to pay the fee in (1 for ROOT, 2 for XRP etc)
     * @param slippage - the slippage to use for the fee - in percentage
     * @returns the FuturePassExtrinsic and the maxPayment
     */
    protected futurepassLogic(futurePass: string, assetId: number, slippage: number): Promise<{
        futurePassExtrinsic: Extrinsic;
        maxPayment: bigint;
    }>;
    /**
     * Helper function to add a FuturePass Proxy to the extrinsic
     *
     * @param futurePass - the future pass to proxy the extrinsic through
     * @returns the TransactionBuilder instance
     */
    addFuturePass(futurePass: string): Promise<RootTransactionBuilder>;
    /**
     * Helper function to add a FeeProxy to the extrinsic
     *
     * @param assetId - the asset ID to pay the fee in (1 for ROOT, 2 for XRP etc)
     * @param slippage - the slippage to use for the fee - in percentage
     * @returns the TransactionBuilder instance
     */
    addFeeProxy({ assetId, slippage, }: {
        assetId: number;
        slippage: number;
    }): Promise<RootTransactionBuilder>;
}
