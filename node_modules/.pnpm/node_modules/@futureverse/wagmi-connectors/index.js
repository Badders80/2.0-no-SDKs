import { getAddress as Y, createWalletClient as q, custom as IM, publicActions as $, isHex as B, SwitchChainError as P, http as MM, serializeTransaction as gM, hexToBigInt as DM, createPublicClient as uM, numberToHex as H, UserRejectedRequestError as G } from "viem";
import { createConnector as V, ChainNotConfiguredError as R, http as oM, createConfig as rM, getConnectors as Z, getAccount as W, connect as TM, disconnect as zM, getWalletClient as eM, ProviderNotFoundError as _, extractRpcUrls as aM } from "@wagmi/core";
import { Xumm as yM } from "xumm";
import { XamanSigner as LM, FutureverseCustodialSigner as AM, clientToSigner as tM } from "@futureverse/signer";
import { toAccount as nM } from "viem/accounts";
import { TransactionBuilder as xM } from "@futureverse/transact";
import { ApiPromise as OM } from "@polkadot/api";
import { getProvider as dM, getApiOptions as EM } from "@therootnetwork/api";
import { metaMask as lM, coinbaseWallet as CM, walletConnect as wM } from "@wagmi/connectors";
var b = { exports: {} }, K;
function UM() {
  if (K) return b.exports;
  K = 1;
  var s = typeof Reflect == "object" ? Reflect : null, j = s && typeof s.apply == "function" ? s.apply : function(e, t, N) {
    return Function.prototype.apply.call(e, t, N);
  }, D;
  s && typeof s.ownKeys == "function" ? D = s.ownKeys : Object.getOwnPropertySymbols ? D = function(e) {
    return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e));
  } : D = function(e) {
    return Object.getOwnPropertyNames(e);
  };
  function I(n) {
    console && console.warn && console.warn(n);
  }
  var y = Number.isNaN || function(e) {
    return e !== e;
  };
  function g() {
    g.init.call(this);
  }
  b.exports = g, b.exports.once = w, g.EventEmitter = g, g.prototype._events = void 0, g.prototype._eventsCount = 0, g.prototype._maxListeners = void 0;
  var L = 10;
  function r(n) {
    if (typeof n != "function")
      throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof n);
  }
  Object.defineProperty(g, "defaultMaxListeners", {
    enumerable: !0,
    get: function() {
      return L;
    },
    set: function(n) {
      if (typeof n != "number" || n < 0 || y(n))
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + n + ".");
      L = n;
    }
  }), g.init = function() {
    (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
  }, g.prototype.setMaxListeners = function(e) {
    if (typeof e != "number" || e < 0 || y(e))
      throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + ".");
    return this._maxListeners = e, this;
  };
  function o(n) {
    return n._maxListeners === void 0 ? g.defaultMaxListeners : n._maxListeners;
  }
  g.prototype.getMaxListeners = function() {
    return o(this);
  }, g.prototype.emit = function(e) {
    for (var t = [], N = 1; N < arguments.length; N++) t.push(arguments[N]);
    var u = e === "error", x = this._events;
    if (x !== void 0)
      u = u && x.error === void 0;
    else if (!u)
      return !1;
    if (u) {
      var A;
      if (t.length > 0 && (A = t[0]), A instanceof Error)
        throw A;
      var c = new Error("Unhandled error." + (A ? " (" + A.message + ")" : ""));
      throw c.context = A, c;
    }
    var O = x[e];
    if (O === void 0)
      return !1;
    if (typeof O == "function")
      j(O, this, t);
    else
      for (var l = O.length, f = i(O, l), N = 0; N < l; ++N)
        j(f[N], this, t);
    return !0;
  };
  function E(n, e, t, N) {
    var u, x, A;
    if (r(t), x = n._events, x === void 0 ? (x = n._events = /* @__PURE__ */ Object.create(null), n._eventsCount = 0) : (x.newListener !== void 0 && (n.emit(
      "newListener",
      e,
      t.listener ? t.listener : t
    ), x = n._events), A = x[e]), A === void 0)
      A = x[e] = t, ++n._eventsCount;
    else if (typeof A == "function" ? A = x[e] = N ? [t, A] : [A, t] : N ? A.unshift(t) : A.push(t), u = o(n), u > 0 && A.length > u && !A.warned) {
      A.warned = !0;
      var c = new Error("Possible EventEmitter memory leak detected. " + A.length + " " + String(e) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      c.name = "MaxListenersExceededWarning", c.emitter = n, c.type = e, c.count = A.length, I(c);
    }
    return n;
  }
  g.prototype.addListener = function(e, t) {
    return E(this, e, t, !1);
  }, g.prototype.on = g.prototype.addListener, g.prototype.prependListener = function(e, t) {
    return E(this, e, t, !0);
  };
  function a() {
    if (!this.fired)
      return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
  }
  function C(n, e, t) {
    var N = { fired: !1, wrapFn: void 0, target: n, type: e, listener: t }, u = a.bind(N);
    return u.listener = t, N.wrapFn = u, u;
  }
  g.prototype.once = function(e, t) {
    return r(t), this.on(e, C(this, e, t)), this;
  }, g.prototype.prependOnceListener = function(e, t) {
    return r(t), this.prependListener(e, C(this, e, t)), this;
  }, g.prototype.removeListener = function(e, t) {
    var N, u, x, A, c;
    if (r(t), u = this._events, u === void 0)
      return this;
    if (N = u[e], N === void 0)
      return this;
    if (N === t || N.listener === t)
      --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete u[e], u.removeListener && this.emit("removeListener", e, N.listener || t));
    else if (typeof N != "function") {
      for (x = -1, A = N.length - 1; A >= 0; A--)
        if (N[A] === t || N[A].listener === t) {
          c = N[A].listener, x = A;
          break;
        }
      if (x < 0)
        return this;
      x === 0 ? N.shift() : z(N, x), N.length === 1 && (u[e] = N[0]), u.removeListener !== void 0 && this.emit("removeListener", e, c || t);
    }
    return this;
  }, g.prototype.off = g.prototype.removeListener, g.prototype.removeAllListeners = function(e) {
    var t, N, u;
    if (N = this._events, N === void 0)
      return this;
    if (N.removeListener === void 0)
      return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : N[e] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete N[e]), this;
    if (arguments.length === 0) {
      var x = Object.keys(N), A;
      for (u = 0; u < x.length; ++u)
        A = x[u], A !== "removeListener" && this.removeAllListeners(A);
      return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
    }
    if (t = N[e], typeof t == "function")
      this.removeListener(e, t);
    else if (t !== void 0)
      for (u = t.length - 1; u >= 0; u--)
        this.removeListener(e, t[u]);
    return this;
  };
  function d(n, e, t) {
    var N = n._events;
    if (N === void 0)
      return [];
    var u = N[e];
    return u === void 0 ? [] : typeof u == "function" ? t ? [u.listener || u] : [u] : t ? T(u) : i(u, u.length);
  }
  g.prototype.listeners = function(e) {
    return d(this, e, !0);
  }, g.prototype.rawListeners = function(e) {
    return d(this, e, !1);
  }, g.listenerCount = function(n, e) {
    return typeof n.listenerCount == "function" ? n.listenerCount(e) : M.call(n, e);
  }, g.prototype.listenerCount = M;
  function M(n) {
    var e = this._events;
    if (e !== void 0) {
      var t = e[n];
      if (typeof t == "function")
        return 1;
      if (t !== void 0)
        return t.length;
    }
    return 0;
  }
  g.prototype.eventNames = function() {
    return this._eventsCount > 0 ? D(this._events) : [];
  };
  function i(n, e) {
    for (var t = new Array(e), N = 0; N < e; ++N)
      t[N] = n[N];
    return t;
  }
  function z(n, e) {
    for (; e + 1 < n.length; e++)
      n[e] = n[e + 1];
    n.pop();
  }
  function T(n) {
    for (var e = new Array(n.length), t = 0; t < e.length; ++t)
      e[t] = n[t].listener || n[t];
    return e;
  }
  function w(n, e) {
    return new Promise(function(t, N) {
      function u(A) {
        n.removeListener(e, x), N(A);
      }
      function x() {
        typeof n.removeListener == "function" && n.removeListener("error", u), t([].slice.call(arguments));
      }
      S(n, e, x, { once: !0 }), e !== "error" && U(n, u, { once: !0 });
    });
  }
  function U(n, e, t) {
    typeof n.on == "function" && S(n, "error", e, t);
  }
  function S(n, e, t, N) {
    if (typeof n.on == "function")
      N.once ? n.once(e, t) : n.on(e, t);
    else if (typeof n.addEventListener == "function")
      n.addEventListener(e, function u(x) {
        N.once && n.removeEventListener(e, u), t(x);
      });
    else
      throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof n);
  }
  return b.exports;
}
var SM = UM();
class QM extends SM.EventEmitter {
  constructor({
    payload: j,
    headerText: D,
    bodyText: I
  }) {
    super(), this.modal = null, this.imageSrc = "", this.headerText = "", this.bodyText = "", this.uuid = "", this.uuid = j.uuid, this.imageSrc = j.refs.qr_png, this.headerText = D && D !== "" ? D : "Scan QR code to sign transaction", I && I !== "" && (this.bodyText = I), console.log("Creating modal"), console.log("Image src:", this.imageSrc), console.log("Header text:", this.headerText), console.log("Body text:", this.bodyText), this.createModal();
  }
  createModal() {
    const j = Math.random().toString(36).substring(7);
    this.modal = document.createElement("div"), this.modal.id = "fv-signer-modal", this.modal.className = `fv-signer-modal-${j}`;
    const D = document.createElement("img");
    D.src = this.imageSrc;
    const I = document.createElement("div");
    I.className = "modal-content", I.style.position = "absolute";
    const y = document.createElement("div");
    y.className = "modal-header", y.innerText = this.headerText, y.style.cursor = "move";
    const g = document.createElement("div");
    g.className = "modal-body", g.innerText = this.bodyText;
    const L = document.createElement("button");
    L.className = "close", L.innerHTML = "&times;";
    const r = document.createElement("div");
    r.className = "button-row";
    const o = document.createElement("button");
    o.className = "close-button", o.innerText = "Close";
    const E = document.createElement("button");
    E.className = "cancel-close-button", E.innerText = "Cancel", I.appendChild(y), I.appendChild(L), I.appendChild(D), this.bodyText !== "" && I.appendChild(g), I.appendChild(r), r.appendChild(o), r.appendChild(E), this.modal.appendChild(I), document.body.appendChild(this.modal), this.modal.addEventListener("click", (C) => {
      C.target === this.modal && this.destroy();
    }), E.addEventListener("click", () => {
      this.cancelAndDestroy();
    }), o.addEventListener("click", () => {
      this.destroy();
    }), L.addEventListener("click", () => {
      this.destroy();
    }), this.makeDraggable(y, I);
    const a = document.createElement("style");
    a.innerHTML = `
      .fv-signer-modal-${j} {
        display: block;
        position: fixed;
        z-index: 9999;
        left: 0;
        top: 0;
        width: 100vw;
        height: 100vh;
        overflow: auto;
        background-color: rgba(0,0,0,0.8);
      }

      .fv-signer-modal-${j} .modal-content {
        position: absolute;
        background-color: #fff;
        padding: 16px;
        border: 1px solid #000;
        width: 100%;
        max-width: 300px;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        text-align: center;
        border-radius: 16px;
        -webkit-box-shadow: 0px 16px 16px -8px rgba(0,0,0,0.84);
        -moz-box-shadow: 0px 16px 16px -8px rgba(0,0,0,0.84);
        box-shadow: 0px 16px 16px -8px rgba(0,0,0,0.84);
      }

      .fv-signer-modal-${j} .modal-header {
        font-weight: 700;
        font-size: 1.4rem;
      }

      .fv-signer-modal-${j} .modal-content img {
        width: 100%;
      }

      .fv-signer-modal-${j} .button-row {
        padding: 0;
        width: 100%;
        display: grid;
        grid-template-columns: repeat(2, auto);
        gap: 8px;
      }

      .fv-signer-modal-${j} .close-button,
      .fv-signer-modal-${j} .cancel-close-button {
        width: 100%;
        text-transform: uppercase;
        border: none;
        margin: 0;
        padding: 16px;
        line-height: 1;
        letter-spacing: 1.1px;
        font-weight: 700;
        font-size: 0.8rem;
        appearance: none;
        border: 1px solid transparent;
        transition: all 0.3s;
        cursor: pointer;

      }

      .fv-signer-modal-${j} .close-button {
        background: black;
        color: white;
      }

      .fv-signer-modal-${j} .cancel-close-button {
        background: transparent;
        color: black;
        border: 1px solid black;
      }

      .fv-signer-modal-${j} .close-button:hover,
      .fv-signer-modal-${j} .cancel-close-button:hover {
        border: 1px solid #0029fe;
        background: #0029fe;
        color: #fff;
      }

      .fv-signer-modal-${j} .close {
        appearance: none;
        color: #373737;
        float: right;
        font-size: 23px;
        font-weight: bold;
        width: 32px;
        height: 32px;
        line-height: 0;
        text-align: center;
        position: absolute;
        border: none;
        background: #fff;
        padding: 8px;
        border-radius: 50px;
        top: -16px;
        right: -16px;
        box-shadow: 0 0 8px rgba(0, 0, 0, 0.6);
      }

      .fv-signer-modal-${j} .close:hover,
      .fv-signer-modal-${j} .close:focus {
        color: black;
        text-decoration: none;
        cursor: pointer;
      }
    `, document.head.appendChild(a);
  }
  makeDraggable(j, D) {
    let I, y, g, L;
    const r = (a) => {
      a.preventDefault(), I = a.clientX, y = a.clientY, g = D.offsetLeft, L = D.offsetTop, document.onmouseup = E, document.onmousemove = o;
    }, o = (a) => {
      a.preventDefault();
      const C = a.clientX - I, d = a.clientY - y, M = g + C, i = L + d, z = window.innerHeight - D.offsetHeight / 2, T = window.innerWidth - (D.offsetWidth / 2 + 16);
      D.style.top = `${Math.max(
        D.offsetHeight / 2 + 16,
        Math.min(i, z)
      )}px`, D.style.left = `${Math.max(
        D.offsetWidth / 2,
        Math.min(M, T)
      )}px`;
    }, E = () => {
      document.onmouseup = null, document.onmousemove = null;
    };
    j.onmousedown = r;
  }
  cancelAndDestroy() {
    console.log("Cancelling and destroying modal"), this.emit("cancel", this.uuid), this.destroy();
  }
  destroy() {
    this.modal && document.body.contains(this.modal) && (document.body.removeChild(this.modal), this.modal = null);
  }
}
async function iM(s, j) {
  await s.getUser() && await s.OIDCManager.removeUser(), await s.signInPass({
    type: j.authType,
    signer: j.signer,
    extraQueryParams: { connector_id: j.connectorId },
    ...j.signOpts
  });
}
function kM({
  apiKey: s,
  authClient: j,
  onQR: D,
  onSign: I,
  qrModalEnabled: y = !0,
  trnNode: g = "default"
}) {
  let L, r, o = !1, E;
  const a = "XummPkceJwt", C = "xaman", d = typeof document < "u";
  let M = null, i = !1, z = j.environment.chain, T;
  const w = (e) => {
    M = new QM({
      payload: e,
      headerText: "Scan QR Code"
    }), i = !0;
  }, U = async (e) => {
    if (!(L != null && L.payload))
      throw new Error("No Xaman client payload");
    await L.payload.cancel(e), i = !1;
  }, S = () => {
    M == null || M.destroy();
  }, n = async () => {
    if (E && E.isConnected)
      return E;
    const e = j.environment.chain.rpcUrls[g].webSocket;
    if (!e)
      throw new Error("Invalid chain RPC");
    return E = await OM.create({
      noInitWarn: !0,
      ...EM(),
      ...dM(e[0])
    }), E;
  };
  return V((e) => {
    const t = () => e != null && e.transports ? e.transports[z.id] : MM(), N = (c) => {
      i || (y && d && (w(c), M == null || M.addListener("cancel", () => {
        U(c.uuid);
      })), e.emitter.emit("message", { type: "display_qr", data: c }), D && D(c));
    }, u = (c) => {
      y && d && (S(), M == null || M.removeListener("cancel", () => {
        U(c.uuid);
      })), i = !1, e.emitter.emit("message", { type: "signed", data: c }), I && I(c);
    }, x = (c) => {
      var O, l;
      if (T) {
        if (!c)
          return T([]);
        (l = (O = j.userSession) == null ? void 0 : O.user) != null && l.profile.sub.startsWith("xrpl") && T([c.eoa, c.futurepass]);
      }
    }, A = (c) => {
      r || (r = new LM(c), r.subscribe("showQR", N), r.subscribe("signed", u));
    };
    return {
      icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjU2IiBoZWlnaHQ9IjI1NiIgdmlld0JveD0iMCAwIDI1NiAyNTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxnIGNsaXAtcGF0aD0idXJsKCNjbGlwMF8zMTE2Xzk1OCkiPgo8cGF0aCBkPSJNMjU2IDBIMFYyNTZIMjU2VjBaIiBmaWxsPSIjMDAzMENGIi8+CjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMTUyLjc4MiAtMjM3LjMzOEMyMDguMyAtMjE3LjMyMyAyNjIuMTgzIC0xNzIuNjk0IDI5My45MTQgLTEzNi4zNTlDMzI1LjczIC05OS45MjM4IDM0OC4yMTMgLTU3LjAyMDEgMzUzLjI2MSAtNy41MjA3NEMzNTguMzEgNDEuOTkwOSAzNDUuODg1IDk3LjgwNTEgMzA4LjQwMyAxNTkuOTkzQzI3MS4wMDMgMjIyLjA0NiAxOTMuNjYyIDMxNS4zMDYgMTE3Ljc2OSAzODQuMDM3Qzc5LjgzNDQgNDE4LjM5IDQyLjA4NzkgNDQ2Ljc3NyA5LjczNjk0IDQ2Mi4wMzZDLTYuNDMyNzggNDY5LjY2MyAtMjEuNDU1MSA0NzQuMTA3IC0zNC41OTU4IDQ3NC4yNDFDLTQ3LjgzOCA0NzQuMzc3IC01OS4yMTg5IDQ3MC4xMjIgLTY3LjcyMDQgNDYwLjM4NkMtNzYuMDY2NiA0NTAuODI5IC04Mi4xODggNDM1LjMzMSAtODYuNTM0MyA0MTUuNzE3Qy05MC44OTg4IDM5Ni4wMjEgLTkzLjU0NTMgMzcxLjgyNyAtOTQuNzA0NiAzNDQuNTU3Qy05Ny4wMjM0IDI5MC4wMDggLTkzLjQwMjIgMjIyLjg2MSAtODUuNDg1OCAxNTQuMTc0Qy03Ny41Njg0IDg1LjQ3NzMgLTY1LjM0NTMgMTUuMTU5NiAtNTAuNDMxNSAtNDUuNzQzMUMtMzUuNTM2MiAtMTA2LjU3IC0xNy44OTc0IC0xNTguMjYgMC45NDc1NDggLTE4OS41MjdDMTkuODk1MyAtMjIwLjk2NCA0My44NjY3IC0yMzguMDgyIDcwLjI2OTYgLTI0NC42OTNDOTYuNTg3MiAtMjUxLjI4MyAxMjQuOTk3IC0yNDcuMzU1IDE1Mi43ODIgLTIzNy4zMzhaTTcxLjYwNTUgLTIzOS4zNThDNDYuNzgwMiAtMjMzLjE0MiAyMy45NDg5IC0yMTcuMDM1IDUuNjU4MDkgLTE4Ni42ODhDLTEyLjczNTUgLTE1Ni4xNyAtMzAuMjE5IC0xMDUuMTYgLTQ1LjA4OTMgLTQ0LjQzNUMtNTkuOTQxMiAxNi4yMTUxIC03Mi4xMjcyIDg2LjMwMzQgLTgwLjAyMiAxNTQuODA0Qy04Ny45MTc5IDIyMy4zMTMgLTkxLjUxMjIgMjkwLjE1NSAtODkuMjA5NSAzNDQuMzIzQy04OC4wNTggMzcxLjQxMSAtODUuNDM0NSAzOTUuMjU4IC04MS4xNjQ2IDQxNC41MjdDLTc2Ljg3NjYgNDMzLjg3OCAtNzAuOTk5NCA0NDguMjcgLTYzLjU3NzcgNDU2Ljc2OUMtNTYuMzExMSA0NjUuMDkgLTQ2LjU3NzkgNDY4Ljg2MyAtMzQuNjUxOSA0NjguNzQyQy0yMi42MjQzIDQ2OC42MTkgLTguNDI0MTkgNDY0LjUyMSA3LjM5MDY3IDQ1Ny4wNjFDMzkuMDA4OSA0NDIuMTQ4IDc2LjI4MDEgNDE0LjE4OSAxMTQuMDc3IDM3OS45NkMxODkuNjQ0IDMxMS41MjQgMjY2LjYxNiAyMTguNjcgMzAzLjY5MiAxNTcuMTU0QzM0MC42ODggOTUuNzczNiAzNTIuNjk1IDQxLjEzODkgMzQ3Ljc4OSAtNi45NjI3NUMzNDIuODgzIC01NS4wNzY3IDMyMS4wMjUgLTk2Ljk1MDUgMjg5Ljc3MSAtMTMyLjc0MUMyNTguNDI5IC0xNjguNjMxIDIwNS4yODEgLTIxMi41NjQgMTUwLjkxNyAtMjMyLjE2NEMxMjMuNzYgLTI0MS45NTQgOTYuNTE2MSAtMjQ1LjU5NiA3MS42MDU1IC0yMzkuMzU4WiIgZmlsbD0idXJsKCNwYWludDBfbGluZWFyXzMxMTZfOTU4KSIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTE1MC4zOTcgLTIwMS4wNjNDMjAwLjQyMSAtMTgzLjAyOCAyNDguOTUyIC0xNDIuODI4IDI3Ny41MjkgLTExMC4xMDRDMzA2LjE5MyAtNzcuMjggMzI2LjQ1OSAtMzguNjE1MiAzMzEuMDA5IDYuMDAzNDZDMzM1LjU2IDUwLjYzNDQgMzI0LjM1NiAxMDAuOTI2IDI5MC41OTggMTU2LjkzNkMyNTYuOTIyIDIxMi44MSAxODcuMjk3IDI5Ni43NjQgMTE4Ljk3NiAzNTguNjM3Qzg0LjgyODggMzg5LjU2MSA1MC44MzMyIDQxNS4xMzEgMjEuNjgwNyA0MjguODgxQzcuMTEwMjEgNDM1Ljc1NCAtNi40NTA5NiA0MzkuNzcxIC0xOC4zMzMyIDQzOS44OTJDLTMwLjMxNzEgNDQwLjAxNSAtNDAuNjQyMyA0MzYuMTYxIC00OC4zNTUzIDQyNy4zMjlDLTU1LjkxMzIgNDE4LjY3NCAtNjEuNDM0NyA0MDQuNjcxIC02NS4zNDkzIDM4Ny4wMDVDLTY5LjI4MiAzNjkuMjU3IC03MS42NjUxIDM0Ny40NjUgLTcyLjcwODggMzIyLjkxM0MtNzQuNzk2NiAyNzMuOCAtNzEuNTM2MiAyMTMuMzUzIC02NC40MTA0IDE1MS41MjVDLTU3LjI4MzUgODkuNjg4NCAtNDYuMjgwOCAyNi4zOTEgLTMyLjg1NTMgLTI4LjQzNDFDLTE5LjQ0ODMgLTgzLjE4MzkgLTMuNTY1NjQgLTEyOS43MzkgMTMuNDE3NCAtMTU3LjkxNkMzMC41MDMyIC0xODYuMjY0IDUyLjEzNDQgLTIwMS43MjEgNzUuOTc1OSAtMjA3LjY5MUM5OS43MzIxIC0yMTMuNjM5IDEyNS4zNTkgLTIxMC4wODkgMTUwLjM5NyAtMjAxLjA2M1pNNzcuMzExOSAtMjAyLjM1NUM1NS4wNDc5IC0xOTYuNzgxIDM0LjU1NjggLTE4Mi4zMzUgMTguMTI3OSAtMTU1LjA3N0MxLjU5NjI2IC0xMjcuNjQ4IC0xNC4xMzExIC04MS43NzM3IC0yNy41MTMyIC0yNy4xMjZDLTQwLjg3NjggMjcuNDQ2NSAtNTEuODQyMyA5MC41MTQ1IC01OC45NDY1IDE1Mi4xNTVDLTY2LjA1MTggMjEzLjgwNSAtNjkuMjg1NCAyNzMuOTQ3IC02Ny4yMTM3IDMyMi42NzlDLTY2LjE3NzggMzQ3LjA1IC02My44MTc3IDM2OC40OTQgLTU5Ljk3OTYgMzg1LjgxNUMtNTYuMTIzMiA0MDMuMjE4IC01MC44NDYgNDE2LjExNSAtNDQuMjEyNiA0MjMuNzExQy0zNy43MzQ1IDQzMS4xMjkgLTI5LjA1NyA0MzQuNTAyIC0xOC4zODk0IDQzNC4zOTNDLTcuNjIwMjEgNDM0LjI4MyA1LjExODc5IDQzMC42MTIgMTkuMzM0NCA0MjMuOTA3QzQ3Ljc1NDIgNDEwLjUwMiA4MS4yNzQ1IDM4NS4zNiAxMTUuMjg0IDM1NC41NkMxODMuMjc5IDI5Mi45ODIgMjUyLjUzNSAyMDkuNDM0IDI4NS44ODcgMTU0LjA5NkMzMTkuMTU5IDk4Ljg5NDYgMzI5Ljk0NSA0OS43ODI0IDMyNS41MzcgNi41NjE0M0MzMjEuMTI5IC0zNi42NzE4IDMwMS40ODcgLTc0LjMwNjcgMjczLjM4NiAtMTA2LjQ4NkMyNDUuMTk4IC0xMzguNzY0IDE5Ny40MDIgLTE3OC4yNyAxNDguNTMyIC0xOTUuODg5QzEyNC4xMjMgLTIwNC42ODkgOTkuNjYxMSAtMjA3Ljk1MiA3Ny4zMTE5IC0yMDIuMzU1WiIgZmlsbD0idXJsKCNwYWludDFfbGluZWFyXzMxMTZfOTU4KSIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTE0OC4wMTIgLTE2NC43ODhDMTkyLjU0MSAtMTQ4LjczNCAyMzUuNzIxIC0xMTIuOTYxIDI2MS4xNDQgLTgzLjg0ODZDMjg2LjY1NCAtNTQuNjM2NCAzMDQuNzAzIC0yMC4yMTA1IDMwOC43NTYgMTkuNTI3NUMzMTIuODEgNTkuMjc3OCAzMDIuODI3IDEwNC4wNDcgMjcyLjc5MyAxNTMuODc4QzI0Mi44NDEgMjAzLjU3NCAxODAuOTMxIDI3OC4yMjMgMTIwLjE4NCAzMzMuMjM3Qzg5LjgyMjkgMzYwLjczMiA1OS41NzgxIDM4My40ODUgMzMuNjI0MSAzOTUuNzI2QzIwLjY1MjkgNDAxLjg0NSA4LjU1MjgxIDQwNS40MzUgLTIuMDcxMDQgNDA1LjU0NEMtMTIuNzk2NSA0MDUuNjUzIC0yMi4wNjYgNDAyLjIwMSAtMjguOTkwNiAzOTQuMjcxQy0zNS43NiAzODYuNTIgLTQwLjY4MTYgMzc0LjAxMSAtNDQuMTY0NSAzNTguMjkzQy00Ny42NjU2IDM0Mi40OTQgLTQ5Ljc4NTEgMzIzLjEwNCAtNTAuNzEzMyAzMDEuMjY5Qy01Mi41NyAyNTcuNTkyIC00OS42NzAzIDIwMy44NDQgLTQzLjMzNTIgMTQ4Ljg3NkMtMzYuOTk4OSA5My44OTk0IC0yNy4yMTY3IDM3LjYyMjMgLTE1LjI3OTUgLTExLjEyNTJDLTMuMzYwNzIgLTU5Ljc5NzQgMTAuNzY1OCAtMTAxLjIxNyAyNS44ODcgLTEyNi4zMDVDNDEuMTEwOCAtMTUxLjU2NCA2MC40MDIgLTE2NS4zNiA4MS42ODIgLTE3MC42ODhDMTAyLjg3NyAtMTc1Ljk5NSAxMjUuNzIxIC0xNzIuODI0IDE0OC4wMTIgLTE2NC43ODhaTTgzLjAxOCAtMTY1LjM1M0M2My4zMTU1IC0xNjAuNDE5IDQ1LjE2NDUgLTE0Ny42MzUgMzAuNTk3NSAtMTIzLjQ2NkMxNS45Mjc3IC05OS4xMjcgMS45NTY0NyAtNTguMzg3MiAtOS45MzczMiAtOS44MTcwNEMtMjEuODEyNyAzOC42Nzc3IC0zMS41NTc3IDk0LjcyNTUgLTM3Ljg3MTMgMTQ5LjUwNkMtNDQuMTg2IDIwNC4yOTYgLTQ3LjA1ODggMjU3LjczOSAtNDUuMjE4MiAzMDEuMDM2Qy00NC4yOTc4IDMyMi42ODggLTQyLjIwMTIgMzQxLjczMSAtMzguNzk0OCAzNTcuMTAzQy0zNS4zNzAyIDM3Mi41NTggLTMwLjY5MjkgMzgzLjk2MSAtMjQuODQ3OSAzOTAuNjU0Qy0xOS4xNTgyIDM5Ny4xNjkgLTExLjUzNjQgNDAwLjE0IC0yLjEyNzIyIDQwMC4wNDRDNy4zODM1NCAzOTkuOTQ3IDE4LjY2MTQgMzk2LjcwMyAzMS4yNzc4IDM5MC43NTJDNTYuNDk5MSAzNzguODU2IDg2LjI2ODYgMzU2LjUzMSAxMTYuNDkyIDMyOS4xNkMxNzYuOTE0IDI3NC40NDEgMjM4LjQ1NCAyMDAuMTk4IDI2OC4wODIgMTUxLjAzOUMyOTcuNjMgMTAyLjAxNiAzMDcuMTk0IDU4LjQyNTggMzAzLjI4NCAyMC4wODU1QzI5OS4zNzMgLTE4LjI2NyAyODEuOTQ5IC01MS42NjMgMjU3LjAwMSAtODAuMjMwOUMyMzEuOTY3IC0xMDguODk4IDE4OS41MjMgLTE0My45NzYgMTQ2LjE0NiAtMTU5LjYxNEMxMjQuNDg0IC0xNjcuNDIzIDEwMi44MDYgLTE3MC4zMDggODMuMDE4IC0xNjUuMzUzWiIgZmlsbD0idXJsKCNwYWludDJfbGluZWFyXzMxMTZfOTU4KSIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTE0NS42MjcgLTEyOC41MTNDMTg0LjY2MiAtMTE0LjQ0IDIyMi40OTEgLTgzLjA5NTIgMjQ0Ljc2IC01Ny41OTM2QzI2Ny4xMTcgLTMxLjk5MjcgMjgyLjk0OSAtMS44MDU2MyAyODYuNTA0IDMzLjA1MTdDMjkwLjA2IDY3LjkyMTIgMjgxLjMgMTA3LjE2OCAyNTQuOTkgMTUwLjgyMUMyMjguNzYxIDE5NC4zMzggMTc0LjU2NiAyNTkuNjgxIDEyMS4zOTIgMzA3LjgzN0M5NC44MTc0IDMzMS45MDQgNjguMzIzNCAzNTEuODM5IDQ1LjU2NzkgMzYyLjU3MkMzNC4xOTU4IDM2Ny45MzYgMjMuNTU2OSAzNzEuMDk5IDE0LjE5MTQgMzcxLjE5NUM0LjcyNDQxIDM3MS4yOTEgLTMuNDg5MzggMzY4LjI0MSAtOS42MjU2NCAzNjEuMjE0Qy0xNS42MDY3IDM1NC4zNjUgLTE5LjkyODMgMzQzLjM1IC0yMi45Nzk1IDMyOS41ODFDLTI2LjA0ODggMzE1LjczIC0yNy45MDQ4IDI5OC43NDIgLTI4LjcxNzUgMjc5LjYyNUMtMzAuMzQzMSAyNDEuMzg0IC0yNy44MDQzIDE5NC4zMzYgLTIyLjI1OTcgMTQ2LjIyOEMtMTYuNzE0MSA5OC4xMTA1IC04LjE1MjM2IDQ4Ljg1MzYgMi4yOTY1NyA2LjE4Mzc1QzEyLjcyNyAtMzYuNDEwOCAyNS4wOTc1IC03Mi42OTU3IDM4LjM1NjYgLTk0LjY5NDZDNTEuNzE4NiAtMTE2Ljg2NCA2OC42Njk2IC0xMjguOTk4IDg3LjM4ODIgLTEzMy42ODZDMTA2LjAyMiAtMTM4LjM1MiAxMjYuMDgzIC0xMzUuNTU4IDE0NS42MjcgLTEyOC41MTNaTTg4LjcyNDIgLTEyOC4zNUM3MS41ODMxIC0xMjQuMDU4IDU1Ljc3MjIgLTExMi45MzUgNDMuMDY3MiAtOTEuODU1NEMzMC4yNTk0IC03MC42MDU0IDE4LjA0NDIgLTM1LjAwMDYgNy42Mzg3MyA3LjQ5MTkzQy0yLjc0ODMxIDQ5LjkwOTEgLTExLjI3MjkgOTguOTM2NiAtMTYuNzk1OSAxNDYuODU3Qy0yMi4zMTk5IDE5NC43ODggLTI0LjgzMTkgMjQxLjUzMSAtMjMuMjIyNCAyNzkuMzkyQy0yMi40MTc1IDI5OC4zMjYgLTIwLjU4NDUgMzE0Ljk2NyAtMTcuNjA5OCAzMjguMzkxQy0xNC42MTY5IDM0MS44OTcgLTEwLjUzOTUgMzUxLjgwNiAtNS40ODI5MiAzNTcuNTk2Qy0wLjU4MTU4MSAzNjMuMjA5IDUuOTg0NTIgMzY1Ljc3OCAxNC4xMzUzIDM2NS42OTVDMjIuMzg3NiAzNjUuNjExIDMyLjIwNDQgMzYyLjc5NCA0My4yMjE2IDM1Ny41OTdDNjUuMjQ0NCAzNDcuMjEgOTEuMjYzMSAzMjcuNzAyIDExNy43IDMwMy43NkMxNzAuNTQ5IDI1NS45IDIyNC4zNzQgMTkwLjk2MiAyNTAuMjggMTQ3Ljk4MkMyNzYuMTAyIDEwNS4xMzcgMjg0LjQ0NSA2Ny4wNjkzIDI4MS4wMzIgMzMuNjA5N0MyNzcuNjE5IDAuMTM3Nzg3IDI2Mi40MTIgLTI5LjAxOTMgMjQwLjYxOCAtNTMuOTc1OUMyMTguNzM3IC03OS4wMzE4IDE4MS42NDQgLTEwOS42ODEgMTQzLjc2MiAtMTIzLjMzOUMxMjQuODQ3IC0xMzAuMTU4IDEwNS45NTEgLTEzMi42NjQgODguNzI0MiAtMTI4LjM1WiIgZmlsbD0idXJsKCNwYWludDNfbGluZWFyXzMxMTZfOTU4KSIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTE0My4yNDIgLTkyLjIzNzVDMTc2Ljc4MyAtODAuMTQ1MiAyMDkuMjYgLTUzLjIyOSAyMjguMzc2IC0zMS4zMzg3QzI0Ny41NzkgLTkuMzQ4OTIgMjYxLjE5NCAxNi41OTkzIDI2NC4yNTEgNDYuNTc2QzI2Ny4zMDkgNzYuNTY0OSAyNTkuNzcxIDExMC4yODkgMjM3LjE4NCAxNDcuNzY0QzIxNC42NzkgMTg1LjEwMyAxNjguMjAxIDI0MS4xNCAxMjIuNiAyODIuNDM4Qzk5LjgxMTUgMzAzLjA3NSA3Ny4wNjg1IDMyMC4xOTMgNTcuNTExNSAzMjkuNDE3QzQ3LjczODcgMzM0LjAyNyAzOC41NjA5IDMzNi43NjMgMzAuNDUzOSAzMzYuODQ2QzIyLjI0NTIgMzM2LjkyOSAxNS4wODcyIDMzNC4yOCA5LjczOTM0IDMyOC4xNTZDNC41NDY3MiAzMjIuMjEgMC44MjQ5NzYgMzEyLjY5IC0xLjc5NDQ4IDMwMC44NjlDLTQuNDMyMDcgMjg4Ljk2NiAtNi4wMjQ1OSAyNzQuMzggLTYuNzIxNyAyNTcuOTgyQy04LjExNjI1IDIyNS4xNzYgLTUuOTM4MTggMTg0LjgyNyAtMS4xODQyNCAxNDMuNTc5QzMuNTcwNzYgMTAyLjMyMiAxMC45MTIxIDYwLjA4NSAxOS44NzI3IDIzLjQ5MjdDMjguODE0OSAtMTMuMDI0MiAzOS40MjkyIC00NC4xNzQyIDUwLjgyNjUgLTYzLjA4MzlDNjIuMzI2NSAtODIuMTY0IDc2LjkzNzMgLTkyLjYzNzIgOTMuMDk0NiAtOTYuNjgzQzEwOS4xNjcgLTEwMC43MDcgMTI2LjQ0NSAtOTguMjkzIDE0My4yNDIgLTkyLjIzNzVaTTk0LjQzMDUgLTkxLjM0NzhDNzkuODUwOCAtODcuNjk3IDY2LjM4MDEgLTc4LjIzNSA1NS41MzcgLTYwLjI0NDdDNDQuNTkxMSAtNDIuMDgzOSAzNC4xMzIxIC0xMS42MTQxIDI1LjIxNDkgMjQuODAwOUMxNi4zMTYxIDYxLjE0MDQgOS4wMTE5NiAxMDMuMTQ4IDQuMjc5NTkgMTQ0LjIwOUMtMC40NTM4NTIgMTg1LjI3OSAtMi42MDUwNiAyMjUuMzIzIC0xLjIyNjY2IDI1Ny43NDhDLTAuNTM3Mjg2IDI3My45NjUgMS4wMzIyMyAyODguMjAzIDMuNTc1MjYgMjk5LjY3OUM2LjEzNjQzIDMxMS4yMzcgOS42MTM4OSAzMTkuNjUxIDEzLjg4MjEgMzI0LjUzOUMxNy45OTUgMzI5LjI0OCAyMy41MDU0IDMzMS40MTYgMzAuMzk3NyAzMzEuMzQ2QzM3LjM5MTYgMzMxLjI3NCA0NS43NDcyIDMyOC44ODUgNTUuMTY1MiAzMjQuNDQzQzczLjk4OTUgMzE1LjU2NCA5Ni4yNTcyIDI5OC44NzQgMTE4LjkwOCAyNzguMzYxQzE2NC4xODMgMjM3LjM1OCAyMTAuMjkyIDE4MS43MjYgMjMyLjQ3NCAxNDQuOTI0QzI1NC41NzMgMTA4LjI1OCAyNjEuNjk0IDc1LjcxMjkgMjU4Ljc3OSA0Ny4xMzRDMjU1Ljg2NCAxOC41NDI3IDI0Mi44NzQgLTYuMzc1NTggMjI0LjIzNCAtMjcuNzIwOUMyMDUuNTA3IC00OS4xNjU2IDE3My43NjUgLTc1LjM4NyAxNDEuMzc3IC04Ny4wNjM0QzEyNS4yMDkgLTkyLjg5MjMgMTA5LjA5NiAtOTUuMDE5OSA5NC40MzA1IC05MS4zNDc4WiIgZmlsbD0idXJsKCNwYWludDRfbGluZWFyXzMxMTZfOTU4KSIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTE0MC44NTcgLTU1Ljk2MjVDMTY4LjkwNCAtNDUuODUxIDE5Ni4wMjkgLTIzLjM2MjkgMjExLjk5MiAtNS4wODM3M0MyMjguMDQxIDEzLjI5NDggMjM5LjQzOSAzNS4wMDQxIDI0MS45OTkgNjAuMTAwMUMyNDQuNTU5IDg1LjIwODQgMjM4LjI0MiAxMTMuNDEgMjE5LjM4IDE0NC43MDZDMjAwLjU5OCAxNzUuODY3IDE2MS44MzUgMjIyLjU5OSAxMjMuODA3IDI1Ny4wMzhDMTA0LjgwNiAyNzQuMjQ2IDg1LjgxMzggMjg4LjU0NyA2OS40NTUxIDI5Ni4yNjNDNjEuMjgxNiAzMDAuMTE4IDUzLjU2NDkgMzAyLjQyNyA0Ni43MTYzIDMwMi40OTdDMzkuNzY2MSAzMDIuNTY4IDMzLjY2MzggMzAwLjMyIDI5LjEwNDQgMjk1LjA5OUMyNC43MDAxIDI5MC4wNTYgMjEuNTc4MyAyODIuMDMgMTkuMzkwNiAyNzIuMTU3QzE3LjE4NDcgMjYyLjIwMiAxNS44NTU3IDI1MC4wMTggMTUuMjc0MSAyMzYuMzM4QzE0LjExMDYgMjA4Ljk2OCAxNS45Mjc5IDE3NS4zMTkgMTkuODkxMiAxNDAuOTNDMjMuODU1NiAxMDYuNTMzIDI5Ljk3NjQgNzEuMzE2MyAzNy40NDg4IDQwLjgwMTZDNDQuOTAyNyAxMC4zNjI0IDUzLjc2MDkgLTE1LjY1MjYgNjMuMjk2MiAtMzEuNDczMUM3Mi45MzQyIC00Ny40NjQxIDg1LjIwNSAtNTYuMjc2MSA5OC44MDA4IC01OS42ODA1QzExMi4zMTEgLTYzLjA2MzYgMTI2LjgwOCAtNjEuMDI3NyAxNDAuODU3IC01NS45NjI1Wk0xMDAuMTM3IC01NC4zNDUzQzg4LjExODUgLTUxLjMzNTggNzYuOTg3OSAtNDMuNTM1MSA2OC4wMDY3IC0yOC42MzM5TDY1LjY1MTUgLTMwLjA1MzVMNjguMDA2NyAtMjguNjMzOUM1OC45MjI4IC0xMy41NjI0IDUwLjIxOTkgMTEuNzcyNSA0Mi43OTA5IDQyLjEwOThDMzUuMzgwNSA3Mi4zNzE4IDI5LjI5NjggMTA3LjM1OSAyNS4zNTUgMTQxLjU2QzIxLjQxMjIgMTc1Ljc3IDE5LjYyMTggMjA5LjExNSAyMC43NjkxIDIzNi4xMDRDMjEuMzQzIDI0OS42MDMgMjIuNjQ5IDI2MS40MzkgMjQuNzYwMyAyNzAuOTY3QzI2Ljg4OTggMjgwLjU3NyAyOS43NjczIDI4Ny40OTYgMzMuMjQ3MSAyOTEuNDgxTDMxLjE3NTcgMjkzLjI5TDMzLjI0NzEgMjkxLjQ4MUMzNi41NzE2IDI5NS4yODggNDEuMDI2MiAyOTcuMDU1IDQ2LjY2MDEgMjk2Ljk5N0M1Mi4zOTU2IDI5Ni45MzggNTkuMjkwMSAyOTQuOTc2IDY3LjEwODggMjkxLjI4OEM4Mi43MzQ3IDI4My45MTggMTAxLjI1MiAyNzAuMDQ1IDEyMC4xMTUgMjUyLjk2MUMxNTcuODE4IDIxOC44MTcgMTk2LjIxMSAxNzIuNDkxIDIxNC42NjkgMTQxLjg2N0MyMzMuMDQ1IDExMS4zNzkgMjM4Ljk0NCA4NC4zNTY0IDIzNi41MjcgNjAuNjU4MUMyMzQuMTA5IDM2Ljk0NzUgMjIzLjMzNiAxNi4yNjgxIDIwNy44NDkgLTEuNDY2MDJDMTkyLjI3NiAtMTkuMjk5NSAxNjUuODg2IC00MS4wOTI4IDEzOC45OTIgLTUwLjc4ODVDMTI1LjU3MSAtNTUuNjI3IDExMi4yNCAtNTcuMzc2IDEwMC4xMzcgLTU0LjM0NTNaIiBmaWxsPSJ1cmwoI3BhaW50NV9saW5lYXJfMzExNl85NTgpIi8+CjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMTM4LjQ3MiAtMTkuNjg3NUMxNjEuMDI1IC0xMS41NTY3IDE4Mi43OTkgNi41MDMzOCAxOTUuNjA4IDIxLjE3MTJDMjA4LjUwNCAzNS45Mzg0IDIxNy42ODQgNTMuNDA4OSAyMTkuNzQ2IDczLjYyNDJDMjIxLjgwOSA5My44NTE4IDIxNi43MTMgMTE2LjUzMSAyMDEuNTc0IDE0MS42NDlDMTg2LjUxNyAxNjYuNjMxIDE1NS40NyAyMDQuMDU2IDEyNS4wMTUgMjMxLjYzN0MxMDkuOCAyNDUuNDE2IDk0LjU1ODggMjU2Ljg5OSA4MS4zOTg2IDI2My4xMDZDNzQuODI0MyAyNjYuMjA3IDY4LjU2ODcgMjY4LjA4OCA2Mi45Nzg1IDI2OC4xNDVDNTcuMjg2NyAyNjguMjAzIDUyLjI0MDEgMjY2LjM1NyA0OC40NjkgMjYyLjAzOUM0NC44NTMyIDI1Ny44OTggNDIuMzMxMyAyNTEuMzY3IDQwLjU3NTMgMjQzLjQ0M0MzOC44MDEyIDIzNS40MzcgMzcuNzM1NiAyMjUuNjU1IDM3LjI2OTYgMjE0LjY5MkMzNi4zMzcyIDE5Mi43NTkgMzcuNzkzNyAxNjUuODA5IDQwLjk2NjQgMTM4LjI4MUM0NC4xNDAyIDExMC43NDMgNDkuMDQwNiA4Mi41NDcyIDU1LjAyNDcgNTguMTEwM0M2MC45OTAzIDMzLjc0ODggNjguMDkyNCAxMi44Njg4IDc1Ljc2NTggMC4xMzc1MzNDODMuNTQyIC0xMi43NjQyIDkzLjQ3MjYgLTE5LjkxNSAxMDQuNTA3IC0yMi42NzhDMTE1LjQ1NiAtMjUuNDE5NyAxMjcuMTcgLTIzLjc2MjIgMTM4LjQ3MiAtMTkuNjg3NVpNMTA1Ljg0MyAtMTcuMzQyOEM5Ni4zODYxIC0xNC45NzQ3IDg3LjU5NTYgLTguODM1MjUgODAuNDc2NCAyLjk3NjY3TDc4LjEyMTEgMS41NTcxTDgwLjQ3NjQgMi45NzY2OEM3My4yNTQzIDE0Ljk1OTEgNjYuMzA3NSAzNS4xNTg5IDYwLjM2NjggNTkuNDE4NUM1NC40NDQ2IDgzLjYwMjcgNDkuNTgxNCAxMTEuNTY5IDQ2LjQzMDMgMTM4LjkxQzQzLjI3ODEgMTY2LjI2MSA0MS44NDg0IDE5Mi45MDUgNDIuNzY0NiAyMTQuNDU5QzQzLjIyMjkgMjI1LjIzOSA0NC4yNjU1IDIzNC42NzQgNDUuOTQ1MSAyNDIuMjUzQzQ3LjY0MjggMjQ5LjkxNSA0OS45MjA0IDI1NS4zMzkgNTIuNjExNyAyNTguNDIxQzU1LjE0NzkgMjYxLjMyNSA1OC41NDY5IDI2Mi42OSA2Mi45MjI0IDI2Mi42NDZDNjcuMzk5NSAyNjIuNiA3Mi44MzI5IDI2MS4wNjUgNzkuMDUyNCAyNTguMTMxQzkxLjQ3OTggMjUyLjI3IDEwNi4yNDYgMjQxLjIxNCAxMjEuMzIzIDIyNy41NkMxNTEuNDUzIDIwMC4yNzUgMTgyLjEzIDE2My4yNTUgMTk2Ljg2NCAxMzguODFDMjExLjUxNiAxMTQuNSAyMTYuMTkzIDkyLjk5OTggMjE0LjI3NCA3NC4xODIyQzIxMi4zNTQgNTUuMzUyMyAyMDMuNzk4IDM4LjkxMTggMTkxLjQ2NSAyNC43ODg5QzE3OS4wNDUgMTAuNTY2NyAxNTguMDA3IC02Ljc5ODQgMTM2LjYwNyAtMTQuNTEzNEMxMjUuOTMzIC0xOC4zNjE2IDExNS4zODUgLTE5LjczMjEgMTA1Ljg0MyAtMTcuMzQyOFoiIGZpbGw9InVybCgjcGFpbnQ2X2xpbmVhcl8zMTE2Xzk1OCkiLz4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xMzYuMDg3IDE2LjU4NzZDMTUzLjE0NiAyMi43Mzc3IDE2OS41NjggMzYuMzY5NSAxNzkuMjI0IDQ3LjQyNjFDMTg4Ljk2NiA1OC41ODIgMTk1LjkzIDcxLjgxMzYgMTk3LjQ5NCA4Ny4xNDgzQzE5OS4wNTkgMTAyLjQ5NSAxOTUuMTg1IDExOS42NTIgMTgzLjc3IDEzOC41OTJDMTcyLjQzNiAxNTcuMzk1IDE0OS4xMDUgMTg1LjUxNSAxMjYuMjIzIDIwNi4yMzhDMTE0Ljc5NCAyMTYuNTg3IDEwMy4zMDQgMjI1LjI1MyA5My4zNDIzIDIyOS45NTJDODguMzY3MiAyMzIuMjk4IDgzLjU3MjggMjMzLjc1MyA3OS4yNDEgMjMzLjc5N0M3NC44MDc3IDIzMy44NDIgNzAuODE2NyAyMzIuMzk4IDY3LjgzNDEgMjI4Ljk4Mkw2OS45MDU0IDIyNy4xNzNMNjcuODM0MSAyMjguOTgyQzY1LjAwNjYgMjI1Ljc0NCA2My4wODQ3IDIyMC43MDggNjEuNzYwNCAyMTQuNzMyQzYwLjQxNzkgMjA4LjY3MyA1OS42MTU5IDIwMS4yOTMgNTkuMjY1NCAxOTMuMDQ5QzU4LjU2NDEgMTc2LjU1MSA1OS42NTk4IDE1Ni4zIDYyLjA0MTkgMTM1LjYzMkM2NC40MjUxIDExNC45NTQgNjguMTA1IDkzLjc3ODQgNzIuNjAwOCA3NS40MTkxQzc3LjA3ODIgNTcuMTM1MiA4Mi40MjQyIDQxLjM5MDIgODguMjM1NyAzMS43NDgxQzk0LjE0OTkgMjEuOTM1NiAxMDEuNzQgMTYuNDQ2MiAxMTAuMjEzIDE0LjMyNDVDMTE4LjYwMSAxMi4yMjQyIDEyNy41MzIgMTMuNTAzMiAxMzYuMDg3IDE2LjU4NzZaTTExMS41NDkgMTkuNjU5OEMxMDQuNjU0IDIxLjM4NjQgOTguMjAzNSAyNS44NjQ2IDkyLjk0NjIgMzQuNTg3M0w5MC41OTA5IDMzLjE2NzdMOTIuOTQ2MiAzNC41ODczQzg3LjU4NjEgNDMuNDgwNSA4Mi4zOTU0IDU4LjU0NTMgNzcuOTQzIDc2LjcyNzNDNzMuNTA5IDk0LjgzMzkgNjkuODY2MyAxMTUuNzggNjcuNTA1NyAxMzYuMjYxQzY1LjE0NDEgMTU2Ljc1MiA2NC4wNzUyIDE3Ni42OTggNjQuNzYwNCAxOTIuODE1QzY1LjEwMzIgMjAwLjg3OCA2NS44ODIyIDIwNy45MSA2Ny4xMzAxIDIxMy41NDJDNjguMzk2MSAyMTkuMjU1IDcwLjA3MzggMjIzLjE4NSA3MS45NzY4IDIyNS4zNjRMNjkuOTIyNCAyMjcuMTU4TDcxLjk3NjggMjI1LjM2NEM3My43MjQ1IDIyNy4zNjYgNzYuMDY3OCAyMjguMzI5IDc5LjE4NDkgMjI4LjI5OEM4Mi40MDM2IDIyOC4yNjUgODYuMzc1OCAyMjcuMTU3IDkwLjk5NjEgMjI0Ljk3N0MxMDAuMjI1IDIyMC42MjQgMTExLjI0IDIxMi4zODYgMTIyLjUzMSAyMDIuMTYxQzE0NS4wODcgMTgxLjczMyAxNjguMDQ5IDE1NC4wMTkgMTc5LjA1OSAxMzUuNzUyQzE4OS45ODcgMTE3LjYyMSAxOTMuNDQzIDEwMS42NDMgMTkyLjAyMiA4Ny43MDYzQzE5MC41OTkgNzMuNzU3IDE4NC4yNiA2MS41NTU0IDE3NS4wODEgNTEuMDQzOEMxNjUuODE1IDQwLjQzMjkgMTUwLjEyOCAyNy40OTU5IDEzNC4yMjIgMjEuNzYxN0MxMjYuMjk1IDE4LjkwMzkgMTE4LjUzIDE3LjkxMTggMTExLjU0OSAxOS42NTk4WiIgZmlsbD0idXJsKCNwYWludDdfbGluZWFyXzMxMTZfOTU4KSIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzMy43MDIgNTIuODYyOUMxNDUuMjY3IDU3LjAzMjMgMTU2LjMzOCA2Ni4yMzYgMTYyLjg0IDczLjY4MTRDMTY5LjQyOCA4MS4yMjYgMTc0LjE3NSA5MC4yMTg4IDE3NS4yNDEgMTAwLjY3M0MxNzYuMzA4IDExMS4xMzkgMTczLjY1NiAxMjIuNzc0IDE2NS45NjUgMTM1LjUzNEMxNTguMzU1IDE0OC4xNiAxNDIuNzM5IDE2Ni45NzQgMTI3LjQzIDE4MC44MzhDMTE5Ljc4OCAxODcuNzU5IDExMi4wNDkgMTkzLjYwNyAxMDUuMjg2IDE5Ni43OTdDMTAxLjkxIDE5OC4zODkgOTguNTc2NiAxOTkuNDE3IDk1LjUwMzIgMTk5LjQ0OEM5Mi4zMjgzIDE5OS40ODEgODkuMzkzIDE5OC40MzcgODcuMTk4OCAxOTUuOTI1Qzg1LjE1OTcgMTkzLjU5IDgzLjgzNzcgMTkwLjA0OCA4Mi45NDUxIDE4Ni4wMkM4Mi4wMzQ0IDE4MS45MSA4MS40OTU5IDE3Ni45MzIgODEuMjYwOSAxNzEuNDA1QzgwLjc5MDcgMTYwLjM0MyA4MS41MjU2IDE0Ni43OTIgODMuMTE3MSAxMzIuOTgzQzg0LjcwOTYgMTE5LjE2NSA4Ny4xNjkxIDEwNS4wMSA5MC4xNzY2IDkyLjcyODJDOTMuMTY1NyA4MC41MjIgOTYuNzU1NiA2OS45MTE5IDEwMC43MDUgNjMuMzU5MUMxMDQuNzU3IDU2LjYzNTggMTEwLjAwOCA1Mi44MDc2IDExNS45MTkgNTEuMzI3M0MxMjEuNzQ2IDQ5Ljg2ODQgMTI3Ljg5NCA1MC43Njg5IDEzMy43MDIgNTIuODYyOVpNMTE3LjI1NSA1Ni42NjI2QzExMi45MjEgNTcuNzQ3OCAxMDguODExIDYwLjU2NDggMTA1LjQxNiA2Ni4xOTgzTDEwMy4wNiA2NC43Nzg3TDEwNS40MTYgNjYuMTk4M0MxMDEuOTE3IDcyLjAwMjIgOTguNDgyOSA4MS45MzIxIDk1LjUxODggOTQuMDM2NEM5Mi41NzMyIDEwNi4wNjUgOTAuMTUwOCAxMTkuOTkxIDg4LjU4MDkgMTMzLjYxM0M4Ny4wMSAxNDcuMjQ0IDg2LjMwMTkgMTYwLjQ5IDg2Ljc1NiAxNzEuMTcxQzg2Ljk4MzIgMTc2LjUxNiA4Ny40OTg3IDE4MS4xNDcgODguMzE0OSAxODQuODNDODkuMTQ5MiAxODguNTk1IDkwLjIyNjkgMTkxLjAzMSA5MS4zNDE1IDE5Mi4zMDdDOTIuMzAwOCAxOTMuNDA1IDkzLjU4ODQgMTkzLjk2OCA5NS40NDcxIDE5My45NDlDOTcuNDA3MyAxOTMuOTI5IDk5LjkxODUgMTkzLjI0OCAxMDIuOTM5IDE5MS44MjNDMTA4Ljk3IDE4OC45NzggMTE2LjIzNCAxODMuNTU3IDEyMy43MzggMTc2Ljc2MUMxMzguNzIyIDE2My4xOTIgMTUzLjk2OCAxNDQuNzg0IDE2MS4yNTQgMTMyLjY5NUwxNjMuNjA5IDEzNC4xMTVMMTYxLjI1NCAxMzIuNjk1QzE2OC40NTggMTIwLjc0MiAxNzAuNjkzIDExMC4yODcgMTY5Ljc2OSAxMDEuMjMxQzE2OC44NDQgOTIuMTYyMiAxNjQuNzIzIDg0LjE5OTQgMTU4LjY5NyA3Ny4yOTkxTDE2MC43NjggNzUuNDkwMkwxNTguNjk3IDc3LjI5OTFDMTUyLjU4NCA3MC4yOTk0IDE0Mi4yNDkgNjEuNzkwNSAxMzEuODM3IDU4LjAzNjlDMTI2LjY1NyA1Ni4xNjk1IDEyMS42NzUgNTUuNTU2IDExNy4yNTUgNTYuNjYyNloiIGZpbGw9InVybCgjcGFpbnQ4X2xpbmVhcl8zMTE2Xzk1OCkiLz4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xMzEuMzE4IDg5LjEzNzlDMTM3LjM4OCA5MS4zMjY1IDE0My4xMDcgOTYuMTAyMSAxNDYuNDU2IDk5LjkzNjJDMTQ5Ljg5MSAxMDMuODcgMTUyLjQyIDEwOC42MjMgMTUyLjk4OCAxMTQuMTk3QzE1My41NTggMTE5Ljc4MiAxNTIuMTI3IDEyNS44OTUgMTQ4LjE2IDEzMi40NzdMMTQ1LjgwNSAxMzEuMDU3TDE0OC4xNiAxMzIuNDc3QzE0NC4yNzUgMTM4LjkyNCAxMzYuMzc0IDE0OC40MzIgMTI4LjYzOCAxNTUuNDM4QzEyNC43ODMgMTU4LjkzIDEyMC43OTQgMTYxLjk2MSAxMTcuMjMgMTYzLjY0MkMxMTUuNDUzIDE2NC40OCAxMTMuNTgxIDE2NS4wODEgMTExLjc2NiAxNjUuMDk5QzEwOS44NDkgMTY1LjExOSAxMDcuOTcgMTY0LjQ3NyAxMDYuNTY0IDE2Mi44NjdDMTA1LjMxMyAxNjEuNDM1IDEwNC41OTEgMTU5LjM4NyAxMDQuMTMgMTU3LjMwN0MxMDMuNjUxIDE1NS4xNDYgMTAzLjM3NiAxNTIuNTcgMTAzLjI1NyAxNDkuNzYxQzEwMy4wMTggMTQ0LjEzNSAxMDMuMzkyIDEzNy4yODMgMTA0LjE5MyAxMzAuMzM0QzEwNC45OTUgMTIzLjM3NiAxMDYuMjM0IDExNi4yNDEgMTA3Ljc1MyAxMTAuMDM3QzEwOS4yNTQgMTAzLjkwOCAxMTEuMDg3IDk4LjQzMzMgMTEzLjE3NSA5NC45Njk3QzExNS4zNjUgOTEuMzM1NiAxMTguMjc2IDg5LjE2ODcgMTIxLjYyNiA4OC4zMjk4QzEyNC44OTEgODcuNTEyMyAxMjguMjU2IDg4LjAzNDIgMTMxLjMxOCA4OS4xMzc5Wk0xMjIuOTYyIDkzLjY2NTFDMTIxLjE4OSA5NC4xMDkgMTE5LjQxOSA5NS4yNjQ2IDExNy44ODUgOTcuODA4OUMxMTYuMjQ5IDEwMC41MjQgMTE0LjU3MSAxMDUuMzE5IDExMy4wOTUgMTExLjM0NUMxMTEuNjM4IDExNy4yOTYgMTEwLjQzNiAxMjQuMjAyIDEwOS42NTcgMTMwLjk2NEMxMDguODc2IDEzNy43MzUgMTA4LjUyOSAxNDQuMjgxIDEwOC43NTIgMTQ5LjUyN0MxMDguODY0IDE1Mi4xNTQgMTA5LjExNiAxNTQuMzgyIDEwOS41IDE1Ni4xMTdDMTA5LjkwMyAxNTcuOTM0IDExMC4zOCAxNTguODc1IDExMC43MDcgMTU5LjI0OUwxMTAuNzA3IDE1OS4yNDlDMTEwLjg3OCAxNTkuNDQ1IDExMS4xMDkgMTU5LjYwNSAxMTEuNzEgMTU5LjU5OUMxMTIuNDExIDE1OS41OTIgMTEzLjQ2MSAxNTkuMzM4IDExNC44ODMgMTU4LjY2OEMxMTcuNzE1IDE1Ny4zMzIgMTIxLjIyOSAxNTQuNzI4IDEyNC45NDYgMTUxLjM2MUMxMzIuMzU3IDE0NC42NTEgMTM5Ljg4OCAxMzUuNTQ4IDE0My40NSAxMjkuNjM4QzE0Ni45MyAxMjMuODYzIDE0Ny45NDMgMTE4LjkzIDE0Ny41MTcgMTE0Ljc1NUMxNDcuMDkgMTEwLjU2NyAxNDUuMTg1IDEwNi44NDMgMTQyLjMxMyAxMDMuNTU0QzEzOS4zNTQgMTAwLjE2NSAxMzQuMzcgOTYuMDg0OCAxMjkuNDUyIDk0LjMxMkMxMjcuMDIgOTMuNDM0OSAxMjQuODIgOTMuMTk5OSAxMjIuOTYyIDkzLjY2NTFaIiBmaWxsPSJ1cmwoI3BhaW50OV9saW5lYXJfMzExNl85NTgpIi8+CjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMjMwLjg3NCAxMTEuNzY0QzIzNi42MTMgMTA1LjUyOCAyMzYuMTQzIDk1Ljg4IDIyOS44MjggOTAuMjE0M0MyMjMuNTEzIDg0LjU0ODggMjEzLjc0MSA4NS4wMTEgMjA4LjAwNSA5MS4yNDczTDE2Ni44NTQgMTM1Ljk3MUwxNTAuMjE3IDExOC43MjJDMTQ0LjMzMyAxMTIuNjIxIDEzNC41NTMgMTEyLjM4NSAxMjguMzc0IDExOC4xOTZDMTIyLjE5NSAxMjQuMDA3IDEyMS45NTcgMTMzLjY2MyAxMjcuODQxIDEzOS43NjRMMTU1LjkzMyAxNjguODg5QzE1OC44OTIgMTcxLjk1NyAxNjMuMDExIDE3My42NzIgMTY3LjMwMyAxNzMuNjIyQzE3MS41OTMgMTczLjU3MiAxNzUuNjcxIDE3MS43NjMgMTc4LjU1NSAxNjguNjI2TDIzMC44NzQgMTExLjc2NFpNMTE0LjQwMyAxNTAuMDU3TDk2LjQ3OCAxMzIuMTk4TDExNC40MDMgMTE0LjM0QzExOC4yNzggMTEwLjUxMyAxMjAuMjE2IDEwNy4yNzEgMTIwLjIxNiAxMDQuNjEzQzEyMC4yMTYgMTAxLjg0OSAxMTguMjc4IDk4LjU1MzggMTE0LjQwMyA5NC43MjdDMTEwLjUyNyA5MC45MDAzIDEwNy4yNDQgODguOTg2OCAxMDQuNTUyIDg4Ljk4NjhDMTAxLjg2MSA4OC45ODY4IDk4LjU3NzMgOTAuOTAwMyA5NC43MDE4IDk0LjcyN0w3Ni45Mzg4IDExMi41ODZMNTkuMDE0MyA5NC43MjdDNTUuMTM4OCA5MC45MDAzIDUxLjg1NTIgODguOTg2OCA0OS4xNjM3IDg4Ljk4NjhDNDYuNTggODguOTg2OCA0My4yOTY1IDkwLjkwMDMgMzkuMzEzMyA5NC43MjdDMzUuNDM3OCA5OC41NTM4IDMzLjUgMTAxLjg0OSAzMy41IDEwNC42MTNDMzMuNSAxMDcuMjcxIDM1LjQzNzggMTEwLjUxMyAzOS4zMTMzIDExNC4zNEw1Ny4yMzggMTMyLjE5OEwzOS4zMTMzIDE1MC4wNTdDMzUuNDM3OCAxNTMuODg0IDMzLjUgMTU3LjE3OSAzMy41IDE1OS45NDNDMzMuNSAxNjIuNiAzNS40Mzc4IDE2NS44NDMgMzkuMzEzMyAxNjkuNjY5QzQzLjI5NjUgMTczLjM5IDQ2LjU4IDE3NS4yNSA0OS4xNjM3IDE3NS4yNUM1MS44NTUyIDE3NS4yNSA1NS4xMzg4IDE3My4zMzcgNTkuMDE0MyAxNjkuNTFMNzYuOTM4OCAxNTEuODExTDk0LjcwMTggMTY5LjUxQzk4LjU3NzMgMTczLjMzNyAxMDEuODYxIDE3NS4yNSAxMDQuNTUyIDE3NS4yNUMxMDcuMjQ0IDE3NS4yNSAxMTAuNTI3IDE3My4zOSAxMTQuNDAzIDE2OS42NjlDMTE4LjI3OCAxNjUuODQzIDEyMC4yMTYgMTYyLjYgMTIwLjIxNiAxNTkuOTQzQzEyMC4yMTYgMTU3LjE3OSAxMTguMjc4IDE1My44ODQgMTE0LjQwMyAxNTAuMDU3WiIgZmlsbD0id2hpdGUiLz4KPC9nPgo8ZGVmcz4KPGxpbmVhckdyYWRpZW50IGlkPSJwYWludDBfbGluZWFyXzMxMTZfOTU4IiB4MT0iMTg1LjE2NyIgeTE9Ii0yMzIuOTM4IiB4Mj0iNzAuODMyOSIgeTI9IjQ4OC45MzciIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agb2Zmc2V0PSIwLjQ1IiBzdG9wLWNvbG9yPSIjMjI0N0ZGIi8+CjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iIzBEMUM2NSIvPgo8L2xpbmVhckdyYWRpZW50Pgo8bGluZWFyR3JhZGllbnQgaWQ9InBhaW50MV9saW5lYXJfMzExNl85NTgiIHgxPSIxNzkuNDUiIHkxPSItMTk2Ljg0NCIgeDI9Ijc2LjU0OTgiIHkyPSI0NTIuODQ1IiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+CjxzdG9wIG9mZnNldD0iMC40NSIgc3RvcC1jb2xvcj0iIzIyNDdGRiIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiMwRDFDNjUiLz4KPC9saW5lYXJHcmFkaWVudD4KPGxpbmVhckdyYWRpZW50IGlkPSJwYWludDJfbGluZWFyXzMxMTZfOTU4IiB4MT0iMTczLjczMyIgeTE9Ii0xNjAuNzUiIHgyPSI4Mi4yNjYyIiB5Mj0iNDE2Ljc1IiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+CjxzdG9wIG9mZnNldD0iMC40NSIgc3RvcC1jb2xvcj0iIzIyNDdGRiIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiMwRDFDNjUiLz4KPC9saW5lYXJHcmFkaWVudD4KPGxpbmVhckdyYWRpZW50IGlkPSJwYWludDNfbGluZWFyXzMxMTZfOTU4IiB4MT0iMTY4LjAxNyIgeTE9Ii0xMjQuNjU3IiB4Mj0iODcuOTgzMSIgeTI9IjM4MC42NTgiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agb2Zmc2V0PSIwLjQ1IiBzdG9wLWNvbG9yPSIjMjI0N0ZGIi8+CjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iIzBEMUM2NSIvPgo8L2xpbmVhckdyYWRpZW50Pgo8bGluZWFyR3JhZGllbnQgaWQ9InBhaW50NF9saW5lYXJfMzExNl85NTgiIHgxPSIxNjIuMyIgeTE9Ii04OC41NjI4IiB4Mj0iOTMuNjk5NyIgeTI9IjM0NC41NjIiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agb2Zmc2V0PSIwLjQ1IiBzdG9wLWNvbG9yPSIjMjI0N0ZGIi8+CjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iIzBEMUM2NSIvPgo8L2xpbmVhckdyYWRpZW50Pgo8bGluZWFyR3JhZGllbnQgaWQ9InBhaW50NV9saW5lYXJfMzExNl85NTgiIHgxPSIxNTYuNTgzIiB5MT0iLTUyLjQ2OSIgeDI9Ijk5LjQxNjUiIHkyPSIzMDguNDciIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agb2Zmc2V0PSIwLjQ1IiBzdG9wLWNvbG9yPSIjMjI0N0ZGIi8+CjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iIzBEMUM2NSIvPgo8L2xpbmVhckdyYWRpZW50Pgo8bGluZWFyR3JhZGllbnQgaWQ9InBhaW50Nl9saW5lYXJfMzExNl85NTgiIHgxPSIxNTAuODY3IiB5MT0iLTE2LjM3NTMiIHgyPSIxMDUuMTMzIiB5Mj0iMjcyLjM3NSIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPgo8c3RvcCBvZmZzZXQ9IjAuNDUiIHN0b3AtY29sb3I9IiMyMjQ3RkYiLz4KPHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjMEQxQzY1Ii8+CjwvbGluZWFyR3JhZGllbnQ+CjxsaW5lYXJHcmFkaWVudCBpZD0icGFpbnQ3X2xpbmVhcl8zMTE2Xzk1OCIgeDE9IjE0NS4xNSIgeTE9IjE5LjcxODUiIHgyPSIxMTAuODUiIHkyPSIyMzYuMjgxIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+CjxzdG9wIG9mZnNldD0iMC40NSIgc3RvcC1jb2xvcj0iIzIyNDdGRiIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiMwRDFDNjUiLz4KPC9saW5lYXJHcmFkaWVudD4KPGxpbmVhckdyYWRpZW50IGlkPSJwYWludDhfbGluZWFyXzMxMTZfOTU4IiB4MT0iMTM5LjQzMyIgeTE9IjU1LjgxMjUiIHgyPSIxMTYuNTY2IiB5Mj0iMjAwLjE4OCIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPgo8c3RvcCBvZmZzZXQ9IjAuNDUiIHN0b3AtY29sb3I9IiMyMjQ3RkYiLz4KPHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjMEQxQzY1Ii8+CjwvbGluZWFyR3JhZGllbnQ+CjxsaW5lYXJHcmFkaWVudCBpZD0icGFpbnQ5X2xpbmVhcl8zMTE2Xzk1OCIgeDE9IjEzMy43MTciIHkxPSI5MS45MDYzIiB4Mj0iMTIyLjI4MyIgeTI9IjE2NC4wOTQiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agb2Zmc2V0PSIwLjQ1IiBzdG9wLWNvbG9yPSIjMjI0N0ZGIi8+CjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iIzBEMUM2NSIvPgo8L2xpbmVhckdyYWRpZW50Pgo8Y2xpcFBhdGggaWQ9ImNsaXAwXzMxMTZfOTU4Ij4KPHJlY3Qgd2lkdGg9IjI1NiIgaGVpZ2h0PSIyNTYiIHJ4PSI2MCIgZmlsbD0id2hpdGUiLz4KPC9jbGlwUGF0aD4KPC9kZWZzPgo8L3N2Zz4K",
      name: "Xaman",
      id: C,
      type: "Xaman",
      supportsSimulation: !1,
      async connect(c) {
        var Q;
        const O = await this.getProvider(), l = await O.authorize();
        if (l instanceof Error)
          throw new Error(l.message);
        if (!l)
          throw new Error("Xaman Wallet Failed to authorize");
        if (o = !0, !await O.user.networkId)
          throw new Error("Xaman Wallet failed to get network Id");
        const v = localStorage.getItem(a);
        v && await ((Q = e.storage) == null ? void 0 : Q.setItem(a, v)), c != null && c.isReconnecting || await iM(j, {
          authType: "eoa",
          signer: r,
          connectorId: C
        }), c != null && c.chainId && c.chainId !== z.id && (z = e.chains.find((k) => k.id === c.chainId) ?? j.environment.chain);
        const p = {
          accounts: await this.getAccounts(),
          chainId: z.id
        };
        return e.emitter.emit("connect", p), p;
      },
      async switchChain({ chainId: c }) {
        const O = e.chains.find((f) => f.id === c);
        if (!O) throw new P(new R());
        return z = O, await this.getChainId() === c && e.emitter.emit("change", { chainId: c }), O;
      },
      async disconnect() {
        var c;
        i = !1, T && (j.removeUserStateListener(x), T = void 0), r && (r.unsubscribe("showQR", N), r.unsubscribe("signed", u)), (c = e.storage) == null || c.removeItem(a), await (await this.getProvider()).logout(), o = !1, L = void 0, r = void 0, e.emitter.emit("disconnect");
      },
      async getAccounts() {
        if (!await (await this.getProvider()).user.account)
          throw new Error("Xaman Wallet failed to retrieve account");
        const l = await j.getUser();
        return l ? [
          Y(l.profile.eoa),
          Y(l.profile.futurepass)
        ] : [];
      },
      async getChainId() {
        return (z == null ? void 0 : z.id) ?? 0;
      },
      async getProvider() {
        const c = async () => {
          var f;
          if (L)
            return L;
          const l = await ((f = e.storage) == null ? void 0 : f.getItem(
            a,
            null
          ));
          return l && localStorage.setItem(a, l), L = await new Promise((v) => {
            const p = new yM(s);
            p.on("ready", () => {
              v(p);
            }), p.on("loggedout", async () => {
              await this.disconnect();
            }), p.on("success", () => {
              o = !0;
            });
          }), L;
        };
        T || (T = this.onAccountsChanged.bind(this), j.addUserStateListener(x));
        const O = await c();
        return A(O), O;
      },
      async isAuthorized() {
        const c = await j.getUser();
        return c != null && c.profile.sub.startsWith("xrpl") ? o : !1;
      },
      async getClient(c) {
        const O = async (Q) => {
          const k = await this.getAccounts();
          if (k.length < 2)
            throw new Error("Xaman accounts invalid, sign in again");
          const h = k[0];
          return nM({
            address: h,
            async signMessage({ message: m }) {
              if (!r)
                throw new Error("Xaman signer not present");
              return r.signMessage(m);
            },
            async signTypedData(m) {
              throw new Error("Not supported");
            },
            async signTransaction(m) {
              if (console.log("signTransaction", m), !r)
                throw new Error("Xaman signer not present");
              let X = !0;
              Q && Q.toLowerCase() === h.toLowerCase() && (X = !1);
              const cM = await n(), F = xM.evm(cM, r, h);
              await F.evmOverride({
                to: m.to,
                value: m.value,
                data: m.data || "",
                fromFuturePass: X
              });
              const J = await F.signAndSend();
              return console.log("Xaman transaction result", J), J.transactionHash;
            }
          });
        }, l = e.chains.find((Q) => Q.id === (c == null ? void 0 : c.chainId)) || z, f = await O(), v = t();
        return q({
          transport: IM({
            async request({ method: Q, params: k }) {
              return Q === "eth_sendRawTransaction" ? k : v({ chain: l }).request({ method: Q, params: k });
            }
          }),
          chain: l,
          account: f
        }).extend($).extend((Q) => ({
          signer: r,
          async sendTransaction(k) {
            let h = k.account;
            return B(h) && (h = await O(h)), Q.sendTransaction({
              ...k,
              account: h
            });
          },
          async writeContract(k) {
            let h = k.account;
            return B(h) && (h = await O(h)), Q.writeContract({
              ...k,
              account: h
            });
          }
        }));
      },
      onDisconnect() {
      },
      onChainChanged(c) {
        const O = Number(c);
        e.emitter.emit("change", { chainId: O });
      },
      onAccountsChanged: (c) => {
        const O = c.map((l) => Y(l));
        c.length > 0 && e.emitter.emit("connect", {
          chainId: z.id,
          accounts: O
        }), e.emitter.emit("change", {
          accounts: O
        });
      }
    };
  });
}
function hM({
  authClient: s,
  custodialOpt: j
}) {
  let D, I = s.environment.chain, y;
  const g = j.name.toLowerCase(), L = j.subPrefix.toLowerCase(), r = () => {
    var o;
    if ((o = s.userSession) != null && o.eoa)
      return new AM(
        s.environment.signerURL,
        s.environment.idpURL,
        s.userSession.eoa
      );
  };
  return V((o) => {
    var C, d;
    const E = (M) => {
      if (!y) return;
      if (!M)
        return y([]);
      const i = s.getSessionAuthType();
      i && (i === g || i === L.split(":")[1]) && y([M.eoa, M.futurepass]);
    }, a = () => o != null && o.transports ? o.transports[I.id] : MM();
    return {
      name: j.name,
      id: j.id,
      type: "FutureverseCustodial",
      iconLight: (C = j.iconUrls) == null ? void 0 : C.white,
      iconDark: (d = j.iconUrls) == null ? void 0 : d.fullcolor,
      async connect(M) {
        M != null && M.isReconnecting || await iM(s, {
          authType: j.loginHint,
          connectorId: j.id
        }), M != null && M.chainId && M.chainId !== I.id && (I = o.chains.find((z) => z.id === M.chainId) ?? s.environment.chain);
        const i = {
          accounts: await this.getAccounts(),
          chainId: I.id
        };
        return o.emitter.emit("connect", i), i;
      },
      async switchChain({ chainId: M }) {
        const i = o.chains.find((T) => T.id === M);
        if (!i) throw new P(new R());
        return I = i, await this.getChainId() === M && o.emitter.emit("change", { chainId: M }), i;
      },
      disconnect: async () => {
        y && (s.removeUserStateListener(E), y = void 0), o.emitter.emit("disconnect");
      },
      async getAccounts() {
        const M = await s.getUser();
        return M ? [
          Y(M.profile.eoa),
          Y(M.profile.futurepass)
        ] : [];
      },
      async isAuthorized() {
        const M = await s.getUser();
        if (!M)
          return !1;
        const i = M.profile.sub.split(":")[0], z = j.subPrefix.split(":")[0];
        return i === z;
      },
      async getProvider() {
        var M;
        return y || (y = this.onAccountsChanged.bind(this), s.addUserStateListener(E)), D && ((M = D.chain) == null ? void 0 : M.id) === I.id || (D = uM({
          chain: I,
          transport: a()
        })), D;
      },
      async getChainId() {
        return await (await this.getProvider()).getChainId();
      },
      async getClient(M) {
        const i = await this.getAccounts();
        if (i.length === 0)
          throw new Error("Futureverse Custodial user not signed in");
        const z = i[0], T = r();
        if (!T)
          throw new Error("Custodial signer unavailable");
        const w = o.chains.find((n) => n.id === (M == null ? void 0 : M.chainId)) ?? I, U = nM({
          address: Y(z),
          async signMessage({ message: n }) {
            return await T.signMessage(n);
          },
          async signTransaction(n, { serializer: e = gM } = {}) {
            const t = await T.signTransaction(
              e(n)
            ), N = t.slice(0, 66), u = "0x" + t.slice(66, 130), x = "0x" + t.slice(130, 132);
            return e(n, {
              r: N,
              s: u,
              v: DM(x)
            });
          },
          async signTypedData(n) {
            throw new Error("Not supported");
          }
        });
        return q({
          transport: a(),
          chain: w,
          account: U
        }).extend($).extend((n) => ({
          signer: T,
          async sendTransaction(e) {
            return n.sendTransaction({
              ...e,
              account: U
            });
          },
          async writeContract(e) {
            return n.writeContract({
              ...e,
              account: U
            });
          }
        }));
      },
      onDisconnect: () => {
      },
      onChainChanged(M) {
        const i = Number(M);
        o.emitter.emit("change", { chainId: i });
      },
      onAccountsChanged: (M) => {
        const i = M.map((z) => Y(z));
        M.length > 0 && o.emitter.emit("connect", {
          chainId: I.id,
          accounts: i
        }), o.emitter.emit("change", {
          accounts: i
        });
      }
    };
  });
}
const PM = async ({
  walletConnectProjectId: s,
  xamanAPIKey: j,
  xamanOnQRCode: D,
  xamanOnSigned: I,
  authClient: y,
  ssr: g,
  storage: L,
  connectors: r,
  overrideConnectors: o,
  chains: E,
  metamaskDappMetadata: a,
  transports: C,
  trnNode: d
}) => {
  const M = [...E ?? [], y.environment.chain], i = M.reduce(
    (w, U) => {
      const S = C && U.id in C;
      return w[U.id] = S ? C[U.id] : oM(), w;
    },
    {}
  ), T = [
    ...(await y.queryCustodialOptions()).map(
      (w) => hM({
        authClient: y,
        custodialOpt: w
      })
    ),
    lM({
      dappMetadata: a
    }),
    CM({
      appName: "FuturePass",
      enableMobileWalletLink: !0
    }),
    ...j ? [
      kM({
        apiKey: j,
        onQR: D,
        onSign: I,
        authClient: y,
        trnNode: d
      })
    ] : [],
    ...s ? [wM({ projectId: s })] : [],
    ...r || []
  ];
  return rM({
    ssr: g,
    storage: L,
    chains: M,
    connectors: o ?? T,
    transports: i
  });
};
class NM extends Error {
  constructor(j) {
    super(j), this.name = "UnsupportedWallet";
  }
}
const jM = async (s, j) => {
  const D = Z(j);
  try {
    const I = D.find((r) => r.id === s);
    if (!I)
      throw console.log("No connector", s), new Error(`Failed to find connector ${s}`);
    const g = W(j).connector;
    return I !== g && await (g == null ? void 0 : g.disconnect()), await I.isAuthorized() || await TM(j, { connector: I }), await I.getAccounts();
  } catch (I) {
    if (I instanceof NM)
      throw I;
    return null;
  }
}, VM = async (s, j) => {
  const D = Z(s), I = W(s), y = D.find((g) => g.id === j) ?? I.connector;
  y || console.warn("No active connector to disconnect from"), await zM(s, { connector: y });
}, RM = async (s, j, D, I) => {
  const y = Z(D);
  if (await jM(s, D), ["xaman"].includes(s) || s.startsWith("futureverseCustodial"))
    return;
  const g = y.find((a) => a.id === s);
  if (!g)
    throw new Error(`Did not find wagmi connector for ${s}`);
  const L = await eM(D, { connector: g }), r = W(D);
  if (!r.address)
    throw new Error("Wallet not connected");
  const o = r.address, E = tM(L);
  return j.generateFuturepassSignInArgs({
    type: "eoa",
    signer: E,
    address: o,
    extraQueryParams: { connector_id: s },
    ...I
  });
}, XM = async (s, j, D, I) => {
  const y = Z(D);
  if (await jM(s, D), ["xaman"].includes(s) || s.startsWith("futureverseCustodial"))
    return;
  const g = y.find((a) => a.id === s);
  if (!g)
    throw new Error(`Did not find wagmi connector for ${s}`);
  const L = await eM(D, { connector: g }), r = W(D);
  if (!r.address)
    throw new Error("Wallet not connected");
  const o = r.address, E = tM(L);
  await j.signInPass({
    type: "eoa",
    signer: E,
    address: o,
    extraQueryParams: { connector_id: s },
    ...I
  });
};
sM.type = "walletConnectCustom";
function sM(s) {
  const j = s.isNewChainsStale ?? !0, D = s.allowedWalletNames;
  let I, y;
  const g = "eip155";
  let L, r, o, E, a, C;
  return V((d) => ({
    id: s.connectorId,
    name: s.connectorName,
    type: sM.type,
    icon: s.icon,
    async setup() {
      const M = await this.getProvider().catch(() => null);
      M && (o || (o = this.onConnect.bind(this), M.on("connect", o)), a || (a = this.onSessionDelete.bind(this), M.on("session_delete", a)));
    },
    async connect({ chainId: M, ...i } = {}) {
      var z, T, w, U, S, n, e;
      try {
        const t = await this.getProvider();
        if (!t) throw new _();
        E || (E = this.onDisplayUri, t.on("display_uri", E));
        let N = M;
        if (!N) {
          const O = await ((z = d.storage) == null ? void 0 : z.getItem("state")) ?? {};
          d.chains.some(
            (f) => f.id === O.chainId
          ) ? N = O.chainId : N = (T = d.chains[0]) == null ? void 0 : T.id;
        }
        if (!N) throw new Error("No chains found on connector.");
        const u = await this.isChainsStale();
        if (t.session && u && await t.disconnect(), !t.session || u) {
          const O = d.chains.filter((l) => l.id !== N).map((l) => l.id);
          await t.connect({
            optionalChains: [N, ...O],
            ..."pairingTopic" in i ? { pairingTopic: i.pairingTopic } : {}
          }), this.setRequestedChainsIds(d.chains.map((l) => l.id));
        }
        const x = (S = (U = (w = t.session) == null ? void 0 : w.peer) == null ? void 0 : U.metadata) == null ? void 0 : S.name;
        if (console.debug("connecting wallet", (e = (n = t.session) == null ? void 0 : n.peer) == null ? void 0 : e.metadata, { allowedWalletNames: D }), x && !(D != null && D.includes(x)))
          throw console.warn("Unsupported Wallet called from connector", x), await t.disconnect().catch(() => {
          }), new NM(x);
        const A = (await t.enable()).map((O) => Y(O)), c = await this.getChainId();
        return E && (t.removeListener("display_uri", E), E = void 0), o && (t.removeListener("connect", o), o = void 0), L || (L = this.onAccountsChanged.bind(this), t.on("accountsChanged", L)), r || (r = this.onChainChanged.bind(this), t.on("chainChanged", r)), C || (C = this.onDisconnect.bind(this), t.on("disconnect", C)), a || (a = this.onSessionDelete.bind(this), t.on("session_delete", a)), { accounts: A, chainId: c };
      } catch (t) {
        throw /(user rejected|connection request reset)/i.test(
          t == null ? void 0 : t.message
        ) ? new G(t) : t;
      }
    },
    async disconnect() {
      const M = await this.getProvider();
      try {
        await (M == null ? void 0 : M.disconnect());
      } catch (i) {
        if (!/No matching key/i.test(i.message)) throw i;
      } finally {
        r && (M == null || M.removeListener("chainChanged", r), r = void 0), C && (M == null || M.removeListener("disconnect", C), C = void 0), o || (o = this.onConnect.bind(this), M == null || M.on("connect", o)), L && (M == null || M.removeListener("accountsChanged", L), L = void 0), a && (M == null || M.removeListener("session_delete", a), a = void 0), this.setRequestedChainsIds([]);
      }
    },
    async getAccounts() {
      return (await this.getProvider()).accounts.map((i) => Y(i));
    },
    async getProvider({ chainId: M } = {}) {
      var z;
      async function i() {
        const T = d.chains.map((U) => U.id);
        if (!T.length) return;
        const { EthereumProvider: w } = await import("@walletconnect/ethereum-provider");
        return await w.init({
          ...s,
          disableProviderPing: !0,
          optionalChains: T,
          projectId: s.projectId,
          rpcMap: Object.fromEntries(
            d.chains.map((U) => {
              const [S] = aM({
                chain: U,
                transports: d.transports
              });
              return [U.id, S];
            })
          ),
          showQrModal: s.showQrModal ?? !0
        });
      }
      return I || (y || (y = i()), I = await y, I == null || I.events.setMaxListeners(Number.POSITIVE_INFINITY)), M && await ((z = this.switchChain) == null ? void 0 : z.call(this, { chainId: M })), I;
    },
    async getChainId() {
      return (await this.getProvider()).chainId;
    },
    async isAuthorized() {
      var M, i, z;
      try {
        const [T, w] = await Promise.all([
          this.getAccounts(),
          this.getProvider()
        ]);
        if (!T.length) return !1;
        if (await this.isChainsStale() && w.session)
          return await w.disconnect().catch(() => {
          }), !1;
        const S = (z = (i = (M = w.session) == null ? void 0 : M.peer) == null ? void 0 : i.metadata) == null ? void 0 : z.name;
        return S && !(D != null && D.includes(S)) ? (await w.disconnect().catch(() => {
        }), console.warn("Unsupported Wallet called from connector", S), !1) : !0;
      } catch {
        return !1;
      }
    },
    async switchChain({ addEthereumChainParameter: M, chainId: i }) {
      var w, U, S;
      const z = await this.getProvider();
      if (!z) throw new _();
      const T = d.chains.find((n) => n.id === i);
      if (!T) throw new P(new R());
      try {
        await Promise.all([
          new Promise((e) => {
            const t = ({
              chainId: N
            }) => {
              N === i && (d.emitter.off("change", t), e());
            };
            d.emitter.on("change", t);
          }),
          z.request({
            method: "wallet_switchEthereumChain",
            params: [{ chainId: H(i) }]
          })
        ]);
        const n = await this.getRequestedChainsIds();
        return this.setRequestedChainsIds([...n, i]), T;
      } catch (n) {
        const e = n;
        if (/(user rejected)/i.test(e.message))
          throw new G(e);
        try {
          let t;
          M != null && M.blockExplorerUrls ? t = M.blockExplorerUrls : t = (w = T.blockExplorers) != null && w.default.url ? [(U = T.blockExplorers) == null ? void 0 : U.default.url] : [];
          let N;
          (S = M == null ? void 0 : M.rpcUrls) != null && S.length ? N = M.rpcUrls : N = [...T.rpcUrls.default.http];
          const u = {
            blockExplorerUrls: t,
            chainId: H(i),
            chainName: (M == null ? void 0 : M.chainName) ?? T.name,
            iconUrls: M == null ? void 0 : M.iconUrls,
            nativeCurrency: (M == null ? void 0 : M.nativeCurrency) ?? T.nativeCurrency,
            rpcUrls: N
          };
          await z.request({
            method: "wallet_addEthereumChain",
            params: [u]
          });
          const x = await this.getRequestedChainsIds();
          return this.setRequestedChainsIds([...x, i]), T;
        } catch (t) {
          throw new G(t);
        }
      }
    },
    onAccountsChanged(M) {
      M.length === 0 ? this.onDisconnect() : d.emitter.emit("change", {
        accounts: M.map((i) => Y(i))
      });
    },
    onChainChanged(M) {
      const i = Number(M);
      d.emitter.emit("change", { chainId: i });
    },
    async onConnect(M) {
      const i = Number(M.chainId), z = await this.getAccounts();
      d.emitter.emit("connect", { accounts: z, chainId: i });
    },
    async onDisconnect(M) {
      this.setRequestedChainsIds([]), d.emitter.emit("disconnect");
      const i = await this.getProvider();
      L && (i.removeListener("accountsChanged", L), L = void 0), r && (i.removeListener("chainChanged", r), r = void 0), C && (i.removeListener("disconnect", C), C = void 0), a && (i.removeListener("session_delete", a), a = void 0), o || (o = this.onConnect.bind(this), i.on("connect", o));
    },
    onDisplayUri(M) {
      d.emitter.emit("message", { type: "display_uri", data: M });
    },
    onSessionDelete() {
      this.onDisconnect();
    },
    getNamespaceChainsIds() {
      var i, z, T;
      return I ? ((T = (z = (i = I.session) == null ? void 0 : i.namespaces[g]) == null ? void 0 : z.accounts) == null ? void 0 : T.map(
        (w) => Number.parseInt(w.split(":")[1] || "")
      )) ?? [] : [];
    },
    async getRequestedChainsIds() {
      var M;
      return await ((M = d.storage) == null ? void 0 : M.getItem(this.requestedChainsStorageKey)) ?? [];
    },
    /**
     * Checks if the target chains match the chains that were
     * initially requested by the connector for the WalletConnect session.
     * If there is a mismatch, this means that the chains on the connector
     * are considered stale, and need to be revalidated at a later point (via
     * connection).
     *
     * There may be a scenario where a dapp adds a chain to the
     * connector later on, however, this chain will not have been approved or rejected
     * by the wallet. In this case, the chain is considered stale.
     */
    async isChainsStale() {
      if (!j) return !1;
      const M = d.chains.map((T) => T.id), i = this.getNamespaceChainsIds();
      if (i.length && !i.some((T) => M.includes(T)))
        return !1;
      const z = await this.getRequestedChainsIds();
      return !M.every((T) => z.includes(T));
    },
    async setRequestedChainsIds(M) {
      var i;
      await ((i = d.storage) == null ? void 0 : i.setItem(this.requestedChainsStorageKey, M));
    },
    get requestedChainsStorageKey() {
      return `${this.id}.requestedChains`;
    }
  }));
}
export {
  NM as UnsupportedWallet,
  RM as connectAndSign,
  XM as connectAndSignIn,
  jM as connectConnector,
  PM as createWagmiConfig,
  sM as customWalletConnect,
  VM as disconnectConnector,
  hM as futureverseCustodialWallet,
  kM as xamanWallet
};
