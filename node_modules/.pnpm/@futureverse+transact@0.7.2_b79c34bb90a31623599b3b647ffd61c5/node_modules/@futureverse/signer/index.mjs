import { Keyring as be } from "@polkadot/api";
import { hexToU8a as Y, u8aToHex as Se, u8aToString as ee } from "@polkadot/util";
import { blake2AsHex as C } from "@polkadot/util-crypto";
import { getAddress as Ae, recoverMessageAddress as $e, isHex as te, keccak256 as Ee, toHex as Pe } from "viem";
import { decode as _, encode as Ie } from "ripple-binary-codec";
import { deriveAddress as ve, verify as ne } from "ripple-keypairs";
import { ethereumEncode as D } from "@polkadot/util-crypto/ethereum";
import { blake2bInit as Me, blake2bUpdate as Te, blake2bFinal as _e } from "blakejs";
import { encodeForSigning as se, decode as ke } from "xrpl";
export * from "@futureverse/signer-core";
function F(t) {
  if (!Number.isSafeInteger(t) || t < 0)
    throw new Error("positive integer expected, got " + t);
}
function Ue(t) {
  return t instanceof Uint8Array || ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array";
}
function L(t, ...e) {
  if (!Ue(t))
    throw new Error("Uint8Array expected");
  if (e.length > 0 && !e.includes(t.length))
    throw new Error("Uint8Array expected of length " + e + ", got length=" + t.length);
}
function N(t, e = !0) {
  if (t.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (e && t.finished)
    throw new Error("Hash#digest() has already been called");
}
function Re(t, e) {
  L(t);
  const n = e.outputLen;
  if (t.length < n)
    throw new Error("digestInto() expects output buffer of length at least " + n);
}
const P = /* @__PURE__ */ BigInt(2 ** 32 - 1), j = /* @__PURE__ */ BigInt(32);
function Le(t, e = !1) {
  return e ? { h: Number(t & P), l: Number(t >> j & P) } : { h: Number(t >> j & P) | 0, l: Number(t & P) | 0 };
}
function Oe(t, e = !1) {
  let n = new Uint32Array(t.length), s = new Uint32Array(t.length);
  for (let r = 0; r < t.length; r++) {
    const { h: i, l: o } = Le(t[r], e);
    [n[r], s[r]] = [i, o];
  }
  return [n, s];
}
const He = (t, e, n) => t << n | e >>> 32 - n, ze = (t, e, n) => e << n | t >>> 32 - n, Be = (t, e, n) => e << n - 32 | t >>> 64 - n, Ce = (t, e, n) => t << n - 32 | e >>> 64 - n;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function De(t) {
  return new Uint32Array(t.buffer, t.byteOffset, Math.floor(t.byteLength / 4));
}
const K = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
function Fe(t) {
  return t << 24 & 4278190080 | t << 8 & 16711680 | t >>> 8 & 65280 | t >>> 24 & 255;
}
function q(t) {
  for (let e = 0; e < t.length; e++)
    t[e] = Fe(t[e]);
}
typeof Uint8Array.from([]).toHex == "function" && Uint8Array.fromHex;
function Ne(t) {
  if (typeof t != "string")
    throw new Error("utf8ToBytes expected string, got " + typeof t);
  return new Uint8Array(new TextEncoder().encode(t));
}
function re(t) {
  return typeof t == "string" && (t = Ne(t)), L(t), t;
}
class je {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
}
function Ke(t) {
  const e = (s) => t().update(re(s)).digest(), n = t();
  return e.outputLen = n.outputLen, e.blockLen = n.blockLen, e.create = () => t(), e;
}
const ie = [], oe = [], ae = [], qe = /* @__PURE__ */ BigInt(0), A = /* @__PURE__ */ BigInt(1), Xe = /* @__PURE__ */ BigInt(2), Ve = /* @__PURE__ */ BigInt(7), We = /* @__PURE__ */ BigInt(256), Ze = /* @__PURE__ */ BigInt(113);
for (let t = 0, e = A, n = 1, s = 0; t < 24; t++) {
  [n, s] = [s, (2 * n + 3 * s) % 5], ie.push(2 * (5 * s + n)), oe.push((t + 1) * (t + 2) / 2 % 64);
  let r = qe;
  for (let i = 0; i < 7; i++)
    e = (e << A ^ (e >> Ve) * Ze) % We, e & Xe && (r ^= A << (A << /* @__PURE__ */ BigInt(i)) - A);
  ae.push(r);
}
const [Ge, Je] = /* @__PURE__ */ Oe(ae, !0), X = (t, e, n) => n > 32 ? Be(t, e, n) : He(t, e, n), V = (t, e, n) => n > 32 ? Ce(t, e, n) : ze(t, e, n);
function Qe(t, e = 24) {
  const n = new Uint32Array(10);
  for (let s = 24 - e; s < 24; s++) {
    for (let o = 0; o < 10; o++)
      n[o] = t[o] ^ t[o + 10] ^ t[o + 20] ^ t[o + 30] ^ t[o + 40];
    for (let o = 0; o < 10; o += 2) {
      const a = (o + 8) % 10, c = (o + 2) % 10, u = n[c], d = n[c + 1], f = X(u, d, 1) ^ n[a], p = V(u, d, 1) ^ n[a + 1];
      for (let m = 0; m < 50; m += 10)
        t[o + m] ^= f, t[o + m + 1] ^= p;
    }
    let r = t[2], i = t[3];
    for (let o = 0; o < 24; o++) {
      const a = oe[o], c = X(r, i, a), u = V(r, i, a), d = ie[o];
      r = t[d], i = t[d + 1], t[d] = c, t[d + 1] = u;
    }
    for (let o = 0; o < 50; o += 10) {
      for (let a = 0; a < 10; a++)
        n[a] = t[o + a];
      for (let a = 0; a < 10; a++)
        t[o + a] ^= ~n[(a + 2) % 10] & n[(a + 4) % 10];
    }
    t[0] ^= Ge[s], t[1] ^= Je[s];
  }
  n.fill(0);
}
class O extends je {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(e, n, s, r = !1, i = 24) {
    if (super(), this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, this.enableXOF = !1, this.blockLen = e, this.suffix = n, this.outputLen = s, this.enableXOF = r, this.rounds = i, F(s), 0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200), this.state32 = De(this.state);
  }
  keccak() {
    K || q(this.state32), Qe(this.state32, this.rounds), K || q(this.state32), this.posOut = 0, this.pos = 0;
  }
  update(e) {
    N(this);
    const { blockLen: n, state: s } = this;
    e = re(e);
    const r = e.length;
    for (let i = 0; i < r; ) {
      const o = Math.min(n - this.pos, r - i);
      for (let a = 0; a < o; a++)
        s[this.pos++] ^= e[i++];
      this.pos === n && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = !0;
    const { state: e, suffix: n, pos: s, blockLen: r } = this;
    e[s] ^= n, (n & 128) !== 0 && s === r - 1 && this.keccak(), e[r - 1] ^= 128, this.keccak();
  }
  writeInto(e) {
    N(this, !1), L(e), this.finish();
    const n = this.state, { blockLen: s } = this;
    for (let r = 0, i = e.length; r < i; ) {
      this.posOut >= s && this.keccak();
      const o = Math.min(s - this.posOut, i - r);
      e.set(n.subarray(this.posOut, this.posOut + o), r), this.posOut += o, r += o;
    }
    return e;
  }
  xofInto(e) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(e);
  }
  xof(e) {
    return F(e), this.xofInto(new Uint8Array(e));
  }
  digestInto(e) {
    if (Re(e, this), this.finished)
      throw new Error("digest() was already called");
    return this.writeInto(e), this.destroy(), e;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = !0, this.state.fill(0);
  }
  _cloneInto(e) {
    const { blockLen: n, suffix: s, outputLen: r, rounds: i, enableXOF: o } = this;
    return e || (e = new O(n, s, r, o, i)), e.state32.set(this.state32), e.pos = this.pos, e.posOut = this.posOut, e.finished = this.finished, e.rounds = i, e.suffix = s, e.outputLen = r, e.enableXOF = o, e.destroyed = this.destroyed, e;
  }
}
const Ye = (t, e, n) => Ke(() => new O(e, t, n)), et = /* @__PURE__ */ Ye(1, 136, 256 / 8);
function H(t, { strict: e = !0 } = {}) {
  return !t || typeof t != "string" ? !1 : e ? /^0x[0-9a-fA-F]*$/.test(t) : t.startsWith("0x");
}
const ce = "2.29.0";
let $ = {
  getDocsUrl: ({ docsBaseUrl: t, docsPath: e = "", docsSlug: n }) => e ? `${t ?? "https://viem.sh"}${e}${n ? `#${n}` : ""}` : void 0,
  version: `viem@${ce}`
};
class h extends Error {
  constructor(e, n = {}) {
    var a;
    const s = (() => {
      var c;
      return n.cause instanceof h ? n.cause.details : (c = n.cause) != null && c.message ? n.cause.message : n.details;
    })(), r = n.cause instanceof h && n.cause.docsPath || n.docsPath, i = (a = $.getDocsUrl) == null ? void 0 : a.call($, { ...n, docsPath: r }), o = [
      e || "An error occurred.",
      "",
      ...n.metaMessages ? [...n.metaMessages, ""] : [],
      ...i ? [`Docs: ${i}`] : [],
      ...s ? [`Details: ${s}`] : [],
      ...$.version ? [`Version: ${$.version}`] : []
    ].join(`
`);
    super(o, n.cause ? { cause: n.cause } : void 0), Object.defineProperty(this, "details", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "docsPath", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "metaMessages", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shortMessage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "version", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "BaseError"
    }), this.details = s, this.docsPath = r, this.metaMessages = n.metaMessages, this.name = n.name ?? this.name, this.shortMessage = e, this.version = ce;
  }
  walk(e) {
    return ue(this, e);
  }
}
function ue(t, e) {
  return e != null && e(t) ? t : t && typeof t == "object" && "cause" in t && t.cause !== void 0 ? ue(t.cause, e) : e ? null : t;
}
class de extends h {
  constructor({ size: e, targetSize: n, type: s }) {
    super(`${s.charAt(0).toUpperCase()}${s.slice(1).toLowerCase()} size (${e}) exceeds padding size (${n}).`, { name: "SizeExceedsPaddingSizeError" });
  }
}
function M(t, { dir: e, size: n = 32 } = {}) {
  return typeof t == "string" ? tt(t, { dir: e, size: n }) : nt(t, { dir: e, size: n });
}
function tt(t, { dir: e, size: n = 32 } = {}) {
  if (n === null)
    return t;
  const s = t.replace("0x", "");
  if (s.length > n * 2)
    throw new de({
      size: Math.ceil(s.length / 2),
      targetSize: n,
      type: "hex"
    });
  return `0x${s[e === "right" ? "padEnd" : "padStart"](n * 2, "0")}`;
}
function nt(t, { dir: e, size: n = 32 } = {}) {
  if (n === null)
    return t;
  if (t.length > n)
    throw new de({
      size: t.length,
      targetSize: n,
      type: "bytes"
    });
  const s = new Uint8Array(n);
  for (let r = 0; r < n; r++) {
    const i = e === "right";
    s[i ? r : n - r - 1] = t[i ? r : t.length - r - 1];
  }
  return s;
}
class st extends h {
  constructor({ max: e, min: n, signed: s, size: r, value: i }) {
    super(`Number "${i}" is not in safe ${r ? `${r * 8}-bit ${s ? "signed" : "unsigned"} ` : ""}integer range ${e ? `(${n} to ${e})` : `(above ${n})`}`, { name: "IntegerOutOfRangeError" });
  }
}
class rt extends h {
  constructor({ givenSize: e, maxSize: n }) {
    super(`Size cannot exceed ${n} bytes. Given size: ${e} bytes.`, { name: "SizeOverflowError" });
  }
}
function W(t) {
  return H(t, { strict: !1 }) ? Math.ceil((t.length - 2) / 2) : t.length;
}
function z(t, { size: e }) {
  if (W(t) > e)
    throw new rt({
      givenSize: W(t),
      maxSize: e
    });
}
function it(t, e = {}) {
  const { signed: n, size: s } = e, r = BigInt(t);
  let i;
  s ? n ? i = (1n << BigInt(s) * 8n - 1n) - 1n : i = 2n ** (BigInt(s) * 8n) - 1n : typeof t == "number" && (i = BigInt(Number.MAX_SAFE_INTEGER));
  const o = typeof i == "bigint" && n ? -i - 1n : 0;
  if (i && r > i || r < o) {
    const c = typeof t == "bigint" ? "n" : "";
    throw new st({
      max: i ? `${i}${c}` : void 0,
      min: `${o}${c}`,
      signed: n,
      size: s,
      value: `${t}${c}`
    });
  }
  const a = `0x${(n && r < 0 ? (1n << BigInt(s * 8)) + BigInt(r) : r).toString(16)}`;
  return s ? M(a, { size: s }) : a;
}
const ot = /* @__PURE__ */ new TextEncoder();
function at(t, e = {}) {
  return typeof t == "number" || typeof t == "bigint" ? ut(t, e) : typeof t == "boolean" ? ct(t, e) : H(t) ? fe(t, e) : le(t, e);
}
function ct(t, e = {}) {
  const n = new Uint8Array(1);
  return n[0] = Number(t), typeof e.size == "number" ? (z(n, { size: e.size }), M(n, { size: e.size })) : n;
}
const l = {
  zero: 48,
  nine: 57,
  A: 65,
  F: 70,
  a: 97,
  f: 102
};
function Z(t) {
  if (t >= l.zero && t <= l.nine)
    return t - l.zero;
  if (t >= l.A && t <= l.F)
    return t - (l.A - 10);
  if (t >= l.a && t <= l.f)
    return t - (l.a - 10);
}
function fe(t, e = {}) {
  let n = t;
  e.size && (z(n, { size: e.size }), n = M(n, { dir: "right", size: e.size }));
  let s = n.slice(2);
  s.length % 2 && (s = `0${s}`);
  const r = s.length / 2, i = new Uint8Array(r);
  for (let o = 0, a = 0; o < r; o++) {
    const c = Z(s.charCodeAt(a++)), u = Z(s.charCodeAt(a++));
    if (c === void 0 || u === void 0)
      throw new h(`Invalid byte sequence ("${s[a - 2]}${s[a - 1]}" in "${s}").`);
    i[o] = c * 16 + u;
  }
  return i;
}
function ut(t, e) {
  const n = it(t, e);
  return fe(n);
}
function le(t, e = {}) {
  const n = ot.encode(t);
  return typeof e.size == "number" ? (z(n, { size: e.size }), M(n, { dir: "right", size: e.size })) : n;
}
function dt(t, e) {
  return et(H(t, { strict: !1 }) ? at(t) : t);
}
class ft extends h {
  constructor({ address: e }) {
    super(`Address "${e}" is invalid.`, {
      metaMessages: [
        "- Address must be a hex value of 20 bytes (40 hex characters).",
        "- Address must match its checksum counterpart."
      ],
      name: "InvalidAddressError"
    });
  }
}
class he extends Map {
  constructor(e) {
    super(), Object.defineProperty(this, "maxSize", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.maxSize = e;
  }
  get(e) {
    const n = super.get(e);
    return super.has(e) && n !== void 0 && (this.delete(e), super.set(e, n)), n;
  }
  set(e, n) {
    if (super.set(e, n), this.maxSize && this.size > this.maxSize) {
      const s = this.keys().next().value;
      s && this.delete(s);
    }
    return this;
  }
}
const k = /* @__PURE__ */ new he(8192);
function ge(t, e) {
  if (k.has(`${t}.${e}`))
    return k.get(`${t}.${e}`);
  const n = t.substring(2).toLowerCase(), s = dt(le(n)), r = n.split("");
  for (let o = 0; o < 40; o += 2)
    s[o >> 1] >> 4 >= 8 && r[o] && (r[o] = r[o].toUpperCase()), (s[o >> 1] & 15) >= 8 && r[o + 1] && (r[o + 1] = r[o + 1].toUpperCase());
  const i = `0x${r.join("")}`;
  return k.set(`${t}.${e}`, i), i;
}
function lt(t, e) {
  if (!gt(t, { strict: !1 }))
    throw new ft({ address: t });
  return ge(t, e);
}
const ht = /^0x[a-fA-F0-9]{40}$/, U = /* @__PURE__ */ new he(8192);
function gt(t, e) {
  const { strict: n = !0 } = e ?? {}, s = `${t}.${n}`;
  if (U.has(s))
    return U.get(s);
  const r = ht.test(t) ? t.toLowerCase() === t ? !0 : n ? ge(t) === t : !0 : !1;
  return U.set(s, r), r;
}
class w extends h {
  constructor(e) {
    const { docsPath: n, field: s, metaMessages: r } = e;
    super(`Invalid Sign-In with Ethereum message field "${s}".`, {
      docsPath: n,
      metaMessages: r,
      name: "SiweInvalidMessageFieldError"
    });
  }
}
function G(t) {
  if (/[^a-z0-9\:\/\?\#\[\]\@\!\$\&\'\(\)\*\+\,\;\=\.\-\_\~\%]/i.test(t) || /%[^0-9a-f]/i.test(t) || /%[0-9a-f](:?[^0-9a-f]|$)/i.test(t))
    return !1;
  const e = mt(t), n = e[1], s = e[2], r = e[3], i = e[4], o = e[5];
  if (!(n != null && n.length && r.length >= 0))
    return !1;
  if (s != null && s.length) {
    if (!(r.length === 0 || /^\//.test(r)))
      return !1;
  } else if (/^\/\//.test(r))
    return !1;
  if (!/^[a-z][a-z0-9\+\-\.]*$/.test(n.toLowerCase()))
    return !1;
  let a = "";
  return a += `${n}:`, s != null && s.length && (a += `//${s}`), a += r, i != null && i.length && (a += `?${i}`), o != null && o.length && (a += `#${o}`), a;
}
function mt(t) {
  return t.match(/(?:([^:\/?#]+):)?(?:\/\/([^\/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?/);
}
function yt(t) {
  const { chainId: e, domain: n, expirationTime: s, issuedAt: r = /* @__PURE__ */ new Date(), nonce: i, notBefore: o, requestId: a, resources: c, scheme: u, uri: d, version: f } = t;
  {
    if (e !== Math.floor(e))
      throw new w({
        field: "chainId",
        metaMessages: [
          "- Chain ID must be a EIP-155 chain ID.",
          "- See https://eips.ethereum.org/EIPS/eip-155",
          "",
          `Provided value: ${e}`
        ]
      });
    if (!(wt.test(n) || pt.test(n) || xt.test(n)))
      throw new w({
        field: "domain",
        metaMessages: [
          "- Domain must be an RFC 3986 authority.",
          "- See https://www.rfc-editor.org/rfc/rfc3986",
          "",
          `Provided value: ${n}`
        ]
      });
    if (!bt.test(i))
      throw new w({
        field: "nonce",
        metaMessages: [
          "- Nonce must be at least 8 characters.",
          "- Nonce must be alphanumeric.",
          "",
          `Provided value: ${i}`
        ]
      });
    if (!G(d))
      throw new w({
        field: "uri",
        metaMessages: [
          "- URI must be a RFC 3986 URI referring to the resource that is the subject of the signing.",
          "- See https://www.rfc-editor.org/rfc/rfc3986",
          "",
          `Provided value: ${d}`
        ]
      });
    if (f !== "1")
      throw new w({
        field: "version",
        metaMessages: [
          "- Version must be '1'.",
          "",
          `Provided value: ${f}`
        ]
      });
    if (u && !St.test(u))
      throw new w({
        field: "scheme",
        metaMessages: [
          "- Scheme must be an RFC 3986 URI scheme.",
          "- See https://www.rfc-editor.org/rfc/rfc3986#section-3.1",
          "",
          `Provided value: ${u}`
        ]
      });
    const x = t.statement;
    if (x != null && x.includes(`
`))
      throw new w({
        field: "statement",
        metaMessages: [
          "- Statement must not include '\\n'.",
          "",
          `Provided value: ${x}`
        ]
      });
  }
  const p = lt(t.address), m = u ? `${u}://${n}` : n, y = t.statement ? `${t.statement}
` : "", xe = `${m} wants you to sign in with your Ethereum account:
${p}

${y}`;
  let S = `URI: ${d}
Version: ${f}
Chain ID: ${e}
Nonce: ${i}
Issued At: ${r.toISOString()}`;
  if (s && (S += `
Expiration Time: ${s.toISOString()}`), o && (S += `
Not Before: ${o.toISOString()}`), a && (S += `
Request ID: ${a}`), c) {
    let x = `
Resources:`;
    for (const T of c) {
      if (!G(T))
        throw new w({
          field: "resources",
          metaMessages: [
            "- Every resource must be a RFC 3986 URI.",
            "- See https://www.rfc-editor.org/rfc/rfc3986",
            "",
            `Provided value: ${T}`
          ]
        });
      x += `
- ${T}`;
    }
    S += x;
  }
  return `${xe}
${S}`;
}
const wt = /^([a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}(:[0-9]{1,5})?$/, pt = /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(:[0-9]{1,5})?$/, xt = /^localhost(:[0-9]{1,5})?$/, bt = /^[a-zA-Z0-9]{8,}$/, St = /^([a-zA-Z][a-zA-Z0-9+-.]*)$/, R = 256;
let I = R, v;
function At(t = 11) {
  if (!v || I + t > R * 2) {
    v = "", I = 0;
    for (let e = 0; e < R; e++)
      v += (256 + Math.random() * 256 | 0).toString(16).substring(1);
  }
  return v.substring(I, I++ + t);
}
function $t() {
  return At(96);
}
class g {
  async signPassOIDC(e) {
    if (!e.address)
      throw new Error("Address required");
    const n = $t(), s = /* @__PURE__ */ new Date(), r = Ae(e.address), i = yt({
      version: "1",
      nonce: n,
      address: r,
      uri: e.idpURL,
      domain: e.domain,
      chainId: e.chainId,
      issuedAt: s
    }), o = await this.signMessage(i);
    if (o == null)
      throw new Error("Failed to sign auth message");
    return { hint: "eoa:" + new URLSearchParams({
      nonce: n,
      address: r,
      issuedAt: s.toISOString(),
      domain: e.domain,
      signature: o
    }).toString(), nonce: n };
  }
  static async verifySignature(e, n) {
    return { ethAddress: await $e({
      message: e,
      signature: n
    }) };
  }
  verifySignature(e, n) {
    return g.verifySignature(e, n);
  }
  async signExtrinsic(e, n, s) {
    const r = await this.createExtrinsicPayload(e, s, n), i = await this.signPayload(r);
    return n.addSignature(
      s,
      i,
      r.trnPayload.toPayload()
    );
  }
  async signPayload(e, n) {
    const r = {
      raw: e.ethPayload.toString()
    }, i = {
      transaction: n == null ? void 0 : n.toHex()
    }, o = await this.signMessage(
      r,
      i
    );
    if (!Pt(o))
      throw new Error('Expected signature to start with "0x"');
    return o;
  }
  async signExtrinsicWithPayload(e, n, s, r) {
    const i = await this.signPayload(s, n);
    return n.addSignature(
      r,
      i,
      s.trnPayload.toPayload()
    );
  }
  async createExtrinsicPayload(e, n, s, r) {
    const { header: i, mortalLength: o, nonce: a } = await e.derive.tx.signingInfo(
      n
    ), c = {
      address: n,
      blockHash: i == null ? void 0 : i.hash,
      blockNumber: i == null ? void 0 : i.number,
      era: e.registry.createTypeUnsafe("ExtrinsicEra", [
        {
          current: i == null ? void 0 : i.number,
          period: o
        }
      ]),
      genesisHash: e.genesisHash,
      method: s.method,
      nonce: a,
      runtimeVersion: e.runtimeVersion,
      signedExtensions: e.registry.signedExtensions,
      version: e.extrinsicVersion,
      ...r
    }, u = e.registry.createTypeUnsafe("SignerPayload", [
      c
    ]), { data: d } = u.toRaw(), f = d.length > 257 * 2 ? C(d) : d, p = C(f);
    return { trnPayload: u, ethPayload: p };
  }
}
const Et = /^0x[a-fA-F0-9]/;
function Pt(t) {
  return Et.test(t.toString());
}
class Nt extends g {
  constructor(e) {
    super();
    const n = new be({ type: "ethereum" });
    this._keyPair = n.addFromSeed(Y(e));
  }
  async getAddress() {
    return this._keyPair.address;
  }
  async signMessage(e) {
    const n = typeof e == "string" || e instanceof String ? e : e.raw;
    return Se(this._keyPair.sign(n));
  }
}
const b = (t) => It(vt(t)), It = (t) => Array.from(t, (e) => e.toString(16).padStart(2, "0")).join(
  ""
), vt = (t) => new TextEncoder().encode(t), B = (t) => new TextDecoder().decode(Mt(t)), Mt = (t) => {
  const e = new Uint8Array(t.length / 2);
  for (let n = 0; n !== e.length; n++)
    e[n] = parseInt(t.substr(n * 2, 2), 16);
  return e;
};
class Tt extends g {
  constructor(e) {
    super(), this._walletClient = e;
  }
  async getAddress() {
    var e;
    return (e = this._walletClient.account) == null ? void 0 : e.address;
  }
  async signMessage(e) {
    if (console.log(this._walletClient), !this._walletClient.signMessage)
      throw new Error("No signMessage on wallet client");
    return this._walletClient.signMessage({ message: e });
  }
}
function jt(t) {
  const { signer: e } = t;
  return e instanceof g ? e : new Tt(t);
}
function me(t) {
  return typeof t == "string" || t instanceof String ? b(t) : te(t.raw) ? t.raw : b(ee(t.raw));
}
function ye(t) {
  return typeof t == "string" || t instanceof String ? t : te(t.raw) ? B(t.raw) : ee(t.raw);
}
function we(t) {
  const e = t.startsWith("0x") ? t.slice(2) : t, n = ve(e);
  if (!e.toLowerCase().startsWith("ed"))
    return [D(`0x${e}`), n];
  const r = `0x${e}`;
  return [D(
    "0x" + Ee(Y(`0x${r.slice(4)}`)).slice(26)
  ), n];
}
class E extends g {
  constructor(e) {
    super(), this._listeners = {}, this.client = e;
  }
  async getAddress() {
    return await this.client.user.account;
  }
  static async verifySignature(e, n) {
    const s = ye(e), r = _(n), i = r.Memos;
    let o;
    if (i && i.length > 0 && (o = B(i[0].Memo.MemoData)), o !== s)
      throw new Error("Message does not match");
    if (typeof r.TxnSignature != "string" || !r.TxnSignature)
      throw new Error("Transaction is missing a signature, TxnSignature");
    if (typeof r.SigningPubKey != "string" || !r.SigningPubKey)
      throw new Error("Transaction is missing a public key, SigningPubKey");
    if (!ne(
      se(r),
      r.TxnSignature,
      r.SigningPubKey
    ))
      throw new Error("Signature verification failed");
    const [c] = E.deriveAddressPair(
      r.SigningPubKey
    ), u = r.Account;
    return {
      ethAddress: c,
      accounts: [c, u]
    };
  }
  verifySignedPayload(e) {
    const n = _(e), s = n.Account, [r] = E.deriveAddressPair(
      n.SigningPubKey
    );
    return { ethAddress: r, accounts: [r, s] };
  }
  verifySignature(e, n) {
    return E.verifySignature(e, n);
  }
  async signXummPayload(e) {
    if (!this.client.payload)
      throw new Error("No Xaman client payload");
    const { created: n, resolved: s } = await this.client.payload.createAndSubscribe(
      e,
      (i) => {
        if (Object.keys(i.data).indexOf("opened") > -1, Object.keys(i.data).indexOf("signed") > -1) {
          const { signed: o } = i.data;
          if (!o) {
            this.emit("signed", { success: !1, uuid: i.uuid });
            return;
          }
          const a = i.payload.response.hex;
          if (a == null)
            throw new Error("Transaction hex data was null after signing.");
          const c = this.decodeSignedPayload(
            a
          );
          return this.emit("signed", {
            success: !1,
            payload: c,
            uuid: i.uuid
          }), console.log("SIGNATURE", c), a;
        }
      }
    );
    return this.emit("showQR", n), await s;
  }
  async signMessage(e) {
    const n = me(e), s = [
      {
        Memo: {
          MemoType: b("message"),
          MemoData: n
        }
      }
    ];
    return await this.signXummPayload({
      txjson: {
        Memos: s,
        TransactionType: "SignIn",
        AccountTxnID: "0000000000000000000000000000000000000000000000000000000000000000"
      },
      custom_meta: {
        instruction: "Sign message"
      }
    });
  }
  async signPassOIDC(e) {
    const n = await this.signXummPayload({
      custom_meta: {
        instruction: "Sign In"
      },
      txjson: {
        TransactionType: "SignIn"
      }
    }), { ethAddress: s } = this.verifySignedPayload(n);
    return {
      hint: `xrpl:0x${this.decodeSignedPayload(n).SigningPubKey}:eoa:${s}:transaction:${n}`
    };
  }
  async signExtrinsicWithPayload(e, n, s, r) {
    const { mortalLength: i } = await e.derive.tx.signingInfo(r), o = this.createSigningMemoData({
      nonce: s.trnPayload.nonce.toString(),
      genesisHash: s.trnPayload.genesisHash.toHex().slice(2),
      maxBlockNumber: +s.trnPayload.blockNumber + i,
      hashedExtrinsicWithoutPrefix: J(
        n.toHex().slice(n.encodedLength >= 66 ? 8 : 6).toString()
      )
    });
    return this.generateSignedExtrinsic(e, n, o);
  }
  async signExtrinsic(e, n, s) {
    const r = await this.createSignatureOptions(
      e,
      s,
      n
    ), i = this.createSigningMemoData(r);
    return this.generateSignedExtrinsic(e, n, i);
  }
  async generateSignedExtrinsic(e, n, s) {
    const r = await this.signXummPayload({
      txjson: {
        Memos: s,
        TransactionType: "SignIn",
        AccountTxnID: "0000000000000000000000000000000000000000000000000000000000000000"
      },
      custom_meta: {
        instruction: "Sign extrinsic"
      }
    }), i = this.decodeSignedPayload(r), o = i.TxnSignature, a = i;
    return e.tx.xrpl.transact(
      `0x${Ie(a)}`,
      `0x${o}`,
      n
    );
  }
  async createSignatureOptions(e, n, s) {
    const [r, i] = await Promise.allSettled([
      e.query.system.number(),
      e.derive.tx.signingInfo(n)
    ]);
    if (r.status === "rejected")
      throw r.reason;
    if (i.status === "rejected")
      throw i.reason;
    const o = i.value.nonce.toString(), a = e.genesisHash.toHex().slice(2), c = +r.value + i.value.mortalLength, u = J(
      s.toHex().slice(s.encodedLength >= 66 ? 8 : 6).toString()
    ), d = {
      nonce: o,
      genesisHash: a,
      maxBlockNumber: c,
      hashedExtrinsicWithoutPrefix: u
    };
    return console.log("Xaman signing response", d), d;
  }
  createSigningMemoData(e) {
    const { nonce: n, genesisHash: s, maxBlockNumber: r, hashedExtrinsicWithoutPrefix: i } = e;
    return console.log(
      `${s}:${n}:${r}:0:${i}`
    ), [
      {
        Memo: {
          MemoType: b("extrinsic"),
          MemoData: b(
            `${s}:${n}:${r}:0:${i}`
          )
        }
      }
    ];
  }
  subscribe(e, n) {
    var s;
    if (!this._listeners[e]) {
      this._listeners[e] = [n];
      return;
    }
    (s = this._listeners[e]) == null || s.push(n);
  }
  unsubscribe(e, n) {
    var s;
    this._listeners[e] && (this._listeners[e] = (s = this._listeners[e]) == null ? void 0 : s.filter(
      (r) => r !== n
    ));
  }
  emit(e, n) {
    var s;
    this._listeners[e] && ((s = this._listeners[e]) == null || s.forEach((r) => r(n)));
  }
  static decodeSignedPayload(e) {
    return _(e);
  }
  decodeSignedPayload(e) {
    return E.decodeSignedPayload(e);
  }
  static deriveAddressPair(e) {
    return we(e);
  }
}
const J = (t) => {
  t instanceof Buffer || (t = Buffer.from(t, "hex"));
  const e = Me(32);
  return Te(e, t), kt(_e(e));
}, _t = (t) => t < 16 ? `0${t.toString(16)}` : t.toString(16), kt = (t) => Array.from(t).map(_t).join("");
class Kt extends g {
  constructor(e) {
    super(), this._account = e;
  }
  async getAddress() {
    return this._account.address;
  }
  async signMessage(e) {
    return await this._account.signMessage({ message: e });
  }
}
class qt extends g {
  constructor(e, n, s) {
    super(), this._pending = /* @__PURE__ */ new Map(), this._reqId = 0, this._popup = null, this._signerURL = e, this._eoa = s, this._idpUrl = n;
    const r = new URL(this._signerURL).origin;
    this._listener = (i) => {
      i.origin === r && this.receiveMessage(i.data);
    }, window && window.addEventListener("message", this._listener);
  }
  receiveMessage(e) {
    var s;
    const n = (s = this._pending.get(e.id)) == null ? void 0 : s.handler;
    n == null || n(e);
  }
  async getAddress() {
    return this._eoa;
  }
  async signMessage(e, n) {
    if (!this._eoa)
      throw new Error("Must be signed in to sign message");
    const s = typeof e == "string" || e instanceof String ? e : e.raw;
    return await this.makeRequest("signMessage", {
      tag: "fv/sign-msg",
      account: this._eoa,
      message: typeof s == "string" ? s.startsWith("0x") ? s : `0x${b(s)}` : Pe(s),
      idpUrl: this._idpUrl,
      metadata: {
        ...n,
        requester: Q()
      }
    });
  }
  async signTransaction(e) {
    if (!this._eoa)
      throw new Error("Must be signed in to sign message");
    return await this.makeRequest("signTransaction", {
      tag: "fv/sign-tx",
      account: this._eoa,
      transaction: e,
      idpUrl: this._idpUrl,
      metadata: { requester: Q() }
    });
  }
  makeRequest(e, n, s, r) {
    const i = "client:" + String(this._reqId++), { tag: o, ...a } = n, c = {
      id: i,
      tag: o,
      payload: a
    };
    let u = !1;
    const d = () => {
      u || (u = !0, this._pending.delete(i));
    };
    return r == null || r.addEventListener("abort", d), new Promise((f, p) => {
      const m = (y) => {
        if (y.payload.tag === "event") {
          if (u || !s) return;
          s(y.payload.event);
          return;
        }
        if (y.payload.tag === "response") {
          f(y.payload.response.signature), this._pending.delete(i), r == null || r.removeEventListener("abort", d);
          return;
        }
        if (y.payload.tag === "error")
          return this._pending.delete(i), r == null || r.removeEventListener("abort", d), p(y.payload.error);
      };
      this._pending.set(i, { handler: m, tag: o }), this.postMessage(c);
    });
  }
  postMessage(e) {
    var s;
    if (((s = this._popup) == null ? void 0 : s.closed) === !1) {
      this._popup.postMessage(e, "*");
      return;
    }
    if (this._popup = window.open(
      this._signerURL + "?request=" + Ut(JSON.stringify(e)),
      "futureverse_wallet",
      "popup,right=0,width=480,height=496,menubar=no,toolbar=no,location=no,status=0"
    ), this._popup == null)
      throw new Error("Failed to open popup");
    const n = setInterval(() => {
      var r;
      (r = this._popup) != null && r.closed && (clearInterval(n), this.cancelAll(), this._popup = null);
    }, 1e3);
  }
  cancelAll() {
    this._pending.forEach((e, n) => {
      e.handler({
        id: n,
        tag: e.tag,
        payload: { tag: "error", error: { code: "USER_REJECTED" } }
      });
    }), this._pending.clear();
  }
}
function Ut(t) {
  return btoa(t || "").replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/g, "");
}
function Q() {
  try {
    return new URL(window.location.href).hostname;
  } catch {
    return null;
  }
}
class pe extends g {
  constructor(e) {
    super(), this.wallet = e;
  }
  /**
   * Signs a message using XRPL wallet.
   *
   * @param message - The message to be signed.
   * @returns The signed message in hexadecimal format.
   * @throws Error if XRPL wallet is not found.
   */
  async signMessage(e) {
    if (!this.wallet)
      throw new Error("XRPL wallet not found");
    const n = me(e), s = [
      {
        Memo: {
          MemoType: b("message"),
          MemoData: n
        }
      }
    ], r = {
      Account: this.wallet.classicAddress,
      // required for Transaction
      TransactionType: "TicketCreate",
      // can use any valid transaction type here, but TicketCreate have the least required fields
      TicketCount: 1,
      // required field for TicketCreate
      Memos: s,
      // holds the message
      AccountTxnID: "0000000000000000000000000000000000000000000000000000000000000000"
    };
    return this.wallet.sign(r).tx_blob;
  }
  /**
   * Verifies the signature of a signable message.
   *
   * @param message - The signable message to verify.
   * @param signature - The signature to verify against the message.
   * @throws {Error} If the transaction is missing a signature or the message does not match.
   * @returns An object containing the Ethereum address and XRPL account associated with the signature.
   */
  static async verifySignature(e, n) {
    const s = ye(e), r = ke(n), i = r.Memos;
    let o;
    if (i && i.length > 0) {
      const d = i[0].Memo.MemoData;
      d && (o = B(d));
    }
    if (o !== s)
      throw new Error("Message does not match");
    if (typeof r.TxnSignature != "string" || !r.TxnSignature)
      throw new Error("Transaction is missing a signature, TxnSignature");
    if (typeof r.SigningPubKey != "string" || !r.SigningPubKey)
      throw new Error("Transaction is missing a public key, SigningPubKey");
    if (!ne(
      se(r),
      r.TxnSignature,
      r.SigningPubKey
    ))
      throw new Error("Signature verification failed");
    const [c] = we(r.SigningPubKey), u = r.Account;
    return {
      ethAddress: c,
      accounts: [c, u]
    };
  }
  verifySignature(e, n) {
    return pe.verifySignature(e, n);
  }
  /**
   * Retrieves the address associated with the XRPL wallet.
   *
   * @returns A promise that resolves to a string representing the XRPL wallet address, or undefined if the wallet is not found.
   * @throws An error with the message 'XRPL wallet not found' if the wallet is not available.
   */
  async getAddress() {
    if (!this.wallet)
      throw new Error("XRPL wallet not found");
    return this.wallet.classicAddress;
  }
}
export {
  qt as FutureverseCustodialSigner,
  Nt as KeyringSigner,
  g as Signer,
  Kt as ViemSigner,
  Tt as WalletSigner,
  pe as XRPLSigner,
  E as XamanSigner,
  jt as clientToSigner,
  we as deriveAddressPair,
  Pt as isValidSignature,
  me as signableMessageToHex,
  ye as signableMessageToString
};
