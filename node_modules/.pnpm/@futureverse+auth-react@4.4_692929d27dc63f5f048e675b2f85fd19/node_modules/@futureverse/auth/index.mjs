import { CookieStorage as E } from "cookie-storage";
import { jwtDecode as v } from "jwt-decode";
import { ErrorTimeout as x, WebStorageStateStore as y, UserManagerSettingsStore as O, UserManager as C, ErrorResponse as H, SigninResponse as B } from "oidc-client-ts";
import { User as se } from "oidc-client-ts";
import { defineChain as w } from "viem";
import { rootPorcini as R, root as A } from "viem/chains";
import { z as r } from "zod";
const P = 17672, f = "https://porcini.devnet.rootnet.app/", b = "wss://porcini.devnet.rootnet.app/ws", Z = w({
  id: P,
  name: "Porcini Devnet (Testnet)",
  network: "sprout-1",
  nativeCurrency: {
    name: "XRP",
    symbol: "XRP",
    decimals: 18
    // XRP has 6 decimals, but the EVM layer of TRN handles the conversion
  },
  rpcUrls: {
    default: {
      http: [f],
      webSocket: [b]
    },
    public: {
      http: [f],
      webSocket: [b]
    },
    archive: {
      http: [`${f}/archive`],
      webSocket: ["wss://porcini.devnet.rootnet.app/archive/ws"]
    }
  },
  contracts: {
    ensRegistry: { address: "0xA931c1F9621ECa562c258B81bF9fA8401f12241B" },
    ensUniversalResolver: {
      address: "0xB3c0AE882b35E72B7b84F7A1E0cF01fBDC617170",
      blockCreated: 11983898
    }
  }
}), h = w({
  ...R,
  rpcUrls: {
    default: {
      http: ["https://porcini.rootnet.app"],
      webSocket: ["wss://porcini.rootnet.app/ws"]
    },
    archive: {
      http: ["https://porcini.rootnet.app/archive"],
      webSocket: ["wss://porcini.rootnet.app/archive/ws"]
    }
  },
  contracts: {
    ...R.contracts,
    ensBaseRegistrarImplementation: {
      address: "0x4420F023F0133F741e182f721b1DC2D3942fcb5A"
    },
    ensBulkRenewal: {
      address: "0xA7eA86ef8BeD3B3E36e8B08B108da297B8dC5A9a"
    },
    ensEthRegistrarController: {
      address: "0xd64FA152497175B18352F44D720e55bc67faB7EB"
    },
    ensNameWrapper: {
      address: "0xBDC394b7704d3E0DC963a6Cb0Db92cBA2054da23"
    },
    ensPublicResolver: {
      address: "0xaEb82E192d9DbA65478559034924e365bE366E5a"
    },
    ensRegistry: {
      address: "0xA931c1F9621ECa562c258B81bF9fA8401f12241B"
    },
    ensReverseRegistrar: {
      address: "0xDa3E37B6aA86749efF54b48983bcB908bB501c8a"
    },
    ensUniversalResolver: {
      address: "0xB3c0AE882b35E72B7b84F7A1E0cF01fBDC617170"
    },
    ensDnsRegistrar: {
      address: "0xB32cB5677a7C971689228EC835800432B339bA2B"
    },
    ensDnssecImpl: {
      address: "0x0fc3152971714E5ed7723FAFa650F86A4BaF30C5"
    }
  }
}), D = w({
  ...A,
  rpcUrls: {
    default: {
      http: ["https://root.rootnet.live"],
      webSocket: ["wss://root.rootnet.live/ws"]
    },
    archive: {
      http: ["https://root.rootnet.live/archive"],
      webSocket: ["wss://root.rootnet.live/archive/ws"]
    }
  },
  contracts: {
    ...A.contracts,
    ensBaseRegistrarImplementation: {
      address: "0xEeD3C3c547751e23020f4cb506FbA37baEb3308D"
    },
    ensBulkRenewal: {
      address: "0x0193eFBF9504422700295C022766891b0b10049F"
    },
    ensEthRegistrarController: {
      address: "0xc85E5802BADE56Facb93bb373da6bA7c1902b19c"
    },
    ensNameWrapper: {
      address: "0x44640D662A423d738D5ebF8B51E57AfC0f2cf4Df"
    },
    ensPublicResolver: {
      address: "0x870bC2604D6EAC536c791A603bFDE1A1448e168e"
    },
    ensRegistry: {
      address: "0xEC58C26B8E0A4bc0fe1ad21D216e4ecAd9e037A8"
    },
    ensReverseRegistrar: {
      address: "0xfFF7719aaB38eadE6A1CfdA864a174B715e9d673"
    },
    ensUniversalResolver: {
      address: "0x7808dF0A1F1d58c6Ad0F3bA07E749D730F02f13A"
    },
    ensDnsRegistrar: {
      address: "0xB32cB5677a7C971689228EC835800432B339bA2B"
    },
    ensDnssecImpl: {
      address: "0x0fc3152971714E5ed7723FAFa650F86A4BaF30C5"
    }
  }
}), N = Object.freeze({
  production: {
    idpURL: "https://login.pass.online",
    signerURL: "https://signer.pass.online",
    chain: D
  },
  staging: {
    idpURL: "https://login.passonline.cloud",
    signerURL: "https://signer.passonline.cloud",
    chain: h
  },
  development: {
    idpURL: "https://login.passonline.dev",
    signerURL: "https://signer.passonline.dev",
    chain: h
  },
  neptune: {
    idpURL: "https://login.passonline.red",
    signerURL: "https://signer.passonline.red",
    chain: h
  },
  audit: {
    chain: h,
    idpURL: "https://login.futureverse.kiwi",
    signerURL: "https://signer.futureverse.kiwi"
  }
}), c = Object.freeze({
  REDIRECT_FLOW: "redirect",
  SILENT_FLOW: "silent",
  POPUP_FLOW: "popup"
}), d = Object.freeze({
  QUERY: "query",
  FRAGMENT: "fragment",
  FORM_POST: "form_post",
  WEB_MESSAGE: "web_message"
}), I = r.union([r.literal("fv"), r.literal("self")]), W = r.object({
  eoa: r.string(),
  sub: r.string(),
  custodian: I,
  chainId: r.number(),
  futurepass: r.string(),
  nonce: r.string().optional(),
  s_hash: r.string().optional(),
  at_hash: r.string().optional(),
  aud: r.string(),
  exp: r.number(),
  iat: r.number(),
  iss: r.string()
}), J = r.object({
  eoa: r.string(),
  chainId: r.number(),
  custodian: I,
  futurepass: r.string()
}), g = (m = window.location.href) => {
  const t = new URL(m, "http://127.0.0.1").search;
  return new URLSearchParams(t.slice(1));
}, k = "authorization_response", T = "logout_response";
class p {
  constructor({
    silentRequestTimeoutInSeconds: e = 10
  }) {
    this._window = null, this._disposeHandlers = /* @__PURE__ */ new Set(), this.getResponseFromIframe = async (t) => new Promise((n, i) => {
      const o = setTimeout(() => {
        i(new x("IFrame timed out without a response"));
      }, this._timeoutInSeconds * 1e3);
      this._disposeHandlers.add(() => clearTimeout(o));
      const a = (u) => {
        var S;
        const l = u.data;
        if (![T, k].includes(l.type))
          return;
        if (l.type == T)
          return n({
            url: new URL("", "http://127.0.0.1").href
          });
        const F = g(l.url), _ = ((S = l.response) == null ? void 0 : S.state) || F.get("state");
        (!_ || _ !== t.state) && (this._dispose(), i(new Error("Invalid response from window")));
        const M = this.handleSignin(l);
        n({
          url: M
        });
      };
      window.addEventListener("message", a, !1), this._disposeHandlers.add(
        () => window.removeEventListener("message", a, !1)
      );
    }), this._timeoutInSeconds = e, this._frame = p.createHiddenIframe(), this._window = this._frame.contentWindow;
  }
  static createHiddenIframe() {
    const e = window.document.createElement("iframe");
    return e.style.visibility = "hidden", e.style.position = "fixed", e.style.left = "-1000px", e.style.top = "0", e.width = "0", e.height = "0", window.document.body.appendChild(e), e;
  }
  handleSignin(e) {
    var s;
    const t = g(e.url);
    return e.response ? `?${new URLSearchParams({
      ...e.response,
      session_state: (s = e.response) != null && s.code ? "active" : ""
    }).toString()}` : t.get("code") ? (t.append("session_state", "active"), `?${t.toString()}`) : "";
  }
  async navigate(e) {
    if (!this._window)
      throw new Error("Attempted to navigate on a disposed window");
    this._window.location.replace(e.url);
    const t = await this.getResponseFromIframe(e);
    return this._dispose(), this.close(), t;
  }
  _dispose() {
    for (const e of this._disposeHandlers)
      e();
    this._disposeHandlers.clear();
  }
  close() {
    var e;
    this._frame && (this._frame.parentNode && (this._frame.addEventListener(
      "load",
      (t) => {
        var n;
        const s = t.target;
        (n = s.parentNode) == null || n.removeChild(s);
      },
      !0
    ), (e = this._frame.contentWindow) == null || e.location.replace("about:blank")), this._frame = null), this._window = null;
  }
  static notifyParent(e, t = window.location.origin) {
    window.parent.postMessage(
      {
        type: k,
        url: e,
        keepOpen: !1
      },
      t
    );
  }
}
class $ {
  constructor(e) {
    this._settings = e;
  }
  async callback(e) {
    var t;
    p.notifyParent(e, (t = this._settings) == null ? void 0 : t.iframeNotifyParentOrigin);
  }
  async prepare(e) {
    return new p(e);
  }
}
const q = 30 * 1e3, Q = 60 * 60 * 1e3, U = 24 * 60 * 60 * 1e3;
class L {
  constructor(e) {
    this._userStateHandler = [], this._notifiedSignedOut = !1, this._remoteSessionEventHandler = [], this._authLifecycleEventHandler = [], this.idTokenRenewTimer = null, this.getUserFromToken = (i) => W.parse(v(i));
    const {
      environment: t = "production",
      signInFlow: s = c.REDIRECT_FLOW
    } = e;
    if (this.flow = s, this.environmentName = t, this.environment = { ...N[t] }, this.config = e, e.authority && (this.environment.idpURL = e.authority), e.signerAuthority && (this.environment.signerURL = e.signerAuthority), !this.environment)
      throw new Error(`Invalid environment ${t}`);
    this.renewingIdToken = !1, this.userManagerSettings = {
      post_logout_redirect_uri: e.postLogoutRedirectUri,
      client_id: e.clientId,
      redirect_uri: e.redirectUri,
      response_type: e.responseType,
      authority: `${this.environment.idpURL}`,
      scope: "openid",
      automaticSilentRenew: !0,
      userStore: new y({
        store: e.userStore ?? new E({
          path: "/",
          sameSite: "Strict",
          expires: new Date(Date.now() + U)
        }),
        prefix: "fv."
      }),
      stateStore: new y({
        store: e.stateStore ?? new E({
          path: "/",
          sameSite: "Strict",
          expires: new Date(Date.now() + U)
        }),
        prefix: "fv."
      })
    }, e.clientSecret != null && (this.userManagerSettings = {
      disablePKCE: !0,
      client_secret: e.clientSecret,
      ...this.userManagerSettings
    });
    const n = new O(
      this.userManagerSettings
    );
    this.iframeNavigator = new $(n), this._userManager = new C(
      this.userManagerSettings,
      e.redirectNavigator,
      e.popupNavigator,
      this.iframeNavigator
    ), this._userManager.events.addUserLoaded(this._userLoaded.bind(this)), this._userManager.events.addUserUnloaded(this._userUnloaded.bind(this));
  }
  get OIDCManager() {
    return this._userManager;
  }
  setState(e) {
    this.state = e;
  }
  setExtraQueryParams(e) {
    this.extraQueryParams = e;
  }
  async queryCustodialOptions() {
    return await fetch(`${this._userManager.settings.authority}/auth-options`, {
      headers: {
        "x-client-id": this._userManager.settings.client_id
      }
    }).then((e) => {
      if (e.ok === !1)
        throw new Error("Failed to load custodial options from authority");
      return e.json();
    }).catch((e) => (console.error(
      `Failed to fetch ${this._userManager.settings.authority}/auth-options`,
      e
    ), []));
  }
  async signInFuturepassSilent(e) {
    try {
      this.updateAuthLifecycleEventHandlers("sign-in:start");
      const t = {
        responseMode: d.WEB_MESSAGE,
        authFlow: c.SILENT_FLOW,
        ...e
      }, s = await this.generateFuturepassSignInArgs(t);
      return await this._userManager.signinSilent(s);
    } finally {
      this.updateAuthLifecycleEventHandlers("sign-in:end");
    }
  }
  async signInFuturepassRedirect(e) {
    try {
      this.updateAuthLifecycleEventHandlers("sign-in:start");
      const t = await this.generateFuturepassSignInArgs(e);
      await this._userManager.signinRedirect(t);
    } finally {
      this.updateAuthLifecycleEventHandlers("sign-in:end");
    }
  }
  async signInFuturepassPopup(e) {
    try {
      this.updateAuthLifecycleEventHandlers("sign-in:start");
      const t = await this.generateFuturepassSignInArgs(e);
      return await this._userManager.signinPopup({ ...t });
    } finally {
      this.updateAuthLifecycleEventHandlers("sign-in:end");
    }
  }
  async signInPass(e) {
    const {
      address: t,
      authFlow: s = this.flow,
      extraQueryParams: n,
      responseMode: i = d.QUERY,
      signer: o,
      type: a
    } = e;
    return s === c.POPUP_FLOW ? await this.signInFuturepassPopup({
      type: a,
      signer: o,
      address: t,
      state: this.state,
      extraQueryParams: n,
      responseMode: i
    }) : s === c.SILENT_FLOW ? await this.signInFuturepassSilent({
      state: this.state
    }) : await this.signInFuturepassRedirect({
      type: a,
      signer: o,
      address: t,
      state: this.state,
      extraQueryParams: n,
      responseMode: i
    });
  }
  getSessionAuthType() {
    var e;
    if ((e = this.userSession) != null && e.user)
      return L.getAuthType(this.userSession.user);
  }
  static getAuthType(e) {
    const t = e.profile.sub.split(":");
    return t[0] === "eoa" && t.length === 2 || t[0] === "xrpl" && t[2] === "eoa" ? "eoa" : t[0] === "email" ? "email" : (t[0] === "idp", t[1]);
  }
  static getCustodyType(e) {
    const t = e.profile.sub.split(":");
    return t[0] === "email" || t[0] === "idp" ? "Custodial" : "SelfCustodial";
  }
  async generateEOALoginHint(e, t) {
    function s(i) {
      const a = i.replace(/^(?:\w+:)?\/\//, "").match(/^([^/:]+)/);
      return a ? a[1] : null;
    }
    const n = s(this.config.redirectUri) ?? "";
    return t.signPassOIDC({
      address: e.address,
      idpURL: this.environment.idpURL,
      chainId: this.environment.chain.id,
      domain: n
    });
  }
  async generateFuturepassSignInArgs(e) {
    let t = "", s;
    switch (e.type) {
      case "eoa":
        {
          if (!e.signer)
            throw new Error("Must have signer for externally owned address");
          const i = await this.generateEOALoginHint(e, e.signer);
          t = i.hint, s = i.nonce;
        }
        break;
      case "email":
        t = "email:";
        break;
      case "facebook":
        t = `social:${e.type}`;
        break;
      case "google":
        t = `social:${e.type}`;
        break;
      case "tiktok":
        t = `social:${e.type}`;
        break;
      case "x":
        t = "social:twitter";
        break;
      default:
        t = e.type || "";
        break;
    }
    const n = {
      ...e.extraQueryParams,
      ...this.extraQueryParams
    };
    return {
      prompt: e.authFlow == c.SILENT_FLOW ? "none" : "login",
      nonce: s,
      login_hint: t,
      scope: "openid",
      state: (e == null ? void 0 : e.state) || this.state,
      response_mode: e.responseMode || d.QUERY,
      ...Object.keys(n).length > 0 && { extraQueryParams: n }
    };
  }
  /**
   * Deprecated in favor of signOutPass
   * @deprecated
   */
  async signOut(e = { flow: "redirect" }) {
    var t;
    try {
      if (this.updateAuthLifecycleEventHandlers("sign-out:start"), await this._userManager.removeUser(), await ((t = e.onBeforeRedirect) == null ? void 0 : t.call(e)), e.flow === "redirect") {
        window.location.href = `${this.environment.idpURL}/logout`;
        return;
      }
      await this._userManager.signoutSilent();
    } finally {
      this.updateAuthLifecycleEventHandlers("sign-out:end");
    }
  }
  async signOutPass(e = {
    flow: c.REDIRECT_FLOW,
    disableConsent: !0
  }) {
    var t;
    this.updateAuthLifecycleEventHandlers("sign-out:start");
    try {
      if (await ((t = e.onBeforeRedirect) == null ? void 0 : t.call(e)), e.flow === c.REDIRECT_FLOW) {
        await this._userManager.signoutRedirect({
          ...e.postRedirecturi ? { post_logout_redirect_uri: e.postRedirecturi } : {},
          extraQueryParams: {
            ...e.disableConsent ? { disable_consent: !0 } : {}
          }
        });
        return;
      }
      await this._userManager.signoutSilent({
        extraQueryParams: {
          response_mode: d.WEB_MESSAGE
        }
      });
    } finally {
      this.updateAuthLifecycleEventHandlers("sign-out:end");
    }
  }
  async getUser() {
    return await this._userManager.getUser();
  }
  async loadUser(e) {
    let t = await this._userManager.getUser();
    if (!t)
      try {
        const s = await this._userManager.signinCallback(e);
        s && (t = s);
      } catch {
      }
    return this._userManager.startSilentRenew(), this._updateUserSession(t ?? void 0);
  }
  querySessionStatus() {
    return this._userManager.querySessionStatus({
      response_mode: d.WEB_MESSAGE
    });
  }
  /**
   * Verifies and synchronizes the local user session with the remote session state.
   *
   * @returns {Promise<UserSession | null>} The current user session or `null` if none exists.
   */
  async verifyAndLoadUser() {
    try {
      if (await this.handleCallback())
        return this.userSession;
      if (!await this.isLocalSessionActiveOnIDP())
        return await this.removeLocalUserSession(), await this.queryRemoteActiveSession(), this.userSession;
      const s = await this._userManager.getUser();
      return s ? this._updateUserSession(s) : this._updateUserSession();
    } catch (e) {
      return e instanceof H && await this._userManager.removeUser(), this._updateUserSession(), this.userSession;
    }
  }
  /**
   * Processes the redirect callback to handle authentication results.
   * Updates the user session or clears it on error.
   *
   * @returns Promise resolving to `true` if handled, otherwise `false`.
   */
  async handleCallback() {
    const e = g(), { state: t, code: s, error: n } = new B(e), i = await this._userManager.settings.stateStore.get(
      t || ""
    );
    if (!(t && i && (s || n)))
      return !1;
    const a = await this._userManager.signinCallback();
    return a ? (this._updateUserSession(a), !0) : (n && this._updateUserSession(), !1);
  }
  /**
   * Removes the local user session
   *
   * @returns {Promise<void>} A promise that resolves when the user session is removed.
   */
  async removeLocalUserSession() {
    this._updateUserSession(), await this._userManager.removeUser();
  }
  /**
   * Queries the remote active session.
   *
   * @param args - Optional arguments for the silent request.
   * @returns A promise resolving to `FVIdTokenClaims` if active, or `null`.
   */
  async queryRemoteActiveSession(e) {
    var i;
    const t = await this.iframeNavigator.prepare({
      silentRequestTimeoutInSeconds: e == null ? void 0 : e.silentRequestTimeoutInSeconds
    }), s = await this._userManager._client.createSigninRequest({
      request_type: "si:s",
      redirect_uri: this.userManagerSettings.silent_redirect_uri,
      prompt: "none",
      id_token_hint: void 0,
      scope: "openid",
      skipUserInfo: !0,
      response_mode: d.WEB_MESSAGE,
      ...e
    });
    let n = null;
    try {
      const o = await t.navigate({
        url: s.url,
        state: s.state.id,
        response_mode: s.state.response_mode,
        scriptOrigin: this.userManagerSettings.iframeScriptOrigin
      }), a = {}, u = await this._userManager._client.processSigninResponse(o.url, a);
      return u.session_state === "active" && !u.error && (n = u.profile), n;
    } catch {
      return await ((i = this.userManagerSettings.stateStore) == null ? void 0 : i.remove(s.state.id)), n;
    } finally {
      t.close(), this.updateRemoteSessionHandlers(n);
    }
  }
  /**
   * Checks if a local session is active on the IDP by validating the user's access and refresh tokens.
   *
   * @returns A promise resolving to `true` if active, otherwise `false`.
   */
  async isLocalSessionActiveOnIDP() {
    const e = await this.getUser();
    return e ? !e.expired && await this.isTokenActive(e.access_token) ? !0 : e.refresh_token ? !!await this.isTokenActive(e.refresh_token) : !1 : !1;
  }
  /**
   * Checks if the provided token is active by making a request to the token introspection endpoint.
   *
   * @param token - The token to be introspected.
   * @returns A promise that resolves to a boolean indicating whether the token is active.
   * @throws An error if the token introspection request fails.
   */
  async isTokenActive(e) {
    const t = await fetch(
      `${this.environment.idpURL}/token/introspection`,
      {
        method: "POST",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded"
        },
        body: new URLSearchParams({
          token: e,
          client_id: this.config.clientId
        })
      }
    );
    if (!t.ok)
      throw new Error("Failed to introspect token");
    return (await t.json()).active;
  }
  addUserStateListener(e) {
    this._userStateHandler.push(e);
  }
  removeUserStateListener(e) {
    const t = this._userStateHandler.indexOf(e);
    t > -1 && this._userStateHandler.splice(t, 1);
  }
  addRemoteSessionListener(e) {
    this._remoteSessionEventHandler.push(e);
  }
  removeRemoteSessionListener(e) {
    const t = this._remoteSessionEventHandler.indexOf(e);
    t > -1 && this._remoteSessionEventHandler.splice(t, 1);
  }
  updateRemoteSessionHandlers(e) {
    this._remoteSessionEventHandler.forEach((t) => {
      t(e);
    });
  }
  addAuthLifecycleEventListener(e) {
    this._authLifecycleEventHandler.push(e);
  }
  removeAuthLifecycleEventListener(e) {
    const t = this._authLifecycleEventHandler.indexOf(e);
    t > -1 && this._authLifecycleEventHandler.splice(t, 1);
  }
  updateAuthLifecycleEventHandlers(e) {
    this._authLifecycleEventHandler.forEach((t) => {
      t(e);
    });
  }
  _sessionFromUser(e) {
    if (!e)
      return;
    const t = e.profile, s = t.eoa, n = t.futurepass, i = t.chainId, o = t.custodian;
    return {
      eoa: s,
      chainId: i,
      custodian: o,
      futurepass: n,
      linked: [{ eoa: s, chainId: i }],
      user: e
    };
  }
  _userLoaded(e) {
    this._updateUserSession(e);
  }
  _userUnloaded() {
    this._userManager.stopSilentRenew(), this._updateUserSession();
  }
  _updateUserSession(e) {
    var s, n;
    e ? this.startIdTokenRenewTimer(e) : this.stopIdTokenRenewTimer();
    const t = this._sessionFromUser(e);
    return this.userSession && ((s = this.userSession.user) == null ? void 0 : s.access_token) === ((n = t == null ? void 0 : t.user) == null ? void 0 : n.access_token) ? this.userSession : (this.userSession = t, this._updateHandlers(), this.userSession);
  }
  _updateHandlers() {
    if (!this.userSession) {
      if (this._notifiedSignedOut)
        return;
      this._notifiedSignedOut = !0;
    }
    this._userStateHandler.forEach((e) => {
      e(this.userSession);
    }), this.userSession && (this._notifiedSignedOut = !1);
  }
  /**
   * Asynchronously renews the ID token.
   *
   * @returns {Promise<string | null>} A Promise that resolves to the renewed ID token or null if the token renewal is ignored or unsuccessful.
   */
  async renewIdToken() {
    if (this.renewingIdToken)
      return null;
    try {
      this.renewingIdToken = !0;
      const e = await this.signInFuturepassSilent(), t = e == null ? void 0 : e.id_token;
      if (t == null)
        throw new Error("cannot renew idToken");
      return t;
    } catch {
      try {
        await this._userManager.signoutSilent();
      } catch {
      } finally {
        this._updateUserSession();
      }
    } finally {
      this.renewingIdToken = !1;
    }
    return null;
  }
  /**
   * Asynchronously renews the ID token if required, based on the expiration time.
   * Renew iD Token if expiry <= 1 hour.
   * Return existing token if expiry is > 1 hour.
   *
   * @returns {Promise<string | null>} A Promise that resolves to the renewed ID token or the existing token if renewal is not required or unsuccessful.
   */
  async renewIdTokenIfRequired() {
    var s, n;
    const e = (n = (s = this.userSession) == null ? void 0 : s.user) == null ? void 0 : n.id_token;
    return e == null ? null : this.getRenewInMS(e, "manual") === 0 ? await this.renewIdToken() : e;
  }
  /**
   * Calculates the time, in milliseconds, until the ID token should be renewed.
   *
   * @param {string} idToken - The ID token for which to calculate the renewal time.
   * @param {'auto' | 'manual'} type - The type of renew threshold to use. default: `auto`
   * @returns {number} The time, in milliseconds, until the ID token should be renewed. Returns 0 if the token is expired.
   */
  getRenewInMS(e, t = "auto") {
    const n = (v(e).exp ?? 0) * 1e3, i = Date.now(), a = i > n ? 0 : n - i - (t === "auto" ? q : Q);
    return Math.max(a, 0);
  }
  /**
   * Starts a timer that would refresh the ID-Token in future.
   * If it fails to re-new the ID-Token then it would force the application to sign out.
   *
   * @private
   * @param {User} user - The user object containing the ID token and expiration details.
   * @returns {void}
   */
  startIdTokenRenewTimer(e) {
    var o, a;
    const t = (a = (o = this.userSession) == null ? void 0 : o.user) == null ? void 0 : a.id_token, s = e.id_token;
    if (t != null && s != null && t == s && this.idTokenRenewTimer != null)
      return;
    const n = e.id_token;
    if (n == null)
      return;
    const i = this.getRenewInMS(n, "auto");
    this.idTokenRenewTimer != null && clearTimeout(this.idTokenRenewTimer), this.idTokenRenewTimer = setTimeout(async () => {
      await this.renewIdToken();
    }, i);
  }
  /**
   * Stops the timer responsible for renewing the ID token.
   *
   * @private
   * @returns {void}
   */
  stopIdTokenRenewTimer() {
    this.idTokenRenewTimer && clearTimeout(this.idTokenRenewTimer);
  }
}
export {
  N as ENVIRONMENTS,
  c as FLOW_TYPES,
  L as FutureverseAuthClient,
  se as OIDCUser,
  d as RESPONSE_MODES,
  I as custodianSchema,
  W as identityTokenSchema,
  h as porcini,
  Z as porciniDevNet,
  D as root,
  J as userSchema
};
