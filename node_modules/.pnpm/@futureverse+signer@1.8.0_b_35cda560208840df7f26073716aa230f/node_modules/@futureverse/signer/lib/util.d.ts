import { Account, Chain, Client, Hex, RpcSchema, SignableMessage, Transport } from 'viem';
import { Signer } from './signers';
export type SignerClient = Client<Transport, Chain, Account, RpcSchema, {
    signer?: Signer;
    signMessage?: (params: {
        message: SignableMessage;
    }) => Promise<Hex>;
}>;
export declare function clientToSigner(client: SignerClient): Signer;
/**
 * Converts the given message to a hexadecimal representation.
 *
 * If the `message` is already in hexadecimal format, it is returned as is.
 * If the `message` is a string, it is converted to hexadecimal.
 * If the `message` is a Uint8Array, it is converted to a string and then to hexadecimal.
 *
 * @param message - The message to be converted.
 * @returns The hexadecimal representation of the message.
 */
export declare function signableMessageToHex(message: SignableMessage): string;
/**
 * Converts the given `message` to a string representation.
 *
 * If `message` is already a string, it is returned as is.
 * If `message` is a hexadecimal string, it is converted to a string representation.
 * If `message` is a Uint8Array, it is converted to a string representation.
 *
 * @param message - The message to convert.
 * @returns The string representation of the message.
 */
export declare function signableMessageToString(message: SignableMessage): string;
/**
 * Derives a pair of addresses (ETH and XRPL) from a given public key.
 *
 * 1. Removes '0x' prefix if present in the public key
 * 2. Derives XRPL address from deriveAddress
 * 3. Checks if public key is type ED25519 using 'ed' prefix
 *    - If ED25519, compress the key using keccak256 and derive address
 *    - If non-ED25519, directly encode the key into an Ethereum address
 *
 * @param publicKey - The public key in hexadecimal form.
 * @returns Returns an array containing the Ethereum address and the XRPL address derived from a public key.
 */
export declare function deriveAddressPair(publicKey: string): string[];
