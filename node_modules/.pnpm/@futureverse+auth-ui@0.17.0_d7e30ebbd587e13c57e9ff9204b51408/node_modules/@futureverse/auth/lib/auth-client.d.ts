import { AsyncStorage, INavigator, SigninPopupArgs, SigninRedirectArgs, User, UserManager, QuerySessionStatusArgs, IdTokenClaims } from 'oidc-client-ts';
import { Environment, EnvironmentInfo } from './constants';
import { CustodialAuthOption, SignInOptions, UserSession, AuthFlowType, SignOutOptions } from './types';
export type AuthClientConfig = {
    clientId: string;
    redirectUri: string;
    environment?: Environment;
    /**
     * Identity provider OIDC/OAuth2 provider URL
     * - **Default**: Taken from the environment setting
     */
    authority?: string;
    /**
     * Signer provider URL
     * - **Default**: Taken from the environment setting
     */
    signerAuthority?: string;
    responseType?: 'code' | 'id_token';
    userStore?: AsyncStorage | Storage;
    stateStore?: AsyncStorage | Storage;
    popupNavigator?: INavigator;
    redirectNavigator?: INavigator;
    clientSecret?: string;
    signInFlow?: AuthFlowType;
    postLogoutRedirectUri?: string;
};
export type UserStateEventHandler = (user?: UserSession) => void;
export type RemoteActiveSessionEventHandler = (remoteSession: FVIdTokenClaims | null) => void;
export type AuthLifecycleEvent = 'sign-in:start' | 'sign-in:end' | 'sign-out:start' | 'sign-out:end';
export type AuthLifecycleEventEventHandler = (event: AuthLifecycleEvent) => void;
export type FVProfile = {
    handle: string;
    rns?: {
        name: string;
    };
    selectedProfile?: {
        displayName: string;
        avatar?: {
            asset?: {
                imageUrl: string;
            };
        };
    };
};
export type FVIdTokenClaims = Omit<IdTokenClaims, 'profile'> & {
    profile?: FVProfile | null;
};
export declare class FutureverseAuthClient {
    private _userManager;
    private _userStateHandler;
    private _notifiedSignedOut;
    private _remoteSessionEventHandler;
    private _authLifecycleEventHandler;
    environment: EnvironmentInfo;
    environmentName: Environment;
    userSession?: UserSession;
    renewingIdToken: boolean;
    private iframeNavigator;
    private userManagerSettings;
    private idTokenRenewTimer;
    state?: unknown;
    extraQueryParams?: Record<string, string>;
    flow: AuthFlowType;
    config: AuthClientConfig;
    constructor(config: AuthClientConfig);
    get OIDCManager(): UserManager;
    setState<T = unknown>(state: T): void;
    setExtraQueryParams(params: Record<string, string>): void;
    queryCustodialOptions(): Promise<CustodialAuthOption[]>;
    signInFuturepassSilent<T = object>(opts?: SignInOptions<T>): Promise<User | null>;
    signInFuturepassRedirect<T = object>(opts: SignInOptions<T>): Promise<void>;
    signInFuturepassPopup<T = object>(opts: SignInOptions<T>): Promise<User>;
    signInPass<T = object>(opts: SignInOptions<T>): Promise<void | User | null>;
    getSessionAuthType(): string | undefined;
    static getAuthType(user: User): string | undefined;
    static getCustodyType(user: User): "Custodial" | "SelfCustodial";
    private generateEOALoginHint;
    generateFuturepassSignInArgs<T = object>(opts: SignInOptions<T> & SigninRedirectArgs & SigninPopupArgs): Promise<{
        extraQueryParams?: {
            [x: string]: string | number | boolean;
        } | undefined;
        prompt: string;
        nonce: string | undefined;
        login_hint: string;
        scope: string;
        state: unknown;
        response_mode: import('./types').OIDCResponseModes;
    }>;
    /**
     * Deprecated in favor of signOutPass
     * @deprecated
     */
    signOut(opts?: {
        onBeforeRedirect?: () => Promise<void>;
        flow?: 'silent' | 'redirect';
    }): Promise<void>;
    signOutPass(opts?: SignOutOptions): Promise<void>;
    getUser(): Promise<User | null>;
    loadUser(redirectUrl?: string): Promise<UserSession | undefined>;
    querySessionStatus(): Promise<import('oidc-client-ts').SessionStatus | null>;
    /**
     * Verifies and synchronizes the local user session with the remote session state.
     *
     * @returns {Promise<UserSession | null>} The current user session or `null` if none exists.
     */
    verifyAndLoadUser(): Promise<UserSession | undefined>;
    /**
     * Processes the redirect callback to handle authentication results.
     * Updates the user session or clears it on error.
     *
     * @returns Promise resolving to `true` if handled, otherwise `false`.
     */
    private handleCallback;
    /**
     * Removes the local user session
     *
     * @returns {Promise<void>} A promise that resolves when the user session is removed.
     */
    private removeLocalUserSession;
    /**
     * Queries the remote active session.
     *
     * @param args - Optional arguments for the silent request.
     * @returns A promise resolving to `FVIdTokenClaims` if active, or `null`.
     */
    queryRemoteActiveSession(args?: QuerySessionStatusArgs): Promise<FVIdTokenClaims | null>;
    /**
     * Checks if a local session is active on the IDP by validating the user's access and refresh tokens.
     *
     * @returns A promise resolving to `true` if active, otherwise `false`.
     */
    isLocalSessionActiveOnIDP(): Promise<boolean>;
    /**
     * Checks if the provided token is active by making a request to the token introspection endpoint.
     *
     * @param token - The token to be introspected.
     * @returns A promise that resolves to a boolean indicating whether the token is active.
     * @throws An error if the token introspection request fails.
     */
    isTokenActive(token: string): Promise<any>;
    addUserStateListener(cb: UserStateEventHandler): void;
    removeUserStateListener(cb: UserStateEventHandler): void;
    addRemoteSessionListener(cb: RemoteActiveSessionEventHandler): void;
    removeRemoteSessionListener(cb: RemoteActiveSessionEventHandler): void;
    updateRemoteSessionHandlers(remoteSession: FVIdTokenClaims | null): void;
    addAuthLifecycleEventListener(cb: AuthLifecycleEventEventHandler): void;
    removeAuthLifecycleEventListener(cb: AuthLifecycleEventEventHandler): void;
    updateAuthLifecycleEventHandlers(event: AuthLifecycleEvent): void;
    private _sessionFromUser;
    private _userLoaded;
    private _userUnloaded;
    private _updateUserSession;
    private _updateHandlers;
    getUserFromToken: (idToken: string) => {
        sub: string;
        chainId: number;
        eoa: string;
        custodian: "fv" | "self";
        futurepass: string;
        aud: string;
        exp: number;
        iat: number;
        iss: string;
        nonce?: string | undefined;
        s_hash?: string | undefined;
        at_hash?: string | undefined;
    };
    /**
     * Asynchronously renews the ID token.
     *
     * @returns {Promise<string | null>} A Promise that resolves to the renewed ID token or null if the token renewal is ignored or unsuccessful.
     */
    private renewIdToken;
    /**
     * Asynchronously renews the ID token if required, based on the expiration time.
     * Renew iD Token if expiry <= 1 hour.
     * Return existing token if expiry is > 1 hour.
     *
     * @returns {Promise<string | null>} A Promise that resolves to the renewed ID token or the existing token if renewal is not required or unsuccessful.
     */
    renewIdTokenIfRequired(): Promise<string | null>;
    /**
     * Calculates the time, in milliseconds, until the ID token should be renewed.
     *
     * @param {string} idToken - The ID token for which to calculate the renewal time.
     * @param {'auto' | 'manual'} type - The type of renew threshold to use. default: `auto`
     * @returns {number} The time, in milliseconds, until the ID token should be renewed. Returns 0 if the token is expired.
     */
    private getRenewInMS;
    /**
     * Starts a timer that would refresh the ID-Token in future.
     * If it fails to re-new the ID-Token then it would force the application to sign out.
     *
     * @private
     * @param {User} user - The user object containing the ID token and expiration details.
     * @returns {void}
     */
    private startIdTokenRenewTimer;
    /**
     * Stops the timer responsible for renewing the ID token.
     *
     * @private
     * @returns {void}
     */
    private stopIdTokenRenewTimer;
}
